{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"source/images/WechatAddMe.jpeg","path":"images/WechatAddMe.jpeg","modified":1,"renderable":0},{"_id":"source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/Beego源码解析-一-配置项初始化流程.md","hash":"37f5a9a174aa4c4a142a6ffcadb54185c43e00e5","modified":1645968040950},{"_id":"source/_posts/Beego源码解析-三-HTTP请求处理流程.md","hash":"9d78c0cd7627b6cd955fb7b56bdccc6f81f372e1","modified":1645968040950},{"_id":"source/_posts/Beego源码解析-二-路由机制.md","hash":"411df387249fca5e47ed56e5852cb0c4bce8e1c1","modified":1645968040950},{"_id":"source/_posts/我的第一个VLog.md","hash":"9a06625200c5e2d9125703c38f7b2e76e4d5be71","modified":1645968040951},{"_id":"source/_posts/Linux日志文件与Syslog函数介绍.md","hash":"84e1f44e780cd8df7402bee96aaa1bc7c5245670","modified":1645968040951},{"_id":"source/_posts/C++ 中的 static 关键字.md","hash":"715e66d660f2728debddc8bbc3a44f497f1e83f7","modified":1645971137381},{"_id":"source/_posts/初窥OS段页式管理概貌.md","hash":"0e186a1e098cfe120b317e75795f2c4259400834","modified":1645971180462},{"_id":"source/images/WechatAddMe.jpeg","hash":"3c8198bbdcfa47ad5f91195bee703d6f514586ae","modified":1645968040952},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1645970256555},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1645970256555},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1645970256558},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1645970256555},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1645970256558},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1645970256559},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1645970256558},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1645970256560},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1645970256559},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1645970256565},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1645970256582},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1645970256556},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1645970256556},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1645970256557},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1645970256557},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1645970256557},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1645970256557},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1645970256557},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1645970256557},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1645970256558},{"_id":"themes/next/_config.yml","hash":"a2db60577b189e30982bd304dba55d2da520d1f8","modified":1645971050270},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1645970256558},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1645970256558},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1645970256560},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1645970256560},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1645970256561},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1645970256561},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1645970256560},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1645970256561},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1645970256561},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1645970256561},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1645970256561},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1645970256565},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1645970256565},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1645970256565},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1645970256565},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1645970256566},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1645970256566},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1645970256566},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1645970256566},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1645970256566},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1645970256566},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1645970256567},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1645970256567},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1645970256567},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1645970256567},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1645970256567},{"_id":"themes/next/languages/tr.yml","hash":"2b041eeb8bd096f549464f191cfc1ea0181daca4","modified":1645970256568},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1645970256567},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1645970256568},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1645970256568},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1645970256568},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1645970256568},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1645970256569},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1645970256569},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1645970256581},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1645970256581},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1645970256581},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1645970256581},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1645970256581},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1645970256581},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1645970256585},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1645970256556},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1645970256556},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1645970256556},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1645970256556},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1645970256562},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1645970256562},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1645970256562},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1645970256562},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1645970256563},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1645970256563},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1645970256563},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1645970256563},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1645970256564},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1645970256564},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1645970256564},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1645970256564},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1645970256565},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1645970256569},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1645970256569},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1645970256570},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1645970256570},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1645970256570},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1645970256571},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1645970256572},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1645970256574},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1645970256574},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1645970256575},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1645970256574},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1645970256576},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1645970256575},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1645970256576},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1645970256578},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1645970256579},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1645970256582},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1645970256579},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1645970256584},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1645970256584},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1645970256584},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1645970256584},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1645970256584},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1645970256584},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1645970256585},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1645970256585},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1645970256585},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1645970256585},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1645970256585},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1645970256585},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1645970256586},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1645970256586},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1645970256586},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1645970256586},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1645970256586},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1645970256586},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1645970256586},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1645970256587},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1645970256598},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1645970256602},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1645970256602},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1645970256602},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1645970256602},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1645970256603},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1645970256603},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1645970256603},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1645970256604},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1645970256604},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1645970256604},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1645970256605},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1645970256605},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1645970256605},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1645970256605},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1645970256605},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1645970256606},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1645970256606},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1645970256606},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1645970256607},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1645970256607},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1645970256608},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1645970256570},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1645970256570},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1645970256571},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1645970256571},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1645970256571},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1645970256571},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1645970256571},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1645970256571},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1645970256572},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1645970256572},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1645970256572},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1645970256572},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1645970256572},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1645970256573},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1645970256573},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1645970256573},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1645970256573},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1645970256573},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1645970256574},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1645970256575},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1645970256575},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1645970256575},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1645970256575},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1645970256576},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1645970256576},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1645970256576},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1645970256576},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1645970256577},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1645970256577},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1645970256577},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1645970256577},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1645970256577},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1645970256577},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1645970256578},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1645970256578},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1645970256578},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1645970256578},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1645970256578},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1645970256579},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1645970256579},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1645970256579},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1645970256579},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1645970256580},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1645970256580},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1645970256580},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1645970256580},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1645970256580},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1645970256580},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1645970256582},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1645970256582},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1645970256582},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1645970256583},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1645970256583},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1645970256583},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1645970256583},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1645970256583},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1645970256583},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1645970256583},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1645970256584},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1645970256600},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1645970256601},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1645970256601},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1645970256601},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1645970256601},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1645970256607},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1645970256607},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1645970256610},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1645970256610},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1645970256587},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1645970256587},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1645970256587},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1645970256591},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1645970256593},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1645970256593},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1645970256595},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1645970256595},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1645970256595},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1645970256596},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1645970256596},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1645970256596},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1645970256596},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1645970256597},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1645970256598},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1645970256598},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1645970256598},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1645970256598},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1645970256598},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1645970256598},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1645970256599},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1645970256599},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1645970256599},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1645970256599},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1645970256599},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1645970256599},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1645970256599},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1645970256600},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1645970256600},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1645970256600},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1645970256600},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1645970256600},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1645970256609},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1645970256609},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1645970256588},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1645970256588},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1645970256588},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1645970256588},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1645970256588},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1645970256589},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1645970256589},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1645970256589},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1645970256589},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1645970256589},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1645970256589},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1645970256589},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1645970256590},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1645970256590},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1645970256590},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1645970256590},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1645970256590},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1645970256590},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1645970256591},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1645970256591},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1645970256591},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1645970256591},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1645970256591},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1645970256592},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1645970256592},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1645970256592},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1645970256592},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1645970256592},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1645970256592},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1645970256593},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1645970256593},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1645970256593},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1645970256593},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1645970256594},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1645970256594},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1645970256594},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1645970256594},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1645970256594},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1645970256594},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1645970256594},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1645970256594},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1645970256595},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1645970256595},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1645970256595},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1645970256596},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1645970256596},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1645970256597},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1645970256597},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1645970256597},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1645970256597},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1645970256597},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1645970256597},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1645970256609},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1645970256610},{"_id":"source/images/favicon-16x16-next.png","hash":"a4b78484fe9445715e758dfa8b4a02e70c0b7fae","modified":1645968040954},{"_id":"public/archives/index.html","hash":"44f6f98737c4f004bcefa6dac629816cae00d5a3","modified":1645971914149},{"_id":"public/archives/2015/index.html","hash":"37bdd57b3f790ec88e4493ee189c3a5f89ac0eac","modified":1645971914149},{"_id":"public/archives/2015/11/index.html","hash":"199dc70ec7f7b70d9b6cd687e4619cf1396d1a59","modified":1645971914149},{"_id":"public/archives/2016/index.html","hash":"7b5385a5d5a6ecfa9ecbcd46836fdd949d6b96cf","modified":1645971914149},{"_id":"public/archives/2016/03/index.html","hash":"b75769471eda47a41088d9fe3b3fb81a2ac4ff4e","modified":1645971914149},{"_id":"public/archives/2016/07/index.html","hash":"aa73210c7cc16b719e8cd664c9b1f2884cb21cd9","modified":1645971914149},{"_id":"public/archives/2016/08/index.html","hash":"bc0cfaf9e14ed3ba006149d4514941b1fe610ded","modified":1645971914149},{"_id":"public/archives/2018/index.html","hash":"5532f4faf989f98829872d502e46ac7373da76cf","modified":1645971914149},{"_id":"public/archives/2018/12/index.html","hash":"1e56082af8066118f600acdb96a2b76d074100a9","modified":1645971914149},{"_id":"public/archives/2019/index.html","hash":"d45fbdd13cc35738702026a8cc49e12e87006235","modified":1645971914149},{"_id":"public/archives/2019/02/index.html","hash":"7c9b781ad0e8723008a73096e35d3aa1881d6e65","modified":1645971914149},{"_id":"public/tags/Beego-Framework/index.html","hash":"a225745883bce6f5bd41aa3cf796488867b5fe5e","modified":1645971914149},{"_id":"public/tags/C/index.html","hash":"78142ed1cbc4a579faf4e66281c4e205fb54e150","modified":1645971914149},{"_id":"public/tags/Linux/index.html","hash":"86c3418b278fc95e5bf2154036c89d01fbb9cb57","modified":1645971914149},{"_id":"public/tags/Operating-System/index.html","hash":"eb97332a65a2ca038e1c12d333a604be8f20e145","modified":1645971914149},{"_id":"public/tags/内存管理/index.html","hash":"3ee83765430e9d530bbf83b69844b603b554595e","modified":1645971914149},{"_id":"public/tags/日本/index.html","hash":"a1e241ac420a2ee7696755a7af08d3200efc4248","modified":1645971914149},{"_id":"public/tags/旅行/index.html","hash":"7193aa5407b74af3af1a871b312748c6eec4797e","modified":1645971914149},{"_id":"public/tags/VLog/index.html","hash":"bd5e0e6342a3d7339ba79001ae0f1257a718611b","modified":1645971914149},{"_id":"public/2019/02/23/C++ 中的 static 关键字/index.html","hash":"3b0f77d4d35f2c4354e85471ded901975090771c","modified":1645971914149},{"_id":"public/2018/12/03/我的第一个VLog/index.html","hash":"e20041c6b34304aae8e352dff675909c63eada1d","modified":1645971914149},{"_id":"public/2016/08/02/Beego源码解析-三-HTTP请求处理流程/index.html","hash":"e9c4dceb3ef607f9261340a2ab913493f25e7be0","modified":1645971914149},{"_id":"public/2016/08/01/Beego源码解析-二-路由机制/index.html","hash":"9420fae440bb888f0c728141d8e2dee3d9f916c0","modified":1645971914149},{"_id":"public/2016/07/30/Beego源码解析-一-配置项初始化流程/index.html","hash":"cd60744d17f024a498f12eab81bd14cecff10683","modified":1645971914149},{"_id":"public/2016/03/24/Linux日志文件与Syslog函数介绍/index.html","hash":"37447f76c36fda2399645f2e3dacf6d2d4576df6","modified":1645971914149},{"_id":"public/2015/11/13/初窥OS段页式管理概貌/index.html","hash":"66211dc330835eaf1845ad4935d4b5987dd552eb","modified":1645971914149},{"_id":"public/index.html","hash":"f584324e53fa2e9d3674028cd7e59e0633526af2","modified":1645971914149},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1645971914149},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1645971914149},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1645971914149},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1645971914149},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1645971914149},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1645971914149},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1645971914149},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1645971914149},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1645971914149},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1645971914149},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1645971914149},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1645971914149},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1645971914149},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1645971914149},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1645971914149},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1645971914149},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1645971914149},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1645971914149},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1645971914149},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1645971914149},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1645971914149},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1645971914149},{"_id":"public/css/main.css","hash":"82a906fcb393f2dc6ccedd39a394b6974411110f","modified":1645971914149},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1645971914149},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1645971914149},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1645971914149},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1645971914149},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1645971914149},{"_id":"public/images/WechatAddMe.jpeg","hash":"3c8198bbdcfa47ad5f91195bee703d6f514586ae","modified":1645971914149},{"_id":"public/images/favicon-16x16-next.png","hash":"a4b78484fe9445715e758dfa8b4a02e70c0b7fae","modified":1645971914149}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Beego源码解析(一)——配置项初始化流程","date":"2016-07-29T16:06:44.000Z","_content":"\n# 简介\n>beego是一个快速开发 Go应用的 HTTP框架,他可以用来快速开发 API、Web以及后端服务等各种应用,是一个 RESTful框架。\n  想了解更多关于 Beego的介绍,可以看 [**官方文档**](http://www.beego.me/docs/intro)  \n  本文及以后的文章都采用 stable v1.6.1版本  \n  Beego项目[**Github地址**](https://github.com/astaxie/beego)\n\n# 动力\n最近在看 Beego的源码,我选择 Beego一方面是因为我对 Go语言很感兴趣,另一方面在 GoWeb方面 Beego也做的十分出色。模块化的设计、完善的文档和社区、强大的功能都是我对于 Beego下手的推动力。  \n对于一个解析项目的开始,我都想从配置来下手。所以这篇文章也是主要介绍了 Beego在启动过程中配置项的初始化过程。这也是关于 Beego的第一篇文章,日后我们慢慢补坑的。\n\n<!--more-->\n\n关于 **Beego源码的注释**可以见我的 **[Github](https://github.com/riccoqu/Beego-Comments)** 我会很努力的慢慢完善它的 :D\n\n# beego配置项的解析\n在开始之前先让我们用 bee工具创建一个 Beego的应用。  项目的结构大概是这样的\n```\nmyproject\n|—conf\n\t |—app.conf\n|—controllers\n\t |—default.go\n|—main.go\n|—modules\n|—routers\n\t |—router.go\n|—static\n\t |—css\n\t |—img\n\t |—js\n|—tests\n\t |—default_test.go\n|—views\n\t |—index.tpl\n```\n### 配置文件\n可以看到 那个`conf/app.conf`就是项目的默认配置文件了  \n在配置文件中的配置项都是采用 **键值对** 的方式,即 `key = value`\n\n我们看下 beego中对于关于配置的一些文件\nbeego目前支持 INI、XML、JSON、YAML格式的配置文件解析,默认是 INI格式的解析\n`beego/config`这个包内放的就是不同解析器的文件  \n`beego/config.go`这个文件就是用来初始化配置项的文件\n\n### 程序中的配置项\n在 beego的启动过程中,有两个变量对配置项的初始化很重要,它们都在 beego/config.go:106被声明\n```Go\nvar\t(\n\tBConfig *Config\n\tAppConfig *beegoAppConfig\n\n\t...配置文件的路径等变量\n   )\n```\nBConfig是程序在整个运行过程中都需要用的,而 AppConfig是用来解析配置项的接口,所以整个配置项的解析过程来说就是 **使用 AppConfig去完成 BConfig的初始化**  \n(关于 Config这个结构体的定义可以参考 beego/config.go:50行开始的 `Listen`、`WebConfig`、`SessionConfig`、`LogConfig`这四个结构体,注意这里的 Config保存的是程序运行是已经解析好的配置,而与下文提到的 beego/config/Config接口无关)  \n### 关于 beegoAppConfig结构体\n让我们继续进入 beegoAppConfig结构体,在 beego/config.go:340可以看到定义\n```Go\ntype beegoAppConfig struct{\n\t\tinnerConfig config.Configer\n}\n```\n明白了吧,其实它就是 config包中 Configer接口的封装.所以在 beego/config.go文件后面部分都是在调用这个接口从而实现了 beegoAppConfig的很多方法  \n关于 config.Configer接口我们可以在 config/config.go:50找到,它定义了16种在解析配置项中可能用到的方法\n不过正在看源码的同学可能会发现在 Configer接口下还有个 Config接口,那么它又是干什么的呢?\n```Go\ntype Config interface{\n\t\tParse(key string)(Configer,error)\n\t\tParseData(data []byte)(Configer,error)\n}\n```\n看下它的接口定义我们就能猜到,它是为了给我们创建一个 Configer实例的.而 Parse()和 ParseData()两个函数在不同的配置器实现里都有不同的实现,但他们的目的也就只有创建实例了。  \n\n### 保存配置器的 map\n看到这里需要打断下,因为又有一个非常重要的变量需要我们认识  \n在 beego/config/config.go:85行有这样一行\n```Go\nvar adapters = make(map[strng]Config)\n```\n为什么说这个变量很重要呢,看看参数便知。map的 key是 string类型,也就是我们对应配置器的名称(\"ini\"、\"xml\"等）\n而第二个就是我们刚才定义了 Parse()和ParseData()方法的 Config接口,在同文件的91行可以看到一个叫 Register的函数。在不同的配置器文件的init()函数中,配置器都会通过 Register函数向 adapters变量进行注册(比如打开 beego/config/json.go拖到文件末尾就可以看到)  \n也就是说在 beego/config/包中所有源文件的 init()函数执行完时, adapters就已经保存了所有配置器了\n\n这样在 beego/config.go文件中使用时只需要传入配置器的名字,就能获得对应的 Config接口方法,调用方法后就能获得实现了 Configer接口所有方法的实例了!  \n那么接下来就比较简单了,不同的配置器只需要在自己文件中实现 Configer接口的所有方法就能成功的解析文件了,这里只需要根据不同格式进行配置项的处理即可  \n\n### BConfig的初始化\n通过这样自顶向下的分析,大家应该能够对这几个接口和函数之间的关系有了大概的思路了吧,既然我们现在已经知道如何得到 beegoAppConfig这样实现了16种解析方法的实例,那么接下来也就是通过这个实例给我们需要的BConfig变量赋值了。\n首先在 beego/config.go文件的 init()函数中我们可以看到了一大片关于给 BConfig赋默认值的代码,并且在 init()函数的最后 使用 appConfigPath(保存配置文件路径的string类型变量 beego/config.go:117)检查配置文件是否存在,然后调用 parseConfig()函数开始配置的解析过程  \n在 parseConfig()函数中首先是调用了本包内的 newAppConfig()函数给 AppConfig初始化, 然后就可以看到使用了 AppConfig中实现的Congiger接口的方法给BConfig赋了很多值并且在函数末尾初始化了log  \n因为给 BConfig初始化的代码在 init()函数中,所以在 beego.App.Run()方法中并不能看到初始化配置项的代码。也就是说在 Run()函数运行前,配置就已经赋值完成了 :D\n\n___\n配置项的初始化大概就是这么个流程  \n如果有错误非常希望您能指出让我改正 :D\n","source":"_posts/Beego源码解析-一-配置项初始化流程.md","raw":"---\ntitle: Beego源码解析(一)——配置项初始化流程\ndate: 2016-07-30 00:06:44\ntags:\n  - Beego Framework\n---\n\n# 简介\n>beego是一个快速开发 Go应用的 HTTP框架,他可以用来快速开发 API、Web以及后端服务等各种应用,是一个 RESTful框架。\n  想了解更多关于 Beego的介绍,可以看 [**官方文档**](http://www.beego.me/docs/intro)  \n  本文及以后的文章都采用 stable v1.6.1版本  \n  Beego项目[**Github地址**](https://github.com/astaxie/beego)\n\n# 动力\n最近在看 Beego的源码,我选择 Beego一方面是因为我对 Go语言很感兴趣,另一方面在 GoWeb方面 Beego也做的十分出色。模块化的设计、完善的文档和社区、强大的功能都是我对于 Beego下手的推动力。  \n对于一个解析项目的开始,我都想从配置来下手。所以这篇文章也是主要介绍了 Beego在启动过程中配置项的初始化过程。这也是关于 Beego的第一篇文章,日后我们慢慢补坑的。\n\n<!--more-->\n\n关于 **Beego源码的注释**可以见我的 **[Github](https://github.com/riccoqu/Beego-Comments)** 我会很努力的慢慢完善它的 :D\n\n# beego配置项的解析\n在开始之前先让我们用 bee工具创建一个 Beego的应用。  项目的结构大概是这样的\n```\nmyproject\n|—conf\n\t |—app.conf\n|—controllers\n\t |—default.go\n|—main.go\n|—modules\n|—routers\n\t |—router.go\n|—static\n\t |—css\n\t |—img\n\t |—js\n|—tests\n\t |—default_test.go\n|—views\n\t |—index.tpl\n```\n### 配置文件\n可以看到 那个`conf/app.conf`就是项目的默认配置文件了  \n在配置文件中的配置项都是采用 **键值对** 的方式,即 `key = value`\n\n我们看下 beego中对于关于配置的一些文件\nbeego目前支持 INI、XML、JSON、YAML格式的配置文件解析,默认是 INI格式的解析\n`beego/config`这个包内放的就是不同解析器的文件  \n`beego/config.go`这个文件就是用来初始化配置项的文件\n\n### 程序中的配置项\n在 beego的启动过程中,有两个变量对配置项的初始化很重要,它们都在 beego/config.go:106被声明\n```Go\nvar\t(\n\tBConfig *Config\n\tAppConfig *beegoAppConfig\n\n\t...配置文件的路径等变量\n   )\n```\nBConfig是程序在整个运行过程中都需要用的,而 AppConfig是用来解析配置项的接口,所以整个配置项的解析过程来说就是 **使用 AppConfig去完成 BConfig的初始化**  \n(关于 Config这个结构体的定义可以参考 beego/config.go:50行开始的 `Listen`、`WebConfig`、`SessionConfig`、`LogConfig`这四个结构体,注意这里的 Config保存的是程序运行是已经解析好的配置,而与下文提到的 beego/config/Config接口无关)  \n### 关于 beegoAppConfig结构体\n让我们继续进入 beegoAppConfig结构体,在 beego/config.go:340可以看到定义\n```Go\ntype beegoAppConfig struct{\n\t\tinnerConfig config.Configer\n}\n```\n明白了吧,其实它就是 config包中 Configer接口的封装.所以在 beego/config.go文件后面部分都是在调用这个接口从而实现了 beegoAppConfig的很多方法  \n关于 config.Configer接口我们可以在 config/config.go:50找到,它定义了16种在解析配置项中可能用到的方法\n不过正在看源码的同学可能会发现在 Configer接口下还有个 Config接口,那么它又是干什么的呢?\n```Go\ntype Config interface{\n\t\tParse(key string)(Configer,error)\n\t\tParseData(data []byte)(Configer,error)\n}\n```\n看下它的接口定义我们就能猜到,它是为了给我们创建一个 Configer实例的.而 Parse()和 ParseData()两个函数在不同的配置器实现里都有不同的实现,但他们的目的也就只有创建实例了。  \n\n### 保存配置器的 map\n看到这里需要打断下,因为又有一个非常重要的变量需要我们认识  \n在 beego/config/config.go:85行有这样一行\n```Go\nvar adapters = make(map[strng]Config)\n```\n为什么说这个变量很重要呢,看看参数便知。map的 key是 string类型,也就是我们对应配置器的名称(\"ini\"、\"xml\"等）\n而第二个就是我们刚才定义了 Parse()和ParseData()方法的 Config接口,在同文件的91行可以看到一个叫 Register的函数。在不同的配置器文件的init()函数中,配置器都会通过 Register函数向 adapters变量进行注册(比如打开 beego/config/json.go拖到文件末尾就可以看到)  \n也就是说在 beego/config/包中所有源文件的 init()函数执行完时, adapters就已经保存了所有配置器了\n\n这样在 beego/config.go文件中使用时只需要传入配置器的名字,就能获得对应的 Config接口方法,调用方法后就能获得实现了 Configer接口所有方法的实例了!  \n那么接下来就比较简单了,不同的配置器只需要在自己文件中实现 Configer接口的所有方法就能成功的解析文件了,这里只需要根据不同格式进行配置项的处理即可  \n\n### BConfig的初始化\n通过这样自顶向下的分析,大家应该能够对这几个接口和函数之间的关系有了大概的思路了吧,既然我们现在已经知道如何得到 beegoAppConfig这样实现了16种解析方法的实例,那么接下来也就是通过这个实例给我们需要的BConfig变量赋值了。\n首先在 beego/config.go文件的 init()函数中我们可以看到了一大片关于给 BConfig赋默认值的代码,并且在 init()函数的最后 使用 appConfigPath(保存配置文件路径的string类型变量 beego/config.go:117)检查配置文件是否存在,然后调用 parseConfig()函数开始配置的解析过程  \n在 parseConfig()函数中首先是调用了本包内的 newAppConfig()函数给 AppConfig初始化, 然后就可以看到使用了 AppConfig中实现的Congiger接口的方法给BConfig赋了很多值并且在函数末尾初始化了log  \n因为给 BConfig初始化的代码在 init()函数中,所以在 beego.App.Run()方法中并不能看到初始化配置项的代码。也就是说在 Run()函数运行前,配置就已经赋值完成了 :D\n\n___\n配置项的初始化大概就是这么个流程  \n如果有错误非常希望您能指出让我改正 :D\n","slug":"Beego源码解析-一-配置项初始化流程","published":1,"updated":"2022-02-27T13:20:40.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl05d6hhs00005emt1n3bfg3i","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><blockquote>\n<p>beego是一个快速开发 Go应用的 HTTP框架,他可以用来快速开发 API、Web以及后端服务等各种应用,是一个 RESTful框架。<br>  想了解更多关于 Beego的介绍,可以看 <a href=\"http://www.beego.me/docs/intro\"><strong>官方文档</strong></a><br>  本文及以后的文章都采用 stable v1.6.1版本<br>  Beego项目<a href=\"https://github.com/astaxie/beego\"><strong>Github地址</strong></a></p>\n</blockquote>\n<h1 id=\"动力\"><a href=\"#动力\" class=\"headerlink\" title=\"动力\"></a>动力</h1><p>最近在看 Beego的源码,我选择 Beego一方面是因为我对 Go语言很感兴趣,另一方面在 GoWeb方面 Beego也做的十分出色。模块化的设计、完善的文档和社区、强大的功能都是我对于 Beego下手的推动力。<br>对于一个解析项目的开始,我都想从配置来下手。所以这篇文章也是主要介绍了 Beego在启动过程中配置项的初始化过程。这也是关于 Beego的第一篇文章,日后我们慢慢补坑的。</p>\n<span id=\"more\"></span>\n\n<p>关于 <strong>Beego源码的注释</strong>可以见我的 <strong><a href=\"https://github.com/riccoqu/Beego-Comments\">Github</a></strong> 我会很努力的慢慢完善它的 :D</p>\n<h1 id=\"beego配置项的解析\"><a href=\"#beego配置项的解析\" class=\"headerlink\" title=\"beego配置项的解析\"></a>beego配置项的解析</h1><p>在开始之前先让我们用 bee工具创建一个 Beego的应用。  项目的结构大概是这样的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myproject</span><br><span class=\"line\">|—conf</span><br><span class=\"line\">\t |—app.conf</span><br><span class=\"line\">|—controllers</span><br><span class=\"line\">\t |—default.go</span><br><span class=\"line\">|—main.go</span><br><span class=\"line\">|—modules</span><br><span class=\"line\">|—routers</span><br><span class=\"line\">\t |—router.go</span><br><span class=\"line\">|—static</span><br><span class=\"line\">\t |—css</span><br><span class=\"line\">\t |—img</span><br><span class=\"line\">\t |—js</span><br><span class=\"line\">|—tests</span><br><span class=\"line\">\t |—default_test.go</span><br><span class=\"line\">|—views</span><br><span class=\"line\">\t |—index.tpl</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>可以看到 那个<code>conf/app.conf</code>就是项目的默认配置文件了<br>在配置文件中的配置项都是采用 <strong>键值对</strong> 的方式,即 <code>key = value</code></p>\n<p>我们看下 beego中对于关于配置的一些文件<br>beego目前支持 INI、XML、JSON、YAML格式的配置文件解析,默认是 INI格式的解析<br><code>beego/config</code>这个包内放的就是不同解析器的文件<br><code>beego/config.go</code>这个文件就是用来初始化配置项的文件</p>\n<h3 id=\"程序中的配置项\"><a href=\"#程序中的配置项\" class=\"headerlink\" title=\"程序中的配置项\"></a>程序中的配置项</h3><p>在 beego的启动过程中,有两个变量对配置项的初始化很重要,它们都在 beego&#x2F;config.go:106被声明</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span>\t(</span><br><span class=\"line\">\tBConfig *Config</span><br><span class=\"line\">\tAppConfig *beegoAppConfig</span><br><span class=\"line\"></span><br><span class=\"line\">\t...配置文件的路径等变量</span><br><span class=\"line\">   )</span><br></pre></td></tr></table></figure>\n<p>BConfig是程序在整个运行过程中都需要用的,而 AppConfig是用来解析配置项的接口,所以整个配置项的解析过程来说就是 <strong>使用 AppConfig去完成 BConfig的初始化</strong><br>(关于 Config这个结构体的定义可以参考 beego&#x2F;config.go:50行开始的 <code>Listen</code>、<code>WebConfig</code>、<code>SessionConfig</code>、<code>LogConfig</code>这四个结构体,注意这里的 Config保存的是程序运行是已经解析好的配置,而与下文提到的 beego&#x2F;config&#x2F;Config接口无关)  </p>\n<h3 id=\"关于-beegoAppConfig结构体\"><a href=\"#关于-beegoAppConfig结构体\" class=\"headerlink\" title=\"关于 beegoAppConfig结构体\"></a>关于 beegoAppConfig结构体</h3><p>让我们继续进入 beegoAppConfig结构体,在 beego&#x2F;config.go:340可以看到定义</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> beegoAppConfig <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\t\tinnerConfig config.Configer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>明白了吧,其实它就是 config包中 Configer接口的封装.所以在 beego&#x2F;config.go文件后面部分都是在调用这个接口从而实现了 beegoAppConfig的很多方法<br>关于 config.Configer接口我们可以在 config&#x2F;config.go:50找到,它定义了16种在解析配置项中可能用到的方法<br>不过正在看源码的同学可能会发现在 Configer接口下还有个 Config接口,那么它又是干什么的呢?</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">\t\tParse(key <span class=\"type\">string</span>)(Configer,<span class=\"type\">error</span>)</span><br><span class=\"line\">\t\tParseData(data []<span class=\"type\">byte</span>)(Configer,<span class=\"type\">error</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看下它的接口定义我们就能猜到,它是为了给我们创建一个 Configer实例的.而 Parse()和 ParseData()两个函数在不同的配置器实现里都有不同的实现,但他们的目的也就只有创建实例了。  </p>\n<h3 id=\"保存配置器的-map\"><a href=\"#保存配置器的-map\" class=\"headerlink\" title=\"保存配置器的 map\"></a>保存配置器的 map</h3><p>看到这里需要打断下,因为又有一个非常重要的变量需要我们认识<br>在 beego&#x2F;config&#x2F;config.go:85行有这样一行</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> adapters = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[strng]Config)</span><br></pre></td></tr></table></figure>\n<p>为什么说这个变量很重要呢,看看参数便知。map的 key是 string类型,也就是我们对应配置器的名称(“ini”、”xml”等）<br>而第二个就是我们刚才定义了 Parse()和ParseData()方法的 Config接口,在同文件的91行可以看到一个叫 Register的函数。在不同的配置器文件的init()函数中,配置器都会通过 Register函数向 adapters变量进行注册(比如打开 beego&#x2F;config&#x2F;json.go拖到文件末尾就可以看到)<br>也就是说在 beego&#x2F;config&#x2F;包中所有源文件的 init()函数执行完时, adapters就已经保存了所有配置器了</p>\n<p>这样在 beego&#x2F;config.go文件中使用时只需要传入配置器的名字,就能获得对应的 Config接口方法,调用方法后就能获得实现了 Configer接口所有方法的实例了!<br>那么接下来就比较简单了,不同的配置器只需要在自己文件中实现 Configer接口的所有方法就能成功的解析文件了,这里只需要根据不同格式进行配置项的处理即可  </p>\n<h3 id=\"BConfig的初始化\"><a href=\"#BConfig的初始化\" class=\"headerlink\" title=\"BConfig的初始化\"></a>BConfig的初始化</h3><p>通过这样自顶向下的分析,大家应该能够对这几个接口和函数之间的关系有了大概的思路了吧,既然我们现在已经知道如何得到 beegoAppConfig这样实现了16种解析方法的实例,那么接下来也就是通过这个实例给我们需要的BConfig变量赋值了。<br>首先在 beego&#x2F;config.go文件的 init()函数中我们可以看到了一大片关于给 BConfig赋默认值的代码,并且在 init()函数的最后 使用 appConfigPath(保存配置文件路径的string类型变量 beego&#x2F;config.go:117)检查配置文件是否存在,然后调用 parseConfig()函数开始配置的解析过程<br>在 parseConfig()函数中首先是调用了本包内的 newAppConfig()函数给 AppConfig初始化, 然后就可以看到使用了 AppConfig中实现的Congiger接口的方法给BConfig赋了很多值并且在函数末尾初始化了log<br>因为给 BConfig初始化的代码在 init()函数中,所以在 beego.App.Run()方法中并不能看到初始化配置项的代码。也就是说在 Run()函数运行前,配置就已经赋值完成了 :D</p>\n<hr>\n<p>配置项的初始化大概就是这么个流程<br>如果有错误非常希望您能指出让我改正 :D</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><blockquote>\n<p>beego是一个快速开发 Go应用的 HTTP框架,他可以用来快速开发 API、Web以及后端服务等各种应用,是一个 RESTful框架。<br>  想了解更多关于 Beego的介绍,可以看 <a href=\"http://www.beego.me/docs/intro\"><strong>官方文档</strong></a><br>  本文及以后的文章都采用 stable v1.6.1版本<br>  Beego项目<a href=\"https://github.com/astaxie/beego\"><strong>Github地址</strong></a></p>\n</blockquote>\n<h1 id=\"动力\"><a href=\"#动力\" class=\"headerlink\" title=\"动力\"></a>动力</h1><p>最近在看 Beego的源码,我选择 Beego一方面是因为我对 Go语言很感兴趣,另一方面在 GoWeb方面 Beego也做的十分出色。模块化的设计、完善的文档和社区、强大的功能都是我对于 Beego下手的推动力。<br>对于一个解析项目的开始,我都想从配置来下手。所以这篇文章也是主要介绍了 Beego在启动过程中配置项的初始化过程。这也是关于 Beego的第一篇文章,日后我们慢慢补坑的。</p>","more":"<p>关于 <strong>Beego源码的注释</strong>可以见我的 <strong><a href=\"https://github.com/riccoqu/Beego-Comments\">Github</a></strong> 我会很努力的慢慢完善它的 :D</p>\n<h1 id=\"beego配置项的解析\"><a href=\"#beego配置项的解析\" class=\"headerlink\" title=\"beego配置项的解析\"></a>beego配置项的解析</h1><p>在开始之前先让我们用 bee工具创建一个 Beego的应用。  项目的结构大概是这样的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myproject</span><br><span class=\"line\">|—conf</span><br><span class=\"line\">\t |—app.conf</span><br><span class=\"line\">|—controllers</span><br><span class=\"line\">\t |—default.go</span><br><span class=\"line\">|—main.go</span><br><span class=\"line\">|—modules</span><br><span class=\"line\">|—routers</span><br><span class=\"line\">\t |—router.go</span><br><span class=\"line\">|—static</span><br><span class=\"line\">\t |—css</span><br><span class=\"line\">\t |—img</span><br><span class=\"line\">\t |—js</span><br><span class=\"line\">|—tests</span><br><span class=\"line\">\t |—default_test.go</span><br><span class=\"line\">|—views</span><br><span class=\"line\">\t |—index.tpl</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>可以看到 那个<code>conf/app.conf</code>就是项目的默认配置文件了<br>在配置文件中的配置项都是采用 <strong>键值对</strong> 的方式,即 <code>key = value</code></p>\n<p>我们看下 beego中对于关于配置的一些文件<br>beego目前支持 INI、XML、JSON、YAML格式的配置文件解析,默认是 INI格式的解析<br><code>beego/config</code>这个包内放的就是不同解析器的文件<br><code>beego/config.go</code>这个文件就是用来初始化配置项的文件</p>\n<h3 id=\"程序中的配置项\"><a href=\"#程序中的配置项\" class=\"headerlink\" title=\"程序中的配置项\"></a>程序中的配置项</h3><p>在 beego的启动过程中,有两个变量对配置项的初始化很重要,它们都在 beego&#x2F;config.go:106被声明</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span>\t(</span><br><span class=\"line\">\tBConfig *Config</span><br><span class=\"line\">\tAppConfig *beegoAppConfig</span><br><span class=\"line\"></span><br><span class=\"line\">\t...配置文件的路径等变量</span><br><span class=\"line\">   )</span><br></pre></td></tr></table></figure>\n<p>BConfig是程序在整个运行过程中都需要用的,而 AppConfig是用来解析配置项的接口,所以整个配置项的解析过程来说就是 <strong>使用 AppConfig去完成 BConfig的初始化</strong><br>(关于 Config这个结构体的定义可以参考 beego&#x2F;config.go:50行开始的 <code>Listen</code>、<code>WebConfig</code>、<code>SessionConfig</code>、<code>LogConfig</code>这四个结构体,注意这里的 Config保存的是程序运行是已经解析好的配置,而与下文提到的 beego&#x2F;config&#x2F;Config接口无关)  </p>\n<h3 id=\"关于-beegoAppConfig结构体\"><a href=\"#关于-beegoAppConfig结构体\" class=\"headerlink\" title=\"关于 beegoAppConfig结构体\"></a>关于 beegoAppConfig结构体</h3><p>让我们继续进入 beegoAppConfig结构体,在 beego&#x2F;config.go:340可以看到定义</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> beegoAppConfig <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\t\tinnerConfig config.Configer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>明白了吧,其实它就是 config包中 Configer接口的封装.所以在 beego&#x2F;config.go文件后面部分都是在调用这个接口从而实现了 beegoAppConfig的很多方法<br>关于 config.Configer接口我们可以在 config&#x2F;config.go:50找到,它定义了16种在解析配置项中可能用到的方法<br>不过正在看源码的同学可能会发现在 Configer接口下还有个 Config接口,那么它又是干什么的呢?</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">\t\tParse(key <span class=\"type\">string</span>)(Configer,<span class=\"type\">error</span>)</span><br><span class=\"line\">\t\tParseData(data []<span class=\"type\">byte</span>)(Configer,<span class=\"type\">error</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>看下它的接口定义我们就能猜到,它是为了给我们创建一个 Configer实例的.而 Parse()和 ParseData()两个函数在不同的配置器实现里都有不同的实现,但他们的目的也就只有创建实例了。  </p>\n<h3 id=\"保存配置器的-map\"><a href=\"#保存配置器的-map\" class=\"headerlink\" title=\"保存配置器的 map\"></a>保存配置器的 map</h3><p>看到这里需要打断下,因为又有一个非常重要的变量需要我们认识<br>在 beego&#x2F;config&#x2F;config.go:85行有这样一行</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> adapters = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[strng]Config)</span><br></pre></td></tr></table></figure>\n<p>为什么说这个变量很重要呢,看看参数便知。map的 key是 string类型,也就是我们对应配置器的名称(“ini”、”xml”等）<br>而第二个就是我们刚才定义了 Parse()和ParseData()方法的 Config接口,在同文件的91行可以看到一个叫 Register的函数。在不同的配置器文件的init()函数中,配置器都会通过 Register函数向 adapters变量进行注册(比如打开 beego&#x2F;config&#x2F;json.go拖到文件末尾就可以看到)<br>也就是说在 beego&#x2F;config&#x2F;包中所有源文件的 init()函数执行完时, adapters就已经保存了所有配置器了</p>\n<p>这样在 beego&#x2F;config.go文件中使用时只需要传入配置器的名字,就能获得对应的 Config接口方法,调用方法后就能获得实现了 Configer接口所有方法的实例了!<br>那么接下来就比较简单了,不同的配置器只需要在自己文件中实现 Configer接口的所有方法就能成功的解析文件了,这里只需要根据不同格式进行配置项的处理即可  </p>\n<h3 id=\"BConfig的初始化\"><a href=\"#BConfig的初始化\" class=\"headerlink\" title=\"BConfig的初始化\"></a>BConfig的初始化</h3><p>通过这样自顶向下的分析,大家应该能够对这几个接口和函数之间的关系有了大概的思路了吧,既然我们现在已经知道如何得到 beegoAppConfig这样实现了16种解析方法的实例,那么接下来也就是通过这个实例给我们需要的BConfig变量赋值了。<br>首先在 beego&#x2F;config.go文件的 init()函数中我们可以看到了一大片关于给 BConfig赋默认值的代码,并且在 init()函数的最后 使用 appConfigPath(保存配置文件路径的string类型变量 beego&#x2F;config.go:117)检查配置文件是否存在,然后调用 parseConfig()函数开始配置的解析过程<br>在 parseConfig()函数中首先是调用了本包内的 newAppConfig()函数给 AppConfig初始化, 然后就可以看到使用了 AppConfig中实现的Congiger接口的方法给BConfig赋了很多值并且在函数末尾初始化了log<br>因为给 BConfig初始化的代码在 init()函数中,所以在 beego.App.Run()方法中并不能看到初始化配置项的代码。也就是说在 Run()函数运行前,配置就已经赋值完成了 :D</p>\n<hr>\n<p>配置项的初始化大概就是这么个流程<br>如果有错误非常希望您能指出让我改正 :D</p>"},{"title":"Beego源码解析(三)-HTTP请求处理流程","date":"2016-08-02T06:34:33.000Z","_content":"\n>关于上一篇文章[Beego源码解析(二)-路由机制](https://riccoqu.github.io/2016/08/01/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/)中介绍了在 Beego中如注册路由以及如何将我们自定义的路由加入到 Beego的 App实例中  \n我们知道关于注册的路由都是会加入到路由树的节点中,那么在 HTTP的请求中,查找路由树就是非常关键的一部分了  \n\n这篇文章将梳理一遍在 Beego启动后,处理 HTTP请求的流程\n\n<!--more-->\n\n关于 Beego的源码注释可以见我的[**Github**](https://github.com/riccoqu/Beego-Comments)\n\n## beego.Run()入口\n在第一篇文章中就曾提到过,在启动 Beego应用时都是通过调用 beego.Run()方法启动.而这个方法在设置了6个回到调函数后会进入 app.Run()方法(app就是我们 Beego应用程序的一个实例,在 app.go的 init()函数中被初始化)  \n\n### app.Run()函数\napp.Run()函数就是在一切都准备好之后进入 HTTP请求循环的一个启动函数了,函数并不是很长而且逻辑比较简单,结合注释看下即可\nbeego/app.go:\n```Go\n// beego程序启动函数\nfunc (app *App) Run() {\n\t//获得地址\n\taddr := BConfig.Listen.HTTPAddr\n\tif BConfig.Listen.HTTPPort != 0 {\n\t\taddr = fmt.Sprintf(\"%s:%d\", BConfig.Listen.HTTPAddr, BConfig.Listen.HTTPPort)\n\t}\n\n\tvar (\n\t\terr        error\n\t\tl          net.Listener\n\t\tendRunning = make(chan bool, 1)\n\t)\n\t// 运行 CGI服务器\n\tif BConfig.Listen.EnableFcgi {}\n\t//这里设置标准包中的 http.Server.handler为 app.ServerHandler\n\t//也就是 ContollerRegister类型,因为 ControllerRegister实现了 ServeHTTP()函数\n\tapp.Server.Handler = app.Handlers\n\t//设置超时\n\tapp.Server.ReadTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second\n\tapp.Server.WriteTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second\n\t// 运行热编译模式\n\tif BConfig.Listen.Graceful {\n\t\thttpsAddr := BConfig.Listen.HTTPSAddr\n\t\tapp.Server.Addr = httpsAddr\n\t\t// 热编译模式下的 HTTPS\n\t\tif BConfig.Listen.EnableHTTPS {\n\t\t\tgo func() {\n\t\t\t\ttime.Sleep(20 * time.Microsecond)\n\t\t\t\tif BConfig.Listen.HTTPSPort != 0 {\n\t\t\t\t\thttpsAddr = fmt.Sprintf(\"%s:%d\", BConfig.Listen.HTTPSAddr, BConfig.Listen.HTTPSPort)\n\t\t\t\t\tapp.Server.Addr = httpsAddr\n\t\t\t\t}\n\t\t\t\tserver := grace.NewServer(httpsAddr, app.Handlers)\n\t\t\t\tserver.Server.ReadTimeout = app.Server.ReadTimeout\n\t\t\t\tserver.Server.WriteTimeout = app.Server.WriteTimeout\n\t\t\t\t//执行 HTTPS的 ListenAndServerTLS()\n\t\t\t\tif err := server.ListenAndServeTLS(BConfig.Listen.HTTPSCertFile, BConfig.Listen.HTTPSKeyFile); err != nil {\n\t\t\t\t\tBeeLogger.Critical(\"ListenAndServeTLS: \", err, fmt.Sprintf(\"%d\", os.Getpid()))\n\t\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\t\tendRunning <- true\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t// 热编译模式下的 HTTP\n\t\tif BConfig.Listen.EnableHTTP {\n\t\t\tgo func() {\n\t\t\t\tserver := grace.NewServer(addr, app.Handlers)\n\t\t\t\tserver.Server.ReadTimeout = app.Server.ReadTimeout\n\t\t\t\tserver.Server.WriteTimeout = app.Server.WriteTimeout\n\t\t\t\tif BConfig.Listen.ListenTCP4 {\n\t\t\t\t\tserver.Network = \"tcp4\"\n\t\t\t\t}\n\t\t\t\t// 执行 HTTP的 ListenAndServe()\n\t\t\t\tif err := server.ListenAndServe(); err != nil {\n\t\t\t\t\tBeeLogger.Critical(\"ListenAndServe: \", err, fmt.Sprintf(\"%d\", os.Getpid()))\n\t\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\t\tendRunning <- true\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t<-endRunning\n\t\treturn\n\t}\n\t// 运行普通模式\n\tapp.Server.Addr = addr\n\t// HTTPS\n\tif BConfig.Listen.EnableHTTPS {\n\t\tgo func() {\n\t\t\ttime.Sleep(20 * time.Microsecond)\n\t\t\tif BConfig.Listen.HTTPSPort != 0 {\n\t\t\t\tapp.Server.Addr = fmt.Sprintf(\"%s:%d\", BConfig.Listen.HTTPSAddr, BConfig.Listen.HTTPSPort)\n\t\t\t}\n\t\t\tBeeLogger.Info(\"https server Running on %s\", app.Server.Addr)\n\t\t\t// 运行 ListenAndServeTLS\n\t\t\tif err := app.Server.ListenAndServeTLS(BConfig.Listen.HTTPSCertFile, BConfig.Listen.HTTPSKeyFile); err != nil {\n\t\t\t\tBeeLogger.Critical(\"ListenAndServeTLS: \", err)\n\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\tendRunning <- true\n\t\t\t}\n\t\t}()\n\t}\n\t// HTTP\n\tif BConfig.Listen.EnableHTTP {\n\t\tgo func() {\n\t\t\tapp.Server.Addr = addr\n\t\t\tBeeLogger.Info(\"http server Running on %s\", app.Server.Addr)\n\t\t\tif BConfig.Listen.ListenTCP4 {\n\t\t\t\t//TCP4\n\t\t\t\tln, err := net.Listen(\"tcp4\", app.Server.Addr)\n\t\t\t\tif err != nil {\n\t\t\t\t\tBeeLogger.Critical(\"ListenAndServe: \", err)\n\t\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\t\tendRunning <- true\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err = app.Server.Serve(ln); err != nil {\n\t\t\t\t\tBeeLogger.Critical(\"ListenAndServe: \", err)\n\t\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\t\tendRunning <- true\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 运行 ListenAndServe()\n\t\t\t\tif err := app.Server.ListenAndServe(); err != nil {\n\t\t\t\t\tBeeLogger.Critical(\"ListenAndServe: \", err)\n\t\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\t\tendRunning <- true\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\t<-endRunning\n}\n```\n这里需要注意的因为主要讲 HTTP的请求处理,所以为了代码更短我将 CGI部分的代码删掉了  \n想看的可以去看 app.Run()的源码 :D\n\n这个函数的逻辑也比较简单,因为在运行到这个函数之前该初始化的地方已经都做好了\n所以这个函数只需要根据不同的配置启动不同的服务就行,不同的是根据不同的服务需要调用  \n* serve.Server()\t\t\t对应TCP4\n* server.ListenAndServe()\t对应HTTP\n* serve.ListenAndServeLTS()\t对应HTTPS\n\n另外我们也注意到在 热编译的模式中, app.server被 grace.NewServer()函数的返回值给**重写**了  \n因为主要研究 HTTP的处理,所以这里对 grace包不做深究  \n\n## ServeHTTP()\n了解 http包的都应该知道,在 http.Server.ListenAndServe()被调用后,每当有 HTTP请求来到时就会开启一个新的 goroutine并且调用对应 Server的 Handler接口处理(Handler接口包含了 ServeHTTP()方法).而且我们看到在 app.Run()方法中有一句\n```Go\napp.Server.Handler = app.Handlers\n```\n而这个 app.Handlers也就是我们在第二篇文章中介绍到的 ControllerRegister类型的结构体了  \n在 beego/router.go:622行我们也可以发现 ControllerRegister类型实现了 ServeHTTP()方法,那么这个方法就是我们的重中之重了!  \n这个函数的实现有258行,所以就不贴代码了,让我们可以一点一点看\n```Go\nfunc (p *ControllerRegister) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\nstartTime := time.Now()\nvar (\n\trunRouter  reflect.Type\n\tfindRouter bool//是否找到路由\n\trunMethod  string\n\trouterInfo *controllerInfo\n)\n\tcontext := p.pool.Get().(*beecontext.Context)\n\tcontext.Reset(rw, r)\n\n\tdefer p.pool.Put(context)\n\tdefer p.recoverPanic(context)\n```\n函数的开始就是先获得时间,然后从 ControllerRegister中的pool对象池获得一个　Context对象  \nContext对象是对HTTP连接的封装,我们暂时可以理解为 Context中的输入就是客户端发来的信息,输出就是服务器向客户端要发送的信息,所以获得 Context对象后调用 context.Reset()传入当前的 http连接初始化它,可以方便以后的使用  \n\n```Go\n// 路由大小写敏感\n\tif !BConfig.RouterCaseSensitive {\n\t\turlPath = strings.ToLower(r.URL.Path)\n\t} else {\n\t\turlPath = r.URL.Path\n\t}\n\t// 检查请求中的方法是否支持\n\tif _, ok := HTTPMETHOD[r.Method]; !ok {\n\t\t// 不支持则返回405状态\n\t\thttp.Error(rw, \"Method Not Allowed\", 405)\n\t\t// 记录\n\t\tgoto Admin\n\t}\n\t// 检查对应 url的的 filter\n\tif p.execFilter(context, BeforeStatic, urlPath) {\n\t\tgoto Admin\n\t}\n\t// 查找静态文件\n\tserverStaticRouter(context)//只对于 \"GET\"和\"HEAD\"请求方法有效\n\tif context.ResponseWriter.Started {\n\t\t//路由找到并且发送了相应的文件则修改 findRouter标志位并且跳转到记录\n\t\tfindRouter = true\n\t\tgoto Admin\n\t}\n```\n这里可以看到先根据大小写敏感配置设定 URL的大小写,然后检查传过来的方法是否支持  \nHTTPMETHOD是一个全局类型的 map[string]string类型,主要保存了支持的方法  \n然后调用 p.execFilter()方法,执行对应的Filter,注意这里的 p.execFilter()会在每个阶段被调用能够,这里的阶段有5个,被定义在 beego/router.go:36\n```Go\nconst (\n\tBeforeStatic = iota\n\tBeforeRouter\n\tBeforeExec\n\tAfterExec\n\tFinishRouter\n)\n```\n这里的5个阶段同时也对应着 ControllerRegister.filters中的 key,在　p.execFilters()方法中也正是用了不同阶段作为参数而在 ControllerRegister.filters成员总寻找相应的 Filter的  \n\n接下来\n就是调用 serverStaticRouter(方法查找静态文件,如果找到,并且 context.ResponseWriter.Started标志位被置位,表示已经开始发送文件,这时只需要跳转到 Admin处记录下这次连接的信息就可以结束了,否则继续执行)\n\n```Go\n\t//对于非 \"GET\"和\"HEAD\"的请求方法开始解析参数\n\tif r.Method != \"GET\" && r.Method != \"HEAD\" {\n\t\tif BConfig.CopyRequestBody && !context.Input.IsUpload() {\n\t\t\tcontext.Input.CopyBody(BConfig.MaxMemory)\n\t\t}\n\t\tcontext.Input.ParseFormOrMulitForm(BConfig.MaxMemory)\n\t}\n\t// session初始化\n\tif BConfig.WebConfig.Session.SessionOn { //...省略}\n\t//检查 Filter,与659行相似,但是会查找不同的 filters数组\n\tif p.execFilter(context, BeforeRouter, urlPath) {\n\t\tgoto Admin\n\t}\n\t//前面的静态文件未找到,开始查找路由的过程\n\tif !findRouter {\n\t\thttpMethod := r.Method\n\t\tif t, ok := p.routers[httpMethod]; ok {\n\t\t\t//这里通过 p.routers[httpMethod]进入路由树\n\t\t\trunObject := t.Match(urlPath, context)//找到路由树中对应的 runObject变量\n\t\t\tif r, ok := runObject.(*controllerInfo); ok {\n\t\t\t\t//将 runObject变量还原回 controllerInfo结构体\n\t\t\t\trouterInfo = r\n\t\t\t\tfindRouter = true\n\t\t\t\tif splat := context.Input.Param(\":splat\"); splat != \"\" {\n\t\t\t\t\t//如果为全匹配方式,再进行分割\n\t\t\t\t\tfor k, v := range strings.Split(splat, \"/\") {\n\t\t\t\t\t\tcontext.Input.SetParam(strconv.Itoa(k), v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n  // 如果程序执行到这里还没有找到路由则抛出一个异常并跳转到记录\n\tif !findRouter {\n\t\texception(\"404\", context)\n\t\tgoto Admin\n\t}\n```\n如果前面请求的不是静态文件,则开始解析请求的参数  \n然后初始化 session,也就是利用 Session管理器开始一个 Session会话,并且用 defer关键字关闭会话  \n接下来开始执行 BeforeRouter阶段的 Filter  \n可以看到,在 findRouter标志位未被置位的情况下开始路由的查找,这里的逻辑是先通过 ControllerRegister的 routers成员(也就是第二篇文章中向里面注册路由的变量)通过请求的方法名找到对应的路由树,然后通过 Tree.Match()方法找到对应URL的Tree节点中的 runnObject对象(忘掉 runObject的话可以去看[Beego源码解析(二)-路由机制](https://riccoqu.github.io/2016/08/01/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/)中那篇文章)  \n\n只要找到了 runObject,我们就获得了当初注册路由时的自定义 Controller对象的信息,当然如果查找路由还找不到就向客户端返回\"404\"错误\n\n\n当完成路由的查找后,接下来就应该是执行对应的方法了,这也是比较重要的一段代码\n```Go\n\t//找到了路由,进行动作\n\tif findRouter {\n\t\t//查找对应的 Filter\n\t\tif p.execFilter(context, BeforeExec, urlPath) {\n\t\t\tgoto Admin\n\t\t}\n\t\tisRunnable := false\n\t\t//找到了 routerInfo\n\t\tif routerInfo != nil {\n\t\t\t//RESTFul路由,执行对应的方法\n\t\t\tif routerInfo.routerType == routerTypeRESTFul {\n\t\t\t\t//查找到了对应的方法,所以调用回调函数\n\t\t\t\tif _, ok := routerInfo.methods[r.Method]; ok {\n\t\t\t\t\tisRunnable = true\n\t\t\t\t\trouterInfo.runFunction(context)//执行对应的回调方法\n\t\t\t\t} else {\n\t\t\t\t\texception(\"405\", context)\n\t\t\t\t\tgoto Admin\n\t\t\t\t}\n\t\t\t} else if routerInfo.routerType == routerTypeHandler {\n\t\t\t\t//Handler类型的路由\n\t\t\t\tisRunnable = true\n\t\t\t\trouterInfo.handler.ServeHTTP(rw, r)//执行　Handler类型的路由回调方法\n\t\t\t} else {\n\t\t\t\t//其他类型的请求\n\t\t\t\trunRouter = routerInfo.controllerType\n\t\t\t\tmethod := r.Method\n\t\t\t\tif r.Method == \"POST\" && context.Input.Query(\"_method\") == \"PUT\" {\n\t\t\t\t\tmethod = \"PUT\"\n\t\t\t\t}\n\t\t\t\tif r.Method == \"POST\" && context.Input.Query(\"_method\") == \"DELETE\" {\n\t\t\t\t\tmethod = \"DELETE\"\n\t\t\t\t}\n\t\t\t\tif m, ok := routerInfo.methods[method]; ok {\n\t\t\t\t\t//如果找到注册过的方法,则赋值\n\t\t\t\t\trunMethod = m\n\t\t\t\t} else if m, ok = routerInfo.methods[\"*\"]; ok {\n\t\t\t\t\t//如果支持通配符'*',则赋值\n\t\t\t\t\trunMethod = m\n\t\t\t\t} else {\n\t\t\t\t\trunMethod = method\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// also defined runRouter & runMethod from filter\n\t\t//没有正在运行的情况,即在732行的两个 if都没有匹配到\n\t\tif !isRunnable {\n\t\t\t//Invoke the request handler\n\t\t\tvc := reflect.New(runRouter)\n\t\t\texecController, ok := vc.Interface().(ControllerInterface)//这是为了还原出注册时的 Controller结构体变量\n\t\t\tif !ok {\n\t\t\t\tpanic(\"controller is not ControllerInterface\")\n\t\t\t}\n\n\t\t\t//call the controller init function\n\t\t\t//调用 Controller的 init()函数\n\t\t\texecController.Init(context, runRouter.Name(), runMethod, vc.Interface())\n\n\t\t\t//call prepare function\n\t\t\t//调用 Controller的 Prepare()函数\n\t\t\texecController.Prepare()\n\n\t\t\t//if XSRF is Enable then check cookie where there has any cookie in the  request's cookie _csrf\n\t\t\tif BConfig.WebConfig.EnableXSRF {\n\t\t\t\texecController.XSRFToken()\n\t\t\t\tif r.Method == \"POST\" || r.Method == \"DELETE\" || r.Method == \"PUT\" ||\n\t\t\t\t\t(r.Method == \"POST\" && (context.Input.Query(\"_method\") == \"DELETE\" || context.Input.Query(\"_method\") == \"PUT\")) {\n\t\t\t\t\texecController.CheckXSRFCookie()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texecController.URLMapping()\n\t\t\t//根据方法调用不同的处理函数\n\t\t\tif !context.ResponseWriter.Started {\n\t\t\t\t//exec main logic\n\t\t\t\tswitch runMethod {\n\t\t\t\tcase \"GET\":\n\t\t\t\t\texecController.Get()\n\t\t\t\tcase \"POST\":\n\t\t\t\t\texecController.Post()\n\t\t\t\tcase \"DELETE\":\n\t\t\t\t\texecController.Delete()\n\t\t\t\tcase \"PUT\":\n\t\t\t\t\texecController.Put()\n\t\t\t\tcase \"HEAD\":\n\t\t\t\t\texecController.Head()\n\t\t\t\tcase \"PATCH\":\n\t\t\t\t\texecController.Patch()\n\t\t\t\tcase \"OPTIONS\":\n\t\t\t\t\texecController.Options()\n\t\t\t\tdefault:\n\t\t\t\t\tif !execController.HandlerFunc(runMethod) {\n\t\t\t\t\t\tvar in []reflect.Value\n\t\t\t\t\t\tmethod := vc.MethodByName(runMethod)\n\t\t\t\t\t\tmethod.Call(in)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//render template\n\t\t\t\tif !context.ResponseWriter.Started && context.Output.Status == 0 {\n\t\t\t\t\tif BConfig.WebConfig.AutoRender {\n\t\t\t\t\t\tif err := execController.Render(); err != nil {\n\t\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// finish all runRouter. release resource\n\t\t\t//处理完,进行资源的释放\n\t\t\texecController.Finish()\n\t\t}\n\n\t\t//execute middleware filters\n\t\t//执行对应的 Filters\n\t\tif p.execFilter(context, AfterExec, urlPath) {\n\t\t\tgoto Admin\n\t\t}\n\t}\n\t//在处理完请求后,执行对应的 Filters\n\tp.execFilter(context, FinishRouter, urlPath)\n```\n可以看到中间有几个 if else用来判断注册的路由是什么类型\n* 如果类型是 routerTypeRESTFul并且支持请求的方法,则执行 ControllerInfo的runFunction()方法,否则返回\"405\"\n* 如果类型是 routerTypeHandler,则执行 Controller.handler的ServeHTTP()方法\n* 其他类型的路由,则继续往下执行,注意有两行 \"POST\"方法的判断,但是 method又改为其他的方法,这是为了用同一个接口实现不同的请求,既将真实的请求放在参数 _method里面\n\n下面的 if !isRunnable{...} 是当上面匹配到其他类型路由时而执行的流程  \n可以发现通过反射获得了当初注册路由时的 Controller结构体,并依次调用 ControllerInterface接口所定义的方法(这些方法正在在自定义 Controller时需要实现的方法)  \n整个 ServeHTTP()函数的最后调用了 AfterExec阶段和 FinishRouter阶段两个阶段的 Filter  \n\n在后面就是整个请求结束后的记录过程了,逻辑比较简单只贴上代码就好了~\n```Go\n/*\n * 记录此次请求的一些信息\n */\nAdmin:\n\ttimeDur := time.Since(startTime)\n\t//admin module record QPS\n\tif BConfig.Listen.EnableAdmin {\n\t\tif FilterMonitorFunc(r.Method, r.URL.Path, timeDur) {\n\t\t\tif runRouter != nil {\n\t\t\t\tgo toolbox.StatisticsMap.AddStatistics(r.Method, r.URL.Path, runRouter.Name(), timeDur)\n\t\t\t} else {\n\t\t\t\tgo toolbox.StatisticsMap.AddStatistics(r.Method, r.URL.Path, \"\", timeDur)\n\t\t\t}\n\t\t}\n\t}\n\n\tif BConfig.RunMode == DEV || BConfig.Log.AccessLogs {\n\t\tvar devInfo string\n\t\tif findRouter {\n\t\t\tif routerInfo != nil {\n\t\t\t\tdevInfo = fmt.Sprintf(\"| % -10s | % -40s | % -16s | % -10s | % -40s |\", r.Method, r.URL.Path, timeDur.String(), \"match\", routerInfo.pattern)\n\t\t\t} else {\n\t\t\t\tdevInfo = fmt.Sprintf(\"| % -10s | % -40s | % -16s | % -10s |\", r.Method, r.URL.Path, timeDur.String(), \"match\")\n\t\t\t}\n\t\t} else {\n\t\t\tdevInfo = fmt.Sprintf(\"| % -10s | % -40s | % -16s | % -10s |\", r.Method, r.URL.Path, timeDur.String(), \"notmatch\")\n\t\t}\n\t\tif DefaultAccessLogFilter == nil || !DefaultAccessLogFilter.Filter(context) {\n\t\t\tDebug(devInfo)\n\t\t}\n\t}\n\n\t// Call WriteHeader if status code has been set changed\n\tif context.Output.Status != 0 {\n\t\tcontext.ResponseWriter.WriteHeader(context.Output.Status)\n\t}\n}\n```\n\n一个HTTP请求的处理流程大概就是这个样子,先查找静态路由让后再查找用户定义的路由规则,调用相应规则的处理函数\n\n\n如有错误,非常希望您能联系我并让我加以改进 :D\n","source":"_posts/Beego源码解析-三-HTTP请求处理流程.md","raw":"---\ntitle: Beego源码解析(三)-HTTP请求处理流程\ndate: 2016-08-02 14:34:33\ntags:\n  - Beego Framework\n---\n\n>关于上一篇文章[Beego源码解析(二)-路由机制](https://riccoqu.github.io/2016/08/01/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/)中介绍了在 Beego中如注册路由以及如何将我们自定义的路由加入到 Beego的 App实例中  \n我们知道关于注册的路由都是会加入到路由树的节点中,那么在 HTTP的请求中,查找路由树就是非常关键的一部分了  \n\n这篇文章将梳理一遍在 Beego启动后,处理 HTTP请求的流程\n\n<!--more-->\n\n关于 Beego的源码注释可以见我的[**Github**](https://github.com/riccoqu/Beego-Comments)\n\n## beego.Run()入口\n在第一篇文章中就曾提到过,在启动 Beego应用时都是通过调用 beego.Run()方法启动.而这个方法在设置了6个回到调函数后会进入 app.Run()方法(app就是我们 Beego应用程序的一个实例,在 app.go的 init()函数中被初始化)  \n\n### app.Run()函数\napp.Run()函数就是在一切都准备好之后进入 HTTP请求循环的一个启动函数了,函数并不是很长而且逻辑比较简单,结合注释看下即可\nbeego/app.go:\n```Go\n// beego程序启动函数\nfunc (app *App) Run() {\n\t//获得地址\n\taddr := BConfig.Listen.HTTPAddr\n\tif BConfig.Listen.HTTPPort != 0 {\n\t\taddr = fmt.Sprintf(\"%s:%d\", BConfig.Listen.HTTPAddr, BConfig.Listen.HTTPPort)\n\t}\n\n\tvar (\n\t\terr        error\n\t\tl          net.Listener\n\t\tendRunning = make(chan bool, 1)\n\t)\n\t// 运行 CGI服务器\n\tif BConfig.Listen.EnableFcgi {}\n\t//这里设置标准包中的 http.Server.handler为 app.ServerHandler\n\t//也就是 ContollerRegister类型,因为 ControllerRegister实现了 ServeHTTP()函数\n\tapp.Server.Handler = app.Handlers\n\t//设置超时\n\tapp.Server.ReadTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second\n\tapp.Server.WriteTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second\n\t// 运行热编译模式\n\tif BConfig.Listen.Graceful {\n\t\thttpsAddr := BConfig.Listen.HTTPSAddr\n\t\tapp.Server.Addr = httpsAddr\n\t\t// 热编译模式下的 HTTPS\n\t\tif BConfig.Listen.EnableHTTPS {\n\t\t\tgo func() {\n\t\t\t\ttime.Sleep(20 * time.Microsecond)\n\t\t\t\tif BConfig.Listen.HTTPSPort != 0 {\n\t\t\t\t\thttpsAddr = fmt.Sprintf(\"%s:%d\", BConfig.Listen.HTTPSAddr, BConfig.Listen.HTTPSPort)\n\t\t\t\t\tapp.Server.Addr = httpsAddr\n\t\t\t\t}\n\t\t\t\tserver := grace.NewServer(httpsAddr, app.Handlers)\n\t\t\t\tserver.Server.ReadTimeout = app.Server.ReadTimeout\n\t\t\t\tserver.Server.WriteTimeout = app.Server.WriteTimeout\n\t\t\t\t//执行 HTTPS的 ListenAndServerTLS()\n\t\t\t\tif err := server.ListenAndServeTLS(BConfig.Listen.HTTPSCertFile, BConfig.Listen.HTTPSKeyFile); err != nil {\n\t\t\t\t\tBeeLogger.Critical(\"ListenAndServeTLS: \", err, fmt.Sprintf(\"%d\", os.Getpid()))\n\t\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\t\tendRunning <- true\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t// 热编译模式下的 HTTP\n\t\tif BConfig.Listen.EnableHTTP {\n\t\t\tgo func() {\n\t\t\t\tserver := grace.NewServer(addr, app.Handlers)\n\t\t\t\tserver.Server.ReadTimeout = app.Server.ReadTimeout\n\t\t\t\tserver.Server.WriteTimeout = app.Server.WriteTimeout\n\t\t\t\tif BConfig.Listen.ListenTCP4 {\n\t\t\t\t\tserver.Network = \"tcp4\"\n\t\t\t\t}\n\t\t\t\t// 执行 HTTP的 ListenAndServe()\n\t\t\t\tif err := server.ListenAndServe(); err != nil {\n\t\t\t\t\tBeeLogger.Critical(\"ListenAndServe: \", err, fmt.Sprintf(\"%d\", os.Getpid()))\n\t\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\t\tendRunning <- true\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\t<-endRunning\n\t\treturn\n\t}\n\t// 运行普通模式\n\tapp.Server.Addr = addr\n\t// HTTPS\n\tif BConfig.Listen.EnableHTTPS {\n\t\tgo func() {\n\t\t\ttime.Sleep(20 * time.Microsecond)\n\t\t\tif BConfig.Listen.HTTPSPort != 0 {\n\t\t\t\tapp.Server.Addr = fmt.Sprintf(\"%s:%d\", BConfig.Listen.HTTPSAddr, BConfig.Listen.HTTPSPort)\n\t\t\t}\n\t\t\tBeeLogger.Info(\"https server Running on %s\", app.Server.Addr)\n\t\t\t// 运行 ListenAndServeTLS\n\t\t\tif err := app.Server.ListenAndServeTLS(BConfig.Listen.HTTPSCertFile, BConfig.Listen.HTTPSKeyFile); err != nil {\n\t\t\t\tBeeLogger.Critical(\"ListenAndServeTLS: \", err)\n\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\tendRunning <- true\n\t\t\t}\n\t\t}()\n\t}\n\t// HTTP\n\tif BConfig.Listen.EnableHTTP {\n\t\tgo func() {\n\t\t\tapp.Server.Addr = addr\n\t\t\tBeeLogger.Info(\"http server Running on %s\", app.Server.Addr)\n\t\t\tif BConfig.Listen.ListenTCP4 {\n\t\t\t\t//TCP4\n\t\t\t\tln, err := net.Listen(\"tcp4\", app.Server.Addr)\n\t\t\t\tif err != nil {\n\t\t\t\t\tBeeLogger.Critical(\"ListenAndServe: \", err)\n\t\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\t\tendRunning <- true\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err = app.Server.Serve(ln); err != nil {\n\t\t\t\t\tBeeLogger.Critical(\"ListenAndServe: \", err)\n\t\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\t\tendRunning <- true\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 运行 ListenAndServe()\n\t\t\t\tif err := app.Server.ListenAndServe(); err != nil {\n\t\t\t\t\tBeeLogger.Critical(\"ListenAndServe: \", err)\n\t\t\t\t\ttime.Sleep(100 * time.Microsecond)\n\t\t\t\t\tendRunning <- true\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\t<-endRunning\n}\n```\n这里需要注意的因为主要讲 HTTP的请求处理,所以为了代码更短我将 CGI部分的代码删掉了  \n想看的可以去看 app.Run()的源码 :D\n\n这个函数的逻辑也比较简单,因为在运行到这个函数之前该初始化的地方已经都做好了\n所以这个函数只需要根据不同的配置启动不同的服务就行,不同的是根据不同的服务需要调用  \n* serve.Server()\t\t\t对应TCP4\n* server.ListenAndServe()\t对应HTTP\n* serve.ListenAndServeLTS()\t对应HTTPS\n\n另外我们也注意到在 热编译的模式中, app.server被 grace.NewServer()函数的返回值给**重写**了  \n因为主要研究 HTTP的处理,所以这里对 grace包不做深究  \n\n## ServeHTTP()\n了解 http包的都应该知道,在 http.Server.ListenAndServe()被调用后,每当有 HTTP请求来到时就会开启一个新的 goroutine并且调用对应 Server的 Handler接口处理(Handler接口包含了 ServeHTTP()方法).而且我们看到在 app.Run()方法中有一句\n```Go\napp.Server.Handler = app.Handlers\n```\n而这个 app.Handlers也就是我们在第二篇文章中介绍到的 ControllerRegister类型的结构体了  \n在 beego/router.go:622行我们也可以发现 ControllerRegister类型实现了 ServeHTTP()方法,那么这个方法就是我们的重中之重了!  \n这个函数的实现有258行,所以就不贴代码了,让我们可以一点一点看\n```Go\nfunc (p *ControllerRegister) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\nstartTime := time.Now()\nvar (\n\trunRouter  reflect.Type\n\tfindRouter bool//是否找到路由\n\trunMethod  string\n\trouterInfo *controllerInfo\n)\n\tcontext := p.pool.Get().(*beecontext.Context)\n\tcontext.Reset(rw, r)\n\n\tdefer p.pool.Put(context)\n\tdefer p.recoverPanic(context)\n```\n函数的开始就是先获得时间,然后从 ControllerRegister中的pool对象池获得一个　Context对象  \nContext对象是对HTTP连接的封装,我们暂时可以理解为 Context中的输入就是客户端发来的信息,输出就是服务器向客户端要发送的信息,所以获得 Context对象后调用 context.Reset()传入当前的 http连接初始化它,可以方便以后的使用  \n\n```Go\n// 路由大小写敏感\n\tif !BConfig.RouterCaseSensitive {\n\t\turlPath = strings.ToLower(r.URL.Path)\n\t} else {\n\t\turlPath = r.URL.Path\n\t}\n\t// 检查请求中的方法是否支持\n\tif _, ok := HTTPMETHOD[r.Method]; !ok {\n\t\t// 不支持则返回405状态\n\t\thttp.Error(rw, \"Method Not Allowed\", 405)\n\t\t// 记录\n\t\tgoto Admin\n\t}\n\t// 检查对应 url的的 filter\n\tif p.execFilter(context, BeforeStatic, urlPath) {\n\t\tgoto Admin\n\t}\n\t// 查找静态文件\n\tserverStaticRouter(context)//只对于 \"GET\"和\"HEAD\"请求方法有效\n\tif context.ResponseWriter.Started {\n\t\t//路由找到并且发送了相应的文件则修改 findRouter标志位并且跳转到记录\n\t\tfindRouter = true\n\t\tgoto Admin\n\t}\n```\n这里可以看到先根据大小写敏感配置设定 URL的大小写,然后检查传过来的方法是否支持  \nHTTPMETHOD是一个全局类型的 map[string]string类型,主要保存了支持的方法  \n然后调用 p.execFilter()方法,执行对应的Filter,注意这里的 p.execFilter()会在每个阶段被调用能够,这里的阶段有5个,被定义在 beego/router.go:36\n```Go\nconst (\n\tBeforeStatic = iota\n\tBeforeRouter\n\tBeforeExec\n\tAfterExec\n\tFinishRouter\n)\n```\n这里的5个阶段同时也对应着 ControllerRegister.filters中的 key,在　p.execFilters()方法中也正是用了不同阶段作为参数而在 ControllerRegister.filters成员总寻找相应的 Filter的  \n\n接下来\n就是调用 serverStaticRouter(方法查找静态文件,如果找到,并且 context.ResponseWriter.Started标志位被置位,表示已经开始发送文件,这时只需要跳转到 Admin处记录下这次连接的信息就可以结束了,否则继续执行)\n\n```Go\n\t//对于非 \"GET\"和\"HEAD\"的请求方法开始解析参数\n\tif r.Method != \"GET\" && r.Method != \"HEAD\" {\n\t\tif BConfig.CopyRequestBody && !context.Input.IsUpload() {\n\t\t\tcontext.Input.CopyBody(BConfig.MaxMemory)\n\t\t}\n\t\tcontext.Input.ParseFormOrMulitForm(BConfig.MaxMemory)\n\t}\n\t// session初始化\n\tif BConfig.WebConfig.Session.SessionOn { //...省略}\n\t//检查 Filter,与659行相似,但是会查找不同的 filters数组\n\tif p.execFilter(context, BeforeRouter, urlPath) {\n\t\tgoto Admin\n\t}\n\t//前面的静态文件未找到,开始查找路由的过程\n\tif !findRouter {\n\t\thttpMethod := r.Method\n\t\tif t, ok := p.routers[httpMethod]; ok {\n\t\t\t//这里通过 p.routers[httpMethod]进入路由树\n\t\t\trunObject := t.Match(urlPath, context)//找到路由树中对应的 runObject变量\n\t\t\tif r, ok := runObject.(*controllerInfo); ok {\n\t\t\t\t//将 runObject变量还原回 controllerInfo结构体\n\t\t\t\trouterInfo = r\n\t\t\t\tfindRouter = true\n\t\t\t\tif splat := context.Input.Param(\":splat\"); splat != \"\" {\n\t\t\t\t\t//如果为全匹配方式,再进行分割\n\t\t\t\t\tfor k, v := range strings.Split(splat, \"/\") {\n\t\t\t\t\t\tcontext.Input.SetParam(strconv.Itoa(k), v)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n  // 如果程序执行到这里还没有找到路由则抛出一个异常并跳转到记录\n\tif !findRouter {\n\t\texception(\"404\", context)\n\t\tgoto Admin\n\t}\n```\n如果前面请求的不是静态文件,则开始解析请求的参数  \n然后初始化 session,也就是利用 Session管理器开始一个 Session会话,并且用 defer关键字关闭会话  \n接下来开始执行 BeforeRouter阶段的 Filter  \n可以看到,在 findRouter标志位未被置位的情况下开始路由的查找,这里的逻辑是先通过 ControllerRegister的 routers成员(也就是第二篇文章中向里面注册路由的变量)通过请求的方法名找到对应的路由树,然后通过 Tree.Match()方法找到对应URL的Tree节点中的 runnObject对象(忘掉 runObject的话可以去看[Beego源码解析(二)-路由机制](https://riccoqu.github.io/2016/08/01/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/)中那篇文章)  \n\n只要找到了 runObject,我们就获得了当初注册路由时的自定义 Controller对象的信息,当然如果查找路由还找不到就向客户端返回\"404\"错误\n\n\n当完成路由的查找后,接下来就应该是执行对应的方法了,这也是比较重要的一段代码\n```Go\n\t//找到了路由,进行动作\n\tif findRouter {\n\t\t//查找对应的 Filter\n\t\tif p.execFilter(context, BeforeExec, urlPath) {\n\t\t\tgoto Admin\n\t\t}\n\t\tisRunnable := false\n\t\t//找到了 routerInfo\n\t\tif routerInfo != nil {\n\t\t\t//RESTFul路由,执行对应的方法\n\t\t\tif routerInfo.routerType == routerTypeRESTFul {\n\t\t\t\t//查找到了对应的方法,所以调用回调函数\n\t\t\t\tif _, ok := routerInfo.methods[r.Method]; ok {\n\t\t\t\t\tisRunnable = true\n\t\t\t\t\trouterInfo.runFunction(context)//执行对应的回调方法\n\t\t\t\t} else {\n\t\t\t\t\texception(\"405\", context)\n\t\t\t\t\tgoto Admin\n\t\t\t\t}\n\t\t\t} else if routerInfo.routerType == routerTypeHandler {\n\t\t\t\t//Handler类型的路由\n\t\t\t\tisRunnable = true\n\t\t\t\trouterInfo.handler.ServeHTTP(rw, r)//执行　Handler类型的路由回调方法\n\t\t\t} else {\n\t\t\t\t//其他类型的请求\n\t\t\t\trunRouter = routerInfo.controllerType\n\t\t\t\tmethod := r.Method\n\t\t\t\tif r.Method == \"POST\" && context.Input.Query(\"_method\") == \"PUT\" {\n\t\t\t\t\tmethod = \"PUT\"\n\t\t\t\t}\n\t\t\t\tif r.Method == \"POST\" && context.Input.Query(\"_method\") == \"DELETE\" {\n\t\t\t\t\tmethod = \"DELETE\"\n\t\t\t\t}\n\t\t\t\tif m, ok := routerInfo.methods[method]; ok {\n\t\t\t\t\t//如果找到注册过的方法,则赋值\n\t\t\t\t\trunMethod = m\n\t\t\t\t} else if m, ok = routerInfo.methods[\"*\"]; ok {\n\t\t\t\t\t//如果支持通配符'*',则赋值\n\t\t\t\t\trunMethod = m\n\t\t\t\t} else {\n\t\t\t\t\trunMethod = method\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// also defined runRouter & runMethod from filter\n\t\t//没有正在运行的情况,即在732行的两个 if都没有匹配到\n\t\tif !isRunnable {\n\t\t\t//Invoke the request handler\n\t\t\tvc := reflect.New(runRouter)\n\t\t\texecController, ok := vc.Interface().(ControllerInterface)//这是为了还原出注册时的 Controller结构体变量\n\t\t\tif !ok {\n\t\t\t\tpanic(\"controller is not ControllerInterface\")\n\t\t\t}\n\n\t\t\t//call the controller init function\n\t\t\t//调用 Controller的 init()函数\n\t\t\texecController.Init(context, runRouter.Name(), runMethod, vc.Interface())\n\n\t\t\t//call prepare function\n\t\t\t//调用 Controller的 Prepare()函数\n\t\t\texecController.Prepare()\n\n\t\t\t//if XSRF is Enable then check cookie where there has any cookie in the  request's cookie _csrf\n\t\t\tif BConfig.WebConfig.EnableXSRF {\n\t\t\t\texecController.XSRFToken()\n\t\t\t\tif r.Method == \"POST\" || r.Method == \"DELETE\" || r.Method == \"PUT\" ||\n\t\t\t\t\t(r.Method == \"POST\" && (context.Input.Query(\"_method\") == \"DELETE\" || context.Input.Query(\"_method\") == \"PUT\")) {\n\t\t\t\t\texecController.CheckXSRFCookie()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texecController.URLMapping()\n\t\t\t//根据方法调用不同的处理函数\n\t\t\tif !context.ResponseWriter.Started {\n\t\t\t\t//exec main logic\n\t\t\t\tswitch runMethod {\n\t\t\t\tcase \"GET\":\n\t\t\t\t\texecController.Get()\n\t\t\t\tcase \"POST\":\n\t\t\t\t\texecController.Post()\n\t\t\t\tcase \"DELETE\":\n\t\t\t\t\texecController.Delete()\n\t\t\t\tcase \"PUT\":\n\t\t\t\t\texecController.Put()\n\t\t\t\tcase \"HEAD\":\n\t\t\t\t\texecController.Head()\n\t\t\t\tcase \"PATCH\":\n\t\t\t\t\texecController.Patch()\n\t\t\t\tcase \"OPTIONS\":\n\t\t\t\t\texecController.Options()\n\t\t\t\tdefault:\n\t\t\t\t\tif !execController.HandlerFunc(runMethod) {\n\t\t\t\t\t\tvar in []reflect.Value\n\t\t\t\t\t\tmethod := vc.MethodByName(runMethod)\n\t\t\t\t\t\tmethod.Call(in)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//render template\n\t\t\t\tif !context.ResponseWriter.Started && context.Output.Status == 0 {\n\t\t\t\t\tif BConfig.WebConfig.AutoRender {\n\t\t\t\t\t\tif err := execController.Render(); err != nil {\n\t\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// finish all runRouter. release resource\n\t\t\t//处理完,进行资源的释放\n\t\t\texecController.Finish()\n\t\t}\n\n\t\t//execute middleware filters\n\t\t//执行对应的 Filters\n\t\tif p.execFilter(context, AfterExec, urlPath) {\n\t\t\tgoto Admin\n\t\t}\n\t}\n\t//在处理完请求后,执行对应的 Filters\n\tp.execFilter(context, FinishRouter, urlPath)\n```\n可以看到中间有几个 if else用来判断注册的路由是什么类型\n* 如果类型是 routerTypeRESTFul并且支持请求的方法,则执行 ControllerInfo的runFunction()方法,否则返回\"405\"\n* 如果类型是 routerTypeHandler,则执行 Controller.handler的ServeHTTP()方法\n* 其他类型的路由,则继续往下执行,注意有两行 \"POST\"方法的判断,但是 method又改为其他的方法,这是为了用同一个接口实现不同的请求,既将真实的请求放在参数 _method里面\n\n下面的 if !isRunnable{...} 是当上面匹配到其他类型路由时而执行的流程  \n可以发现通过反射获得了当初注册路由时的 Controller结构体,并依次调用 ControllerInterface接口所定义的方法(这些方法正在在自定义 Controller时需要实现的方法)  \n整个 ServeHTTP()函数的最后调用了 AfterExec阶段和 FinishRouter阶段两个阶段的 Filter  \n\n在后面就是整个请求结束后的记录过程了,逻辑比较简单只贴上代码就好了~\n```Go\n/*\n * 记录此次请求的一些信息\n */\nAdmin:\n\ttimeDur := time.Since(startTime)\n\t//admin module record QPS\n\tif BConfig.Listen.EnableAdmin {\n\t\tif FilterMonitorFunc(r.Method, r.URL.Path, timeDur) {\n\t\t\tif runRouter != nil {\n\t\t\t\tgo toolbox.StatisticsMap.AddStatistics(r.Method, r.URL.Path, runRouter.Name(), timeDur)\n\t\t\t} else {\n\t\t\t\tgo toolbox.StatisticsMap.AddStatistics(r.Method, r.URL.Path, \"\", timeDur)\n\t\t\t}\n\t\t}\n\t}\n\n\tif BConfig.RunMode == DEV || BConfig.Log.AccessLogs {\n\t\tvar devInfo string\n\t\tif findRouter {\n\t\t\tif routerInfo != nil {\n\t\t\t\tdevInfo = fmt.Sprintf(\"| % -10s | % -40s | % -16s | % -10s | % -40s |\", r.Method, r.URL.Path, timeDur.String(), \"match\", routerInfo.pattern)\n\t\t\t} else {\n\t\t\t\tdevInfo = fmt.Sprintf(\"| % -10s | % -40s | % -16s | % -10s |\", r.Method, r.URL.Path, timeDur.String(), \"match\")\n\t\t\t}\n\t\t} else {\n\t\t\tdevInfo = fmt.Sprintf(\"| % -10s | % -40s | % -16s | % -10s |\", r.Method, r.URL.Path, timeDur.String(), \"notmatch\")\n\t\t}\n\t\tif DefaultAccessLogFilter == nil || !DefaultAccessLogFilter.Filter(context) {\n\t\t\tDebug(devInfo)\n\t\t}\n\t}\n\n\t// Call WriteHeader if status code has been set changed\n\tif context.Output.Status != 0 {\n\t\tcontext.ResponseWriter.WriteHeader(context.Output.Status)\n\t}\n}\n```\n\n一个HTTP请求的处理流程大概就是这个样子,先查找静态路由让后再查找用户定义的路由规则,调用相应规则的处理函数\n\n\n如有错误,非常希望您能联系我并让我加以改进 :D\n","slug":"Beego源码解析-三-HTTP请求处理流程","published":1,"updated":"2022-02-27T13:20:40.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl05d6hhy00015emt2d33eaj6","content":"<blockquote>\n<p>关于上一篇文章<a href=\"https://riccoqu.github.io/2016/08/01/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/\">Beego源码解析(二)-路由机制</a>中介绍了在 Beego中如注册路由以及如何将我们自定义的路由加入到 Beego的 App实例中<br>我们知道关于注册的路由都是会加入到路由树的节点中,那么在 HTTP的请求中,查找路由树就是非常关键的一部分了  </p>\n</blockquote>\n<p>这篇文章将梳理一遍在 Beego启动后,处理 HTTP请求的流程</p>\n<span id=\"more\"></span>\n\n<p>关于 Beego的源码注释可以见我的<a href=\"https://github.com/riccoqu/Beego-Comments\"><strong>Github</strong></a></p>\n<h2 id=\"beego-Run-入口\"><a href=\"#beego-Run-入口\" class=\"headerlink\" title=\"beego.Run()入口\"></a>beego.Run()入口</h2><p>在第一篇文章中就曾提到过,在启动 Beego应用时都是通过调用 beego.Run()方法启动.而这个方法在设置了6个回到调函数后会进入 app.Run()方法(app就是我们 Beego应用程序的一个实例,在 app.go的 init()函数中被初始化)  </p>\n<h3 id=\"app-Run-函数\"><a href=\"#app-Run-函数\" class=\"headerlink\" title=\"app.Run()函数\"></a>app.Run()函数</h3><p>app.Run()函数就是在一切都准备好之后进入 HTTP请求循环的一个启动函数了,函数并不是很长而且逻辑比较简单,结合注释看下即可<br>beego&#x2F;app.go:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// beego程序启动函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(app *App)</span></span> Run() &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获得地址</span></span><br><span class=\"line\">\taddr := BConfig.Listen.HTTPAddr</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.HTTPPort != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\taddr = fmt.Sprintf(<span class=\"string\">&quot;%s:%d&quot;</span>, BConfig.Listen.HTTPAddr, BConfig.Listen.HTTPPort)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> (</span><br><span class=\"line\">\t\terr        <span class=\"type\">error</span></span><br><span class=\"line\">\t\tl          net.Listener</span><br><span class=\"line\">\t\tendRunning = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">bool</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"comment\">// 运行 CGI服务器</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.EnableFcgi &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//这里设置标准包中的 http.Server.handler为 app.ServerHandler</span></span><br><span class=\"line\">\t<span class=\"comment\">//也就是 ContollerRegister类型,因为 ControllerRegister实现了 ServeHTTP()函数</span></span><br><span class=\"line\">\tapp.Server.Handler = app.Handlers</span><br><span class=\"line\">\t<span class=\"comment\">//设置超时</span></span><br><span class=\"line\">\tapp.Server.ReadTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second</span><br><span class=\"line\">\tapp.Server.WriteTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second</span><br><span class=\"line\">\t<span class=\"comment\">// 运行热编译模式</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.Graceful &#123;</span><br><span class=\"line\">\t\thttpsAddr := BConfig.Listen.HTTPSAddr</span><br><span class=\"line\">\t\tapp.Server.Addr = httpsAddr</span><br><span class=\"line\">\t\t<span class=\"comment\">// 热编译模式下的 HTTPS</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> BConfig.Listen.EnableHTTPS &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\ttime.Sleep(<span class=\"number\">20</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> BConfig.Listen.HTTPSPort != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\thttpsAddr = fmt.Sprintf(<span class=\"string\">&quot;%s:%d&quot;</span>, BConfig.Listen.HTTPSAddr, BConfig.Listen.HTTPSPort)</span><br><span class=\"line\">\t\t\t\t\tapp.Server.Addr = httpsAddr</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tserver := grace.NewServer(httpsAddr, app.Handlers)</span><br><span class=\"line\">\t\t\t\tserver.Server.ReadTimeout = app.Server.ReadTimeout</span><br><span class=\"line\">\t\t\t\tserver.Server.WriteTimeout = app.Server.WriteTimeout</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//执行 HTTPS的 ListenAndServerTLS()</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err := server.ListenAndServeTLS(BConfig.Listen.HTTPSCertFile, BConfig.Listen.HTTPSKeyFile); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServeTLS: &quot;</span>, err, fmt.Sprintf(<span class=\"string\">&quot;%d&quot;</span>, os.Getpid()))</span><br><span class=\"line\">\t\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 热编译模式下的 HTTP</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> BConfig.Listen.EnableHTTP &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\tserver := grace.NewServer(addr, app.Handlers)</span><br><span class=\"line\">\t\t\t\tserver.Server.ReadTimeout = app.Server.ReadTimeout</span><br><span class=\"line\">\t\t\t\tserver.Server.WriteTimeout = app.Server.WriteTimeout</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> BConfig.Listen.ListenTCP4 &#123;</span><br><span class=\"line\">\t\t\t\t\tserver.Network = <span class=\"string\">&quot;tcp4&quot;</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 执行 HTTP的 ListenAndServe()</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err := server.ListenAndServe(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err, fmt.Sprintf(<span class=\"string\">&quot;%d&quot;</span>, os.Getpid()))</span><br><span class=\"line\">\t\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t&lt;-endRunning</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 运行普通模式</span></span><br><span class=\"line\">\tapp.Server.Addr = addr</span><br><span class=\"line\">\t<span class=\"comment\">// HTTPS</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.EnableHTTPS &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(<span class=\"number\">20</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> BConfig.Listen.HTTPSPort != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tapp.Server.Addr = fmt.Sprintf(<span class=\"string\">&quot;%s:%d&quot;</span>, BConfig.Listen.HTTPSAddr, BConfig.Listen.HTTPSPort)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tBeeLogger.Info(<span class=\"string\">&quot;https server Running on %s&quot;</span>, app.Server.Addr)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 运行 ListenAndServeTLS</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := app.Server.ListenAndServeTLS(BConfig.Listen.HTTPSCertFile, BConfig.Listen.HTTPSKeyFile); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServeTLS: &quot;</span>, err)</span><br><span class=\"line\">\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// HTTP</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.EnableHTTP &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\tapp.Server.Addr = addr</span><br><span class=\"line\">\t\t\tBeeLogger.Info(<span class=\"string\">&quot;http server Running on %s&quot;</span>, app.Server.Addr)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> BConfig.Listen.ListenTCP4 &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//TCP4</span></span><br><span class=\"line\">\t\t\t\tln, err := net.Listen(<span class=\"string\">&quot;tcp4&quot;</span>, app.Server.Addr)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err = app.Server.Serve(ln); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 运行 ListenAndServe()</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err := app.Server.ListenAndServe(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&lt;-endRunning</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的因为主要讲 HTTP的请求处理,所以为了代码更短我将 CGI部分的代码删掉了<br>想看的可以去看 app.Run()的源码 :D</p>\n<p>这个函数的逻辑也比较简单,因为在运行到这个函数之前该初始化的地方已经都做好了<br>所以这个函数只需要根据不同的配置启动不同的服务就行,不同的是根据不同的服务需要调用  </p>\n<ul>\n<li>serve.Server()            对应TCP4</li>\n<li>server.ListenAndServe()    对应HTTP</li>\n<li>serve.ListenAndServeLTS()    对应HTTPS</li>\n</ul>\n<p>另外我们也注意到在 热编译的模式中, app.server被 grace.NewServer()函数的返回值给<strong>重写</strong>了<br>因为主要研究 HTTP的处理,所以这里对 grace包不做深究  </p>\n<h2 id=\"ServeHTTP\"><a href=\"#ServeHTTP\" class=\"headerlink\" title=\"ServeHTTP()\"></a>ServeHTTP()</h2><p>了解 http包的都应该知道,在 http.Server.ListenAndServe()被调用后,每当有 HTTP请求来到时就会开启一个新的 goroutine并且调用对应 Server的 Handler接口处理(Handler接口包含了 ServeHTTP()方法).而且我们看到在 app.Run()方法中有一句</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.Server.Handler = app.Handlers</span><br></pre></td></tr></table></figure>\n<p>而这个 app.Handlers也就是我们在第二篇文章中介绍到的 ControllerRegister类型的结构体了<br>在 beego&#x2F;router.go:622行我们也可以发现 ControllerRegister类型实现了 ServeHTTP()方法,那么这个方法就是我们的重中之重了!<br>这个函数的实现有258行,所以就不贴代码了,让我们可以一点一点看</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *ControllerRegister)</span></span> ServeHTTP(rw http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">startTime := time.Now()</span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\trunRouter  reflect.Type</span><br><span class=\"line\">\tfindRouter <span class=\"type\">bool</span><span class=\"comment\">//是否找到路由</span></span><br><span class=\"line\">\trunMethod  <span class=\"type\">string</span></span><br><span class=\"line\">\trouterInfo *controllerInfo</span><br><span class=\"line\">)</span><br><span class=\"line\">\tcontext := p.pool.Get().(*beecontext.Context)</span><br><span class=\"line\">\tcontext.Reset(rw, r)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.pool.Put(context)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.recoverPanic(context)</span><br></pre></td></tr></table></figure>\n<p>函数的开始就是先获得时间,然后从 ControllerRegister中的pool对象池获得一个　Context对象<br>Context对象是对HTTP连接的封装,我们暂时可以理解为 Context中的输入就是客户端发来的信息,输出就是服务器向客户端要发送的信息,所以获得 Context对象后调用 context.Reset()传入当前的 http连接初始化它,可以方便以后的使用  </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 路由大小写敏感</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !BConfig.RouterCaseSensitive &#123;</span><br><span class=\"line\">\t\turlPath = strings.ToLower(r.URL.Path)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\turlPath = r.URL.Path</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查请求中的方法是否支持</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, ok := HTTPMETHOD[r.Method]; !ok &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 不支持则返回405状态</span></span><br><span class=\"line\">\t\thttp.Error(rw, <span class=\"string\">&quot;Method Not Allowed&quot;</span>, <span class=\"number\">405</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 记录</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查对应 url的的 filter</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p.execFilter(context, BeforeStatic, urlPath) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 查找静态文件</span></span><br><span class=\"line\">\tserverStaticRouter(context)<span class=\"comment\">//只对于 &quot;GET&quot;和&quot;HEAD&quot;请求方法有效</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> context.ResponseWriter.Started &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//路由找到并且发送了相应的文件则修改 findRouter标志位并且跳转到记录</span></span><br><span class=\"line\">\t\tfindRouter = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>这里可以看到先根据大小写敏感配置设定 URL的大小写,然后检查传过来的方法是否支持<br>HTTPMETHOD是一个全局类型的 map[string]string类型,主要保存了支持的方法<br>然后调用 p.execFilter()方法,执行对应的Filter,注意这里的 p.execFilter()会在每个阶段被调用能够,这里的阶段有5个,被定义在 beego&#x2F;router.go:36</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tBeforeStatic = <span class=\"literal\">iota</span></span><br><span class=\"line\">\tBeforeRouter</span><br><span class=\"line\">\tBeforeExec</span><br><span class=\"line\">\tAfterExec</span><br><span class=\"line\">\tFinishRouter</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这里的5个阶段同时也对应着 ControllerRegister.filters中的 key,在　p.execFilters()方法中也正是用了不同阶段作为参数而在 ControllerRegister.filters成员总寻找相应的 Filter的  </p>\n<p>接下来<br>就是调用 serverStaticRouter(方法查找静态文件,如果找到,并且 context.ResponseWriter.Started标志位被置位,表示已经开始发送文件,这时只需要跳转到 Admin处记录下这次连接的信息就可以结束了,否则继续执行)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对于非 &quot;GET&quot;和&quot;HEAD&quot;的请求方法开始解析参数</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> r.Method != <span class=\"string\">&quot;GET&quot;</span> &amp;&amp; r.Method != <span class=\"string\">&quot;HEAD&quot;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.CopyRequestBody &amp;&amp; !context.Input.IsUpload() &#123;</span><br><span class=\"line\">\t\tcontext.Input.CopyBody(BConfig.MaxMemory)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcontext.Input.ParseFormOrMulitForm(BConfig.MaxMemory)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// session初始化</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> BConfig.WebConfig.Session.SessionOn &#123; <span class=\"comment\">//...省略&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//检查 Filter,与659行相似,但是会查找不同的 filters数组</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> p.execFilter(context, BeforeRouter, urlPath) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//前面的静态文件未找到,开始查找路由的过程</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> !findRouter &#123;</span><br><span class=\"line\">\thttpMethod := r.Method</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t, ok := p.routers[httpMethod]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里通过 p.routers[httpMethod]进入路由树</span></span><br><span class=\"line\">\t\trunObject := t.Match(urlPath, context)<span class=\"comment\">//找到路由树中对应的 runObject变量</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> r, ok := runObject.(*controllerInfo); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//将 runObject变量还原回 controllerInfo结构体</span></span><br><span class=\"line\">\t\t\trouterInfo = r</span><br><span class=\"line\">\t\t\tfindRouter = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> splat := context.Input.Param(<span class=\"string\">&quot;:splat&quot;</span>); splat != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//如果为全匹配方式,再进行分割</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> strings.Split(splat, <span class=\"string\">&quot;/&quot;</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tcontext.Input.SetParam(strconv.Itoa(k), v)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"comment\">// 如果程序执行到这里还没有找到路由则抛出一个异常并跳转到记录</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> !findRouter &#123;</span><br><span class=\"line\">\texception(<span class=\"string\">&quot;404&quot;</span>, context)</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果前面请求的不是静态文件,则开始解析请求的参数<br>然后初始化 session,也就是利用 Session管理器开始一个 Session会话,并且用 defer关键字关闭会话<br>接下来开始执行 BeforeRouter阶段的 Filter<br>可以看到,在 findRouter标志位未被置位的情况下开始路由的查找,这里的逻辑是先通过 ControllerRegister的 routers成员(也就是第二篇文章中向里面注册路由的变量)通过请求的方法名找到对应的路由树,然后通过 Tree.Match()方法找到对应URL的Tree节点中的 runnObject对象(忘掉 runObject的话可以去看<a href=\"https://riccoqu.github.io/2016/08/01/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/\">Beego源码解析(二)-路由机制</a>中那篇文章)  </p>\n<p>只要找到了 runObject,我们就获得了当初注册路由时的自定义 Controller对象的信息,当然如果查找路由还找不到就向客户端返回”404”错误</p>\n<p>当完成路由的查找后,接下来就应该是执行对应的方法了,这也是比较重要的一段代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找到了路由,进行动作</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> findRouter &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//查找对应的 Filter</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p.execFilter(context, BeforeExec, urlPath) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tisRunnable := <span class=\"literal\">false</span></span><br><span class=\"line\">\t<span class=\"comment\">//找到了 routerInfo</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> routerInfo != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//RESTFul路由,执行对应的方法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> routerInfo.routerType == routerTypeRESTFul &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//查找到了对应的方法,所以调用回调函数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> _, ok := routerInfo.methods[r.Method]; ok &#123;</span><br><span class=\"line\">\t\t\t\tisRunnable = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\trouterInfo.runFunction(context)<span class=\"comment\">//执行对应的回调方法</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\texception(<span class=\"string\">&quot;405&quot;</span>, context)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> routerInfo.routerType == routerTypeHandler &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//Handler类型的路由</span></span><br><span class=\"line\">\t\t\tisRunnable = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\trouterInfo.handler.ServeHTTP(rw, r)<span class=\"comment\">//执行　Handler类型的路由回调方法</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//其他类型的请求</span></span><br><span class=\"line\">\t\t\trunRouter = routerInfo.controllerType</span><br><span class=\"line\">\t\t\tmethod := r.Method</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;POST&quot;</span> &amp;&amp; context.Input.Query(<span class=\"string\">&quot;_method&quot;</span>) == <span class=\"string\">&quot;PUT&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\tmethod = <span class=\"string\">&quot;PUT&quot;</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;POST&quot;</span> &amp;&amp; context.Input.Query(<span class=\"string\">&quot;_method&quot;</span>) == <span class=\"string\">&quot;DELETE&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\tmethod = <span class=\"string\">&quot;DELETE&quot;</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> m, ok := routerInfo.methods[method]; ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//如果找到注册过的方法,则赋值</span></span><br><span class=\"line\">\t\t\t\trunMethod = m</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> m, ok = routerInfo.methods[<span class=\"string\">&quot;*&quot;</span>]; ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//如果支持通配符&#x27;*&#x27;,则赋值</span></span><br><span class=\"line\">\t\t\t\trunMethod = m</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\trunMethod = method</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// also defined runRouter &amp; runMethod from filter</span></span><br><span class=\"line\">\t<span class=\"comment\">//没有正在运行的情况,即在732行的两个 if都没有匹配到</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !isRunnable &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Invoke the request handler</span></span><br><span class=\"line\">\t\tvc := reflect.New(runRouter)</span><br><span class=\"line\">\t\texecController, ok := vc.Interface().(ControllerInterface)<span class=\"comment\">//这是为了还原出注册时的 Controller结构体变量</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;controller is not ControllerInterface&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//call the controller init function</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//调用 Controller的 init()函数</span></span><br><span class=\"line\">\t\texecController.Init(context, runRouter.Name(), runMethod, vc.Interface())</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//call prepare function</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//调用 Controller的 Prepare()函数</span></span><br><span class=\"line\">\t\texecController.Prepare()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//if XSRF is Enable then check cookie where there has any cookie in the  request&#x27;s cookie _csrf</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> BConfig.WebConfig.EnableXSRF &#123;</span><br><span class=\"line\">\t\t\texecController.XSRFToken()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;POST&quot;</span> || r.Method == <span class=\"string\">&quot;DELETE&quot;</span> || r.Method == <span class=\"string\">&quot;PUT&quot;</span> ||</span><br><span class=\"line\">\t\t\t\t(r.Method == <span class=\"string\">&quot;POST&quot;</span> &amp;&amp; (context.Input.Query(<span class=\"string\">&quot;_method&quot;</span>) == <span class=\"string\">&quot;DELETE&quot;</span> || context.Input.Query(<span class=\"string\">&quot;_method&quot;</span>) == <span class=\"string\">&quot;PUT&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t\texecController.CheckXSRFCookie()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\texecController.URLMapping()</span><br><span class=\"line\">\t\t<span class=\"comment\">//根据方法调用不同的处理函数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !context.ResponseWriter.Started &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//exec main logic</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> runMethod &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;GET&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Get()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;POST&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Post()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;DELETE&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Delete()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;PUT&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Put()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;HEAD&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Head()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;PATCH&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Patch()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;OPTIONS&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Options()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> !execController.HandlerFunc(runMethod) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> in []reflect.Value</span><br><span class=\"line\">\t\t\t\t\tmethod := vc.MethodByName(runMethod)</span><br><span class=\"line\">\t\t\t\t\tmethod.Call(in)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//render template</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !context.ResponseWriter.Started &amp;&amp; context.Output.Status == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> BConfig.WebConfig.AutoRender &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> err := execController.Render(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// finish all runRouter. release resource</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//处理完,进行资源的释放</span></span><br><span class=\"line\">\t\texecController.Finish()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//execute middleware filters</span></span><br><span class=\"line\">\t<span class=\"comment\">//执行对应的 Filters</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p.execFilter(context, AfterExec, urlPath) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//在处理完请求后,执行对应的 Filters</span></span><br><span class=\"line\">p.execFilter(context, FinishRouter, urlPath)</span><br></pre></td></tr></table></figure>\n<p>可以看到中间有几个 if else用来判断注册的路由是什么类型</p>\n<ul>\n<li>如果类型是 routerTypeRESTFul并且支持请求的方法,则执行 ControllerInfo的runFunction()方法,否则返回”405”</li>\n<li>如果类型是 routerTypeHandler,则执行 Controller.handler的ServeHTTP()方法</li>\n<li>其他类型的路由,则继续往下执行,注意有两行 “POST”方法的判断,但是 method又改为其他的方法,这是为了用同一个接口实现不同的请求,既将真实的请求放在参数 _method里面</li>\n</ul>\n<p>下面的 if !isRunnable{…} 是当上面匹配到其他类型路由时而执行的流程<br>可以发现通过反射获得了当初注册路由时的 Controller结构体,并依次调用 ControllerInterface接口所定义的方法(这些方法正在在自定义 Controller时需要实现的方法)<br>整个 ServeHTTP()函数的最后调用了 AfterExec阶段和 FinishRouter阶段两个阶段的 Filter  </p>\n<p>在后面就是整个请求结束后的记录过程了,逻辑比较简单只贴上代码就好了~</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 记录此次请求的一些信息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Admin:</span><br><span class=\"line\">\ttimeDur := time.Since(startTime)</span><br><span class=\"line\">\t<span class=\"comment\">//admin module record QPS</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.EnableAdmin &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> FilterMonitorFunc(r.Method, r.URL.Path, timeDur) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> runRouter != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">go</span> toolbox.StatisticsMap.AddStatistics(r.Method, r.URL.Path, runRouter.Name(), timeDur)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">go</span> toolbox.StatisticsMap.AddStatistics(r.Method, r.URL.Path, <span class=\"string\">&quot;&quot;</span>, timeDur)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.RunMode == DEV || BConfig.Log.AccessLogs &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> devInfo <span class=\"type\">string</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> findRouter &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> routerInfo != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tdevInfo = fmt.Sprintf(<span class=\"string\">&quot;| % -10s | % -40s | % -16s | % -10s | % -40s |&quot;</span>, r.Method, r.URL.Path, timeDur.String(), <span class=\"string\">&quot;match&quot;</span>, routerInfo.pattern)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tdevInfo = fmt.Sprintf(<span class=\"string\">&quot;| % -10s | % -40s | % -16s | % -10s |&quot;</span>, r.Method, r.URL.Path, timeDur.String(), <span class=\"string\">&quot;match&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tdevInfo = fmt.Sprintf(<span class=\"string\">&quot;| % -10s | % -40s | % -16s | % -10s |&quot;</span>, r.Method, r.URL.Path, timeDur.String(), <span class=\"string\">&quot;notmatch&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> DefaultAccessLogFilter == <span class=\"literal\">nil</span> || !DefaultAccessLogFilter.Filter(context) &#123;</span><br><span class=\"line\">\t\t\tDebug(devInfo)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Call WriteHeader if status code has been set changed</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> context.Output.Status != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tcontext.ResponseWriter.WriteHeader(context.Output.Status)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个HTTP请求的处理流程大概就是这个样子,先查找静态路由让后再查找用户定义的路由规则,调用相应规则的处理函数</p>\n<p>如有错误,非常希望您能联系我并让我加以改进 :D</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>关于上一篇文章<a href=\"https://riccoqu.github.io/2016/08/01/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/\">Beego源码解析(二)-路由机制</a>中介绍了在 Beego中如注册路由以及如何将我们自定义的路由加入到 Beego的 App实例中<br>我们知道关于注册的路由都是会加入到路由树的节点中,那么在 HTTP的请求中,查找路由树就是非常关键的一部分了  </p>\n</blockquote>\n<p>这篇文章将梳理一遍在 Beego启动后,处理 HTTP请求的流程</p>","more":"<p>关于 Beego的源码注释可以见我的<a href=\"https://github.com/riccoqu/Beego-Comments\"><strong>Github</strong></a></p>\n<h2 id=\"beego-Run-入口\"><a href=\"#beego-Run-入口\" class=\"headerlink\" title=\"beego.Run()入口\"></a>beego.Run()入口</h2><p>在第一篇文章中就曾提到过,在启动 Beego应用时都是通过调用 beego.Run()方法启动.而这个方法在设置了6个回到调函数后会进入 app.Run()方法(app就是我们 Beego应用程序的一个实例,在 app.go的 init()函数中被初始化)  </p>\n<h3 id=\"app-Run-函数\"><a href=\"#app-Run-函数\" class=\"headerlink\" title=\"app.Run()函数\"></a>app.Run()函数</h3><p>app.Run()函数就是在一切都准备好之后进入 HTTP请求循环的一个启动函数了,函数并不是很长而且逻辑比较简单,结合注释看下即可<br>beego&#x2F;app.go:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// beego程序启动函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(app *App)</span></span> Run() &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获得地址</span></span><br><span class=\"line\">\taddr := BConfig.Listen.HTTPAddr</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.HTTPPort != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\taddr = fmt.Sprintf(<span class=\"string\">&quot;%s:%d&quot;</span>, BConfig.Listen.HTTPAddr, BConfig.Listen.HTTPPort)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> (</span><br><span class=\"line\">\t\terr        <span class=\"type\">error</span></span><br><span class=\"line\">\t\tl          net.Listener</span><br><span class=\"line\">\t\tendRunning = <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">bool</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\t<span class=\"comment\">// 运行 CGI服务器</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.EnableFcgi &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//这里设置标准包中的 http.Server.handler为 app.ServerHandler</span></span><br><span class=\"line\">\t<span class=\"comment\">//也就是 ContollerRegister类型,因为 ControllerRegister实现了 ServeHTTP()函数</span></span><br><span class=\"line\">\tapp.Server.Handler = app.Handlers</span><br><span class=\"line\">\t<span class=\"comment\">//设置超时</span></span><br><span class=\"line\">\tapp.Server.ReadTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second</span><br><span class=\"line\">\tapp.Server.WriteTimeout = time.Duration(BConfig.Listen.ServerTimeOut) * time.Second</span><br><span class=\"line\">\t<span class=\"comment\">// 运行热编译模式</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.Graceful &#123;</span><br><span class=\"line\">\t\thttpsAddr := BConfig.Listen.HTTPSAddr</span><br><span class=\"line\">\t\tapp.Server.Addr = httpsAddr</span><br><span class=\"line\">\t\t<span class=\"comment\">// 热编译模式下的 HTTPS</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> BConfig.Listen.EnableHTTPS &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\ttime.Sleep(<span class=\"number\">20</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> BConfig.Listen.HTTPSPort != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\thttpsAddr = fmt.Sprintf(<span class=\"string\">&quot;%s:%d&quot;</span>, BConfig.Listen.HTTPSAddr, BConfig.Listen.HTTPSPort)</span><br><span class=\"line\">\t\t\t\t\tapp.Server.Addr = httpsAddr</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tserver := grace.NewServer(httpsAddr, app.Handlers)</span><br><span class=\"line\">\t\t\t\tserver.Server.ReadTimeout = app.Server.ReadTimeout</span><br><span class=\"line\">\t\t\t\tserver.Server.WriteTimeout = app.Server.WriteTimeout</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//执行 HTTPS的 ListenAndServerTLS()</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err := server.ListenAndServeTLS(BConfig.Listen.HTTPSCertFile, BConfig.Listen.HTTPSKeyFile); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServeTLS: &quot;</span>, err, fmt.Sprintf(<span class=\"string\">&quot;%d&quot;</span>, os.Getpid()))</span><br><span class=\"line\">\t\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 热编译模式下的 HTTP</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> BConfig.Listen.EnableHTTP &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t\tserver := grace.NewServer(addr, app.Handlers)</span><br><span class=\"line\">\t\t\t\tserver.Server.ReadTimeout = app.Server.ReadTimeout</span><br><span class=\"line\">\t\t\t\tserver.Server.WriteTimeout = app.Server.WriteTimeout</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> BConfig.Listen.ListenTCP4 &#123;</span><br><span class=\"line\">\t\t\t\t\tserver.Network = <span class=\"string\">&quot;tcp4&quot;</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 执行 HTTP的 ListenAndServe()</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err := server.ListenAndServe(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err, fmt.Sprintf(<span class=\"string\">&quot;%d&quot;</span>, os.Getpid()))</span><br><span class=\"line\">\t\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;()</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t&lt;-endRunning</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 运行普通模式</span></span><br><span class=\"line\">\tapp.Server.Addr = addr</span><br><span class=\"line\">\t<span class=\"comment\">// HTTPS</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.EnableHTTPS &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\ttime.Sleep(<span class=\"number\">20</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> BConfig.Listen.HTTPSPort != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tapp.Server.Addr = fmt.Sprintf(<span class=\"string\">&quot;%s:%d&quot;</span>, BConfig.Listen.HTTPSAddr, BConfig.Listen.HTTPSPort)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tBeeLogger.Info(<span class=\"string\">&quot;https server Running on %s&quot;</span>, app.Server.Addr)</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 运行 ListenAndServeTLS</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := app.Server.ListenAndServeTLS(BConfig.Listen.HTTPSCertFile, BConfig.Listen.HTTPSKeyFile); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServeTLS: &quot;</span>, err)</span><br><span class=\"line\">\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// HTTP</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.EnableHTTP &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\tapp.Server.Addr = addr</span><br><span class=\"line\">\t\t\tBeeLogger.Info(<span class=\"string\">&quot;http server Running on %s&quot;</span>, app.Server.Addr)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> BConfig.Listen.ListenTCP4 &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//TCP4</span></span><br><span class=\"line\">\t\t\t\tln, err := net.Listen(<span class=\"string\">&quot;tcp4&quot;</span>, app.Server.Addr)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err = app.Server.Serve(ln); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 运行 ListenAndServe()</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> err := app.Server.ListenAndServe(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tBeeLogger.Critical(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class=\"line\">\t\t\t\t\ttime.Sleep(<span class=\"number\">100</span> * time.Microsecond)</span><br><span class=\"line\">\t\t\t\t\tendRunning &lt;- <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&lt;-endRunning</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的因为主要讲 HTTP的请求处理,所以为了代码更短我将 CGI部分的代码删掉了<br>想看的可以去看 app.Run()的源码 :D</p>\n<p>这个函数的逻辑也比较简单,因为在运行到这个函数之前该初始化的地方已经都做好了<br>所以这个函数只需要根据不同的配置启动不同的服务就行,不同的是根据不同的服务需要调用  </p>\n<ul>\n<li>serve.Server()            对应TCP4</li>\n<li>server.ListenAndServe()    对应HTTP</li>\n<li>serve.ListenAndServeLTS()    对应HTTPS</li>\n</ul>\n<p>另外我们也注意到在 热编译的模式中, app.server被 grace.NewServer()函数的返回值给<strong>重写</strong>了<br>因为主要研究 HTTP的处理,所以这里对 grace包不做深究  </p>\n<h2 id=\"ServeHTTP\"><a href=\"#ServeHTTP\" class=\"headerlink\" title=\"ServeHTTP()\"></a>ServeHTTP()</h2><p>了解 http包的都应该知道,在 http.Server.ListenAndServe()被调用后,每当有 HTTP请求来到时就会开启一个新的 goroutine并且调用对应 Server的 Handler接口处理(Handler接口包含了 ServeHTTP()方法).而且我们看到在 app.Run()方法中有一句</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.Server.Handler = app.Handlers</span><br></pre></td></tr></table></figure>\n<p>而这个 app.Handlers也就是我们在第二篇文章中介绍到的 ControllerRegister类型的结构体了<br>在 beego&#x2F;router.go:622行我们也可以发现 ControllerRegister类型实现了 ServeHTTP()方法,那么这个方法就是我们的重中之重了!<br>这个函数的实现有258行,所以就不贴代码了,让我们可以一点一点看</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *ControllerRegister)</span></span> ServeHTTP(rw http.ResponseWriter, r *http.Request) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">startTime := time.Now()</span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\trunRouter  reflect.Type</span><br><span class=\"line\">\tfindRouter <span class=\"type\">bool</span><span class=\"comment\">//是否找到路由</span></span><br><span class=\"line\">\trunMethod  <span class=\"type\">string</span></span><br><span class=\"line\">\trouterInfo *controllerInfo</span><br><span class=\"line\">)</span><br><span class=\"line\">\tcontext := p.pool.Get().(*beecontext.Context)</span><br><span class=\"line\">\tcontext.Reset(rw, r)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.pool.Put(context)</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.recoverPanic(context)</span><br></pre></td></tr></table></figure>\n<p>函数的开始就是先获得时间,然后从 ControllerRegister中的pool对象池获得一个　Context对象<br>Context对象是对HTTP连接的封装,我们暂时可以理解为 Context中的输入就是客户端发来的信息,输出就是服务器向客户端要发送的信息,所以获得 Context对象后调用 context.Reset()传入当前的 http连接初始化它,可以方便以后的使用  </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 路由大小写敏感</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !BConfig.RouterCaseSensitive &#123;</span><br><span class=\"line\">\t\turlPath = strings.ToLower(r.URL.Path)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\turlPath = r.URL.Path</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查请求中的方法是否支持</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, ok := HTTPMETHOD[r.Method]; !ok &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 不支持则返回405状态</span></span><br><span class=\"line\">\t\thttp.Error(rw, <span class=\"string\">&quot;Method Not Allowed&quot;</span>, <span class=\"number\">405</span>)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 记录</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 检查对应 url的的 filter</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p.execFilter(context, BeforeStatic, urlPath) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 查找静态文件</span></span><br><span class=\"line\">\tserverStaticRouter(context)<span class=\"comment\">//只对于 &quot;GET&quot;和&quot;HEAD&quot;请求方法有效</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> context.ResponseWriter.Started &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//路由找到并且发送了相应的文件则修改 findRouter标志位并且跳转到记录</span></span><br><span class=\"line\">\t\tfindRouter = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>这里可以看到先根据大小写敏感配置设定 URL的大小写,然后检查传过来的方法是否支持<br>HTTPMETHOD是一个全局类型的 map[string]string类型,主要保存了支持的方法<br>然后调用 p.execFilter()方法,执行对应的Filter,注意这里的 p.execFilter()会在每个阶段被调用能够,这里的阶段有5个,被定义在 beego&#x2F;router.go:36</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tBeforeStatic = <span class=\"literal\">iota</span></span><br><span class=\"line\">\tBeforeRouter</span><br><span class=\"line\">\tBeforeExec</span><br><span class=\"line\">\tAfterExec</span><br><span class=\"line\">\tFinishRouter</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这里的5个阶段同时也对应着 ControllerRegister.filters中的 key,在　p.execFilters()方法中也正是用了不同阶段作为参数而在 ControllerRegister.filters成员总寻找相应的 Filter的  </p>\n<p>接下来<br>就是调用 serverStaticRouter(方法查找静态文件,如果找到,并且 context.ResponseWriter.Started标志位被置位,表示已经开始发送文件,这时只需要跳转到 Admin处记录下这次连接的信息就可以结束了,否则继续执行)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对于非 &quot;GET&quot;和&quot;HEAD&quot;的请求方法开始解析参数</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> r.Method != <span class=\"string\">&quot;GET&quot;</span> &amp;&amp; r.Method != <span class=\"string\">&quot;HEAD&quot;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.CopyRequestBody &amp;&amp; !context.Input.IsUpload() &#123;</span><br><span class=\"line\">\t\tcontext.Input.CopyBody(BConfig.MaxMemory)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcontext.Input.ParseFormOrMulitForm(BConfig.MaxMemory)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// session初始化</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> BConfig.WebConfig.Session.SessionOn &#123; <span class=\"comment\">//...省略&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//检查 Filter,与659行相似,但是会查找不同的 filters数组</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> p.execFilter(context, BeforeRouter, urlPath) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//前面的静态文件未找到,开始查找路由的过程</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> !findRouter &#123;</span><br><span class=\"line\">\thttpMethod := r.Method</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t, ok := p.routers[httpMethod]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里通过 p.routers[httpMethod]进入路由树</span></span><br><span class=\"line\">\t\trunObject := t.Match(urlPath, context)<span class=\"comment\">//找到路由树中对应的 runObject变量</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> r, ok := runObject.(*controllerInfo); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//将 runObject变量还原回 controllerInfo结构体</span></span><br><span class=\"line\">\t\t\trouterInfo = r</span><br><span class=\"line\">\t\t\tfindRouter = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> splat := context.Input.Param(<span class=\"string\">&quot;:splat&quot;</span>); splat != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//如果为全匹配方式,再进行分割</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> strings.Split(splat, <span class=\"string\">&quot;/&quot;</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\tcontext.Input.SetParam(strconv.Itoa(k), v)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"comment\">// 如果程序执行到这里还没有找到路由则抛出一个异常并跳转到记录</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> !findRouter &#123;</span><br><span class=\"line\">\texception(<span class=\"string\">&quot;404&quot;</span>, context)</span><br><span class=\"line\">\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果前面请求的不是静态文件,则开始解析请求的参数<br>然后初始化 session,也就是利用 Session管理器开始一个 Session会话,并且用 defer关键字关闭会话<br>接下来开始执行 BeforeRouter阶段的 Filter<br>可以看到,在 findRouter标志位未被置位的情况下开始路由的查找,这里的逻辑是先通过 ControllerRegister的 routers成员(也就是第二篇文章中向里面注册路由的变量)通过请求的方法名找到对应的路由树,然后通过 Tree.Match()方法找到对应URL的Tree节点中的 runnObject对象(忘掉 runObject的话可以去看<a href=\"https://riccoqu.github.io/2016/08/01/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%BA%8C-%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6/\">Beego源码解析(二)-路由机制</a>中那篇文章)  </p>\n<p>只要找到了 runObject,我们就获得了当初注册路由时的自定义 Controller对象的信息,当然如果查找路由还找不到就向客户端返回”404”错误</p>\n<p>当完成路由的查找后,接下来就应该是执行对应的方法了,这也是比较重要的一段代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找到了路由,进行动作</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> findRouter &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//查找对应的 Filter</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p.execFilter(context, BeforeExec, urlPath) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tisRunnable := <span class=\"literal\">false</span></span><br><span class=\"line\">\t<span class=\"comment\">//找到了 routerInfo</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> routerInfo != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//RESTFul路由,执行对应的方法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> routerInfo.routerType == routerTypeRESTFul &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//查找到了对应的方法,所以调用回调函数</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> _, ok := routerInfo.methods[r.Method]; ok &#123;</span><br><span class=\"line\">\t\t\t\tisRunnable = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\trouterInfo.runFunction(context)<span class=\"comment\">//执行对应的回调方法</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\texception(<span class=\"string\">&quot;405&quot;</span>, context)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> routerInfo.routerType == routerTypeHandler &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//Handler类型的路由</span></span><br><span class=\"line\">\t\t\tisRunnable = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\trouterInfo.handler.ServeHTTP(rw, r)<span class=\"comment\">//执行　Handler类型的路由回调方法</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//其他类型的请求</span></span><br><span class=\"line\">\t\t\trunRouter = routerInfo.controllerType</span><br><span class=\"line\">\t\t\tmethod := r.Method</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;POST&quot;</span> &amp;&amp; context.Input.Query(<span class=\"string\">&quot;_method&quot;</span>) == <span class=\"string\">&quot;PUT&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\tmethod = <span class=\"string\">&quot;PUT&quot;</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;POST&quot;</span> &amp;&amp; context.Input.Query(<span class=\"string\">&quot;_method&quot;</span>) == <span class=\"string\">&quot;DELETE&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\tmethod = <span class=\"string\">&quot;DELETE&quot;</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> m, ok := routerInfo.methods[method]; ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//如果找到注册过的方法,则赋值</span></span><br><span class=\"line\">\t\t\t\trunMethod = m</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> m, ok = routerInfo.methods[<span class=\"string\">&quot;*&quot;</span>]; ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//如果支持通配符&#x27;*&#x27;,则赋值</span></span><br><span class=\"line\">\t\t\t\trunMethod = m</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\trunMethod = method</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// also defined runRouter &amp; runMethod from filter</span></span><br><span class=\"line\">\t<span class=\"comment\">//没有正在运行的情况,即在732行的两个 if都没有匹配到</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !isRunnable &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Invoke the request handler</span></span><br><span class=\"line\">\t\tvc := reflect.New(runRouter)</span><br><span class=\"line\">\t\texecController, ok := vc.Interface().(ControllerInterface)<span class=\"comment\">//这是为了还原出注册时的 Controller结构体变量</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;controller is not ControllerInterface&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//call the controller init function</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//调用 Controller的 init()函数</span></span><br><span class=\"line\">\t\texecController.Init(context, runRouter.Name(), runMethod, vc.Interface())</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//call prepare function</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//调用 Controller的 Prepare()函数</span></span><br><span class=\"line\">\t\texecController.Prepare()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//if XSRF is Enable then check cookie where there has any cookie in the  request&#x27;s cookie _csrf</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> BConfig.WebConfig.EnableXSRF &#123;</span><br><span class=\"line\">\t\t\texecController.XSRFToken()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;POST&quot;</span> || r.Method == <span class=\"string\">&quot;DELETE&quot;</span> || r.Method == <span class=\"string\">&quot;PUT&quot;</span> ||</span><br><span class=\"line\">\t\t\t\t(r.Method == <span class=\"string\">&quot;POST&quot;</span> &amp;&amp; (context.Input.Query(<span class=\"string\">&quot;_method&quot;</span>) == <span class=\"string\">&quot;DELETE&quot;</span> || context.Input.Query(<span class=\"string\">&quot;_method&quot;</span>) == <span class=\"string\">&quot;PUT&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t\texecController.CheckXSRFCookie()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\texecController.URLMapping()</span><br><span class=\"line\">\t\t<span class=\"comment\">//根据方法调用不同的处理函数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !context.ResponseWriter.Started &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//exec main logic</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> runMethod &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;GET&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Get()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;POST&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Post()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;DELETE&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Delete()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;PUT&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Put()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;HEAD&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Head()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;PATCH&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Patch()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&quot;OPTIONS&quot;</span>:</span><br><span class=\"line\">\t\t\t\texecController.Options()</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> !execController.HandlerFunc(runMethod) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">var</span> in []reflect.Value</span><br><span class=\"line\">\t\t\t\t\tmethod := vc.MethodByName(runMethod)</span><br><span class=\"line\">\t\t\t\t\tmethod.Call(in)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//render template</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> !context.ResponseWriter.Started &amp;&amp; context.Output.Status == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> BConfig.WebConfig.AutoRender &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> err := execController.Render(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// finish all runRouter. release resource</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//处理完,进行资源的释放</span></span><br><span class=\"line\">\t\texecController.Finish()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//execute middleware filters</span></span><br><span class=\"line\">\t<span class=\"comment\">//执行对应的 Filters</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p.execFilter(context, AfterExec, urlPath) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">goto</span> Admin</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//在处理完请求后,执行对应的 Filters</span></span><br><span class=\"line\">p.execFilter(context, FinishRouter, urlPath)</span><br></pre></td></tr></table></figure>\n<p>可以看到中间有几个 if else用来判断注册的路由是什么类型</p>\n<ul>\n<li>如果类型是 routerTypeRESTFul并且支持请求的方法,则执行 ControllerInfo的runFunction()方法,否则返回”405”</li>\n<li>如果类型是 routerTypeHandler,则执行 Controller.handler的ServeHTTP()方法</li>\n<li>其他类型的路由,则继续往下执行,注意有两行 “POST”方法的判断,但是 method又改为其他的方法,这是为了用同一个接口实现不同的请求,既将真实的请求放在参数 _method里面</li>\n</ul>\n<p>下面的 if !isRunnable{…} 是当上面匹配到其他类型路由时而执行的流程<br>可以发现通过反射获得了当初注册路由时的 Controller结构体,并依次调用 ControllerInterface接口所定义的方法(这些方法正在在自定义 Controller时需要实现的方法)<br>整个 ServeHTTP()函数的最后调用了 AfterExec阶段和 FinishRouter阶段两个阶段的 Filter  </p>\n<p>在后面就是整个请求结束后的记录过程了,逻辑比较简单只贴上代码就好了~</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 记录此次请求的一些信息</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Admin:</span><br><span class=\"line\">\ttimeDur := time.Since(startTime)</span><br><span class=\"line\">\t<span class=\"comment\">//admin module record QPS</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.Listen.EnableAdmin &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> FilterMonitorFunc(r.Method, r.URL.Path, timeDur) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> runRouter != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">go</span> toolbox.StatisticsMap.AddStatistics(r.Method, r.URL.Path, runRouter.Name(), timeDur)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">go</span> toolbox.StatisticsMap.AddStatistics(r.Method, r.URL.Path, <span class=\"string\">&quot;&quot;</span>, timeDur)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> BConfig.RunMode == DEV || BConfig.Log.AccessLogs &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> devInfo <span class=\"type\">string</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> findRouter &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> routerInfo != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tdevInfo = fmt.Sprintf(<span class=\"string\">&quot;| % -10s | % -40s | % -16s | % -10s | % -40s |&quot;</span>, r.Method, r.URL.Path, timeDur.String(), <span class=\"string\">&quot;match&quot;</span>, routerInfo.pattern)</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tdevInfo = fmt.Sprintf(<span class=\"string\">&quot;| % -10s | % -40s | % -16s | % -10s |&quot;</span>, r.Method, r.URL.Path, timeDur.String(), <span class=\"string\">&quot;match&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tdevInfo = fmt.Sprintf(<span class=\"string\">&quot;| % -10s | % -40s | % -16s | % -10s |&quot;</span>, r.Method, r.URL.Path, timeDur.String(), <span class=\"string\">&quot;notmatch&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> DefaultAccessLogFilter == <span class=\"literal\">nil</span> || !DefaultAccessLogFilter.Filter(context) &#123;</span><br><span class=\"line\">\t\t\tDebug(devInfo)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Call WriteHeader if status code has been set changed</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> context.Output.Status != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tcontext.ResponseWriter.WriteHeader(context.Output.Status)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个HTTP请求的处理流程大概就是这个样子,先查找静态路由让后再查找用户定义的路由规则,调用相应规则的处理函数</p>\n<p>如有错误,非常希望您能联系我并让我加以改进 :D</p>"},{"title":"Beego源码解析(二)-路由机制","date":"2016-07-31T16:22:08.000Z","_content":"\n>上一篇文章[Beego源码解析(一)-配置项初始化流程](https://riccoqu.github.io/2016/07/30/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E2%80%94%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/)介绍了 Beego关于配置项初始化的流程。那么今天就来说说在 Beego中非常重要的**路由机制**.  \nBeego到现在 v1.6.1版本为止支持了:**固定路由**、**正则路由**、**自动路由**这三种路由方法.  \n关于这三种路由的详细用法可以参考官方给出的[**开发文档**](),这里面已经记录的很全面了.  \n\n所以我们今天这篇文章就是要介绍这三种路由是如何在 Beego内部实现的.  \n\n<!--more-->\n\n关于 Beego的源码注释可以见我的[**Github**](https://github.com/riccoqu/Beego-Comments)\n\n## 一个简单的示例\n让我们先从官网给出的示例开始,下面是会在浏览器中打印\"HelloWorld\"的一个Beego程序.\n```Go\npackage main\n\nimport(\n\t\"github.com/astaxie/beego\"\n)\n\ntype MainController struct {\n\tbeego.Controller\n}\n\nfunc (this *MainController) Get() {\n\tthis.Ctx.WriteString(\"Hello World\")\n}\n\nfunc main() {\n\t\tbeego.Router(\"/\",&MainController{})\n\t\tbeego.Run()\n}\n```\n\n我们需要先知道它干了什么:\n1. 自定义了一个内含 beego.Controller(这个类型后面会讲到)控制器的 MainController\n2. 重写了 MainController的 Get()方法,熟悉 Go语言的应该知道这个方法来自 Controller\n3. 在 main()函数中调用了 beego.Router()方法注册了路由\"/\"和一个 MainController实例\n4. 执行了 beego.Run()方法启用了 beego程序\n\n## 重要的类型和接口\n为了不在接下来的流程中打断,在介绍流程之前需要先了解 beego中关于路由的一些东西\n\n### ControllerInterface 接口\n\n源文件中的位置: beego/controller.go:90\n```Go\ntype ControllerInterface interface {\n\t\tInit(ct *context.Context,controllerName,actionName string,app interface{})\n\t\tPrepare()\n\t\tGet()\n\t\tPost()\n\t\tDelete()\n\t\tPut()\n\t\tHead()\n\t\tPatch()\n\t\tOptions()\n\t\tFinish()\n\t\tRender() error\n\t\tXSRFToken() string\n\t\tCheckXSRFCookie() bool\n\t\tHandlerFunc(fn string) bool\n\t\tURLMapping()\n}\n```\n\n这个接口定义了 15个方法,看名字就能够知道这是每个 Controller都需要实现的接口\n\n### Controller结构体\n\n位置 beego/controller.go:60\n```Go\ntype Controller struct {\n\n//context data\nCtx  *context.Context\nData map[interface{}]interface{}\n\n//route controller info\ncontrollerName string\nactionName     string\nmethodMapping  map[string]func() //method:routertree\ngotofunc       string\nAppController  interface{}\n\n// template data\nTplName        string\nLayout         string\nLayoutSections map[string]string // the key is the section name and the value is the template name\nTplExt         string\nEnableRender   bool\n\n// xsrf data\n_xsrfToken string\nXSRFExpire int\nEnableXSRF bool\n\n// session\nCruSession session.Store\n}\n```\n\n这个结构体保存了作为 Controller的一些必要的信息,一些基础的字段看名字就比较好理解  \n在这里的 context.Context(Beego中的上下文,封装了 HTTP的输入和输出)和 Session.Store(用于存储 Session)在以后的文章中会再提到  \n\n在这个源文件中的后面部分都是对 Controller的一些方法实现,我们会注意到 Controller实现了 ControllerInterface的方法,但是在一些方法实现中却是用 Ctx成员向客户端进行错误输出(例如 Get()方法)。  \n因为就像例子中给的一样,当我们需要自己定义 Controller,并且使用 Get()函数来完成对客户端 Get请求的处理时,我们就需要自己实现处理逻辑,这样就**覆盖**了本身输出错误的方法.而对于我们没有实现的方法(比如例子中的 Post()方法)没有重写,则对于客户端的 Post请求就会输出错误了\n\n### ControllerRegister结构体\n这是一个非常关键的数据结构,为什么说他关键呢?我们可以先看下 Beego中 App结构体的定义\n位置: beego/app.go\n```Go\ntype App struct {\n\tHandlers *ControllerRegister\n\tServer *http.Server\n}\n```\n\n关于 App需要说下,在程序中 App类型的变量**BeeApp**(beego/app.go:32)在 init()函数中会调用 NewApp()创建出唯一的一个Beego程序实例  \n可以看到在例子中 main()函数最后调用了 beego.Run()函数,这个函数会在设置完hooks(关于回调方法以后也会介绍)后进入 BeeApp.Run()函数并且在进入这个函数后就会根据配置项开始不同的　HTTP请求的处理(在 ControllerRegister实现的 ServeHTTP()方法中)\nApp中一共就两个变量,一个**Server**(标准包中 http.Server类型,这个不做介绍,需要的可以看 Go语言文档).  \n另外一个就是 **ControllerRegister**,这个 ControllerRegister顾名思义就是注册 Controller的管理器,那么如何管理的呢?接下来看定义\n\n位置: beego/router.go:115\n```Go\ntype ControllerRegister struct {\n\trouters map[string][]*Tree\n\tenableFilter bool\n\tfilters map[int][]*FilterRouter\n\tpool sync.Pool\n}\n```\n\n可以看到这篇文章的主角已经出现了, routers就是我们程序运行时所需要的路由表, routers的 key是我们注册的方法名(例如\"get\"、\"post\"等),而 value就是由注册的路由构建出来的路由树了(关于路由树,后面也会讲到).\n\n### ControllerInfo结构体\n这个结构体是用来保存我们自定义的控制器信息的,看下定义便知道  \n位置: beego/router.go:104\n```Go\ntype ControllerInfo struct {\n\tpattern string\t//模式\n\tcontrollerType reflect.Type//类型\n\tmethods map[string]string//支持的方法\n\thandler http.Handler//http.Handler接口\n\trunFunction FilterFunc\n\trouterType int//路由类型\n}\n```\n\n### Tree结构体\n```Go\ntype Tree struct {\n\t//路由前缀\n\tprefix string\n\t//不带正则的路由\n\tfixrouters []*Tree\n\t//通配符,如果设置并且查找 fixrouters失败时会来查找 wildcard\n\twildcard *Tree\n\t//叶子节点,如果设置并且查找 wildcard失败后会查找 leaves,里面保存了一些正则的信息\n\tleaves []*leafInfo\n}\n```\n\n### leafInfo结构体\n```Go\ntype leafInfo struct {\n\twildcards []string//通配符\n\tregexps *regexp.Regexp//正则对象\n\trunObject interface{}//一般保存得到的 ControllerInfo对象,在处理请求时会返回该对象,并调用处理方法\n}\n```\n这两个结构体就会构成一颗用来查找路由的路由树,通过结构体的定义我们应该不难看出关于正则的部分都会存放在叶子节点中.所以这个路由树的大致样子也比较好理解\n\n## 路由的注册过程\n在前面的实例中可以看到需要注册自己的 Controller时使用的是 beego.Router()函数(在官方开发文档中的基础路由部分也可以使用 beego.Get()方法注册路由,不过内部与用 beego.Router()注册方法相比都会使用 addToRouter()函数,所以也是比较相似的)  \n\n看下 beego.Router的原型:\n```Go\nbeego/app.go:211\nfunc Router(rootpath string,c ControllerInterface,mappingMethods ...string *App) {\n\t\tBeeApp.Handlers.Add(rootpath,c,mappingMethods...)\n\t\treturn BeeApp\n}\n```\n\n看到第一个参数是需要注册路由,而第二个参数是我们自定义实现了 ControllerInterface接口的控制器,第三个就是自定义路由中方法和处理函数的映射关系  \n函数内部实际调用了 App.ControllerRegister的Add()方法来注册  \n接下来看看 Add()方法做了什么:  \n位置: beego/router.go:144\n```Go\nfunc (p *ControllerRegister) Add(pattern string, c ControllerInterface, mappingMethods ...string) {\n\treflectVal := reflect.ValueOf(c)\t//反射获得 value\n\tt := reflect.Indirect(reflectVal).Type()//反射获得 type\n\tmethods := make(map[string]string)\n\tif len(mappingMethods) > 0 {\n\t\tsemi := strings.Split(mappingMethods[0], \";\")//切分出每个以';'分隔的自定义方法和对应的函数\n\t\tfor _, v := range semi {\n\t\t\tcolon := strings.Split(v, \":\")//切分出以':'分隔的方法名和对应的函数,colon[1]为处理的函数名\n\t\t\tif len(colon) != 2 {\n\t\t\t\tpanic(\"method mapping format is invalid\")\n\t\t\t}\n\t\t\tcomma := strings.Split(colon[0], \",\")//切分出以','分隔的方法名, comma包含了当前需要注册的所有方法名\n\t\t\tfor _, m := range comma {\n\t\t\t\tif _, ok := HTTPMETHOD[strings.ToUpper(m)]; m == \"*\" || ok {\n\t\t\t\t\t//如果方法名为通配符'*'或者在支持的方法列表中.并使用反射包中的方法获得一个绑定对应函数的　Value类型\n\t\t\t\t\t//如果返回的值有效,就将当前方法加入到 methods中\n\t\t\t\t\tif val := reflectVal.MethodByName(colon[1]); val.IsValid() {\n\t\t\t\t\t\tmethods[strings.ToUpper(m)] = colon[1]\n\t\t\t\t\t} else {\n\t\t\t\t\t//不支持方法时报错\n\t\t\t\t\t\tpanic(\"'\" + colon[1] + \"' method doesn't exist in the controller \" + t.Name())\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\tpanic(v + \" is an invalid method mapping. Method doesn't exist \" + m)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//添加 ControllerInfo类型来保存此项路由规则\n\troute := &controllerInfo{}\n\troute.pattern = pattern\n\troute.methods = methods\n\troute.routerType = routerTypeBeego\n\troute.controllerType = t\n\t//当传入的方法名为空时,给当前模式加入所有支持的方法\n\tif len(methods) == 0 {\n\t\tfor _, m := range HTTPMETHOD {\n\t\t\tp.addToRouter(m, pattern, route)\n\t\t}\n\t} else {\n\t\t//方法名不为空时,判断是否含有通配符 \"*\"\n\t\tfor k := range methods {\n\t\t\tif k == \"*\" {\n\t\t\t\tfor _, m := range HTTPMETHOD {\n\t\t\t\t\t//含有通配符,加入所有方法\n\t\t\t\t\tp.addToRouter(m, pattern, route)\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\t//只加入指定的方法\n\t\t\t\t\tp.addToRouter(k, pattern, route)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n这是一个稍微长点的函数,不过通过注释可以看出这个函数做了几个工作:\n1. 解析了传入的 mappingMethods,得到其中包含的全部方法\n2. 用传入的4个参数构造出一个 ControllerInfo的实例,而这个实例中就保存了我们自定的控制器的 reflct.Type类型(可参考[ControllerInfo](#ControllerInfo结构体))  \n\n在函数的最后调用了 ControllerRegister的 addToRouter()方法\n\n位置: beego/router.go:199\n```Go\nfunc (p *ControllerRegister) addToRouter(method, pattern string, r *controllerInfo) {\n\tif !BConfig.RouterCaseSensitive {\n\t\tpattern = strings.ToLower(pattern)\n\t}\n\tif t, ok := p.routers[method]; ok {\n\t\t//如果方法对应的路由树存在就直接添加\n\t\tt.AddRouter(pattern, r)\n\t} else {\n\t\t//方法不存在这新创建一个路由树\n\t\tt := NewTree()\n\t\tt.AddRouter(pattern, r)\n\t\t//设定新方法的路由树\n\t\tp.routers[method] = t\n\t}\n}\n```\n这个方法比较短,主要是判断当前的方法是否在 ControllerRegister的成员 routers所支持的方法中  \n* 存在就直接插入对应的路由树  \n* 否则创建一个新的路由树  \n\n路由树节点的插入操作就是 Tree.AddRouter()方法\n\n位置: beego/tree.go:206\n```Go\nfunc (t *Tree) AddRouter(pattern string,runObject interface{}) {\n\tt.addseg(splitPath(pattern),runObject,nil,\"\")\n}\n```\n可以看出它只是把 pattern中的路径进行了切割(例如\"/admin/users\"切割成\"[\"admin\",\"users\"]\"),并返回一个 string类型的数组切片  \n那么接下来的目的就很明确了,我们需要使用 Tree提供的 addseg方法给路由树**添加节点**\n\n这个函数也是最终的一个函数了,函数的逻辑可以看注释\n\n```Go\nfunc (t *Tree) addseg(segments []string, route interface{}, wildcards []string, reg string) {\n\tif len(segments) == 0 {\n\t\tif reg != \"\" {\n\t\t\t//添加 leaves节点,并给 leaves添加正则规则\n\t\t\tt.leaves = append(t.leaves, &leafInfo{runObject: route, wildcards: wildcards, regexps: regexp.MustCompile(\"^\" + reg + \"$\")})\n\t\t} else {\n\t\t\tt.leaves = append(t.leaves, &leafInfo{runObject: route, wildcards: wildcards})\n\t\t}\n\t} else {\n\t\tseg := segments[0]\n\t\tiswild, params, regexpStr := splitSegment(seg)//splitSegment函数在后面介绍\n\t\t// if it's ? meaning can igone this, so add one more rule for it\n\t\tif len(params) > 0 && params[0] == \":\" {\n\t\t\t//当　params[0]为':'时,代表参数为空,开始解析下一个\n\t\t\tt.addseg(segments[1:], route, wildcards, reg)//递归调用\n\t\t\tparams = params[1:]\n\t\t}\n\t\t//Rule: /login/*/access match /login/2009/11/access\n\t\t//if already has *, and when loop the access, should as a regexpStr\n\t\t//全匹配方式,可参考　http://beego.me/docs/mvc/controller/router.md 的正则路由->全匹配方式\n\t\t// utils.InSlice()检查\":solat\"是否在wildcards中\n\t\tif !iswild && utils.InSlice(\":splat\", wildcards) {\n\t\t\t//如果使用了全匹配方式则继续使用正则解析\n\t\t\tiswild = true\n\t\t\tregexpStr = seg\n\t\t}\n\t\t//Rule: /user/:id/*\n\t\tif seg == \"*\" && len(wildcards) > 0 && reg == \"\" {\n\t\t\tregexpStr = \"(.+)\"\n\t\t}\n\t\t//包含有正则表达式　\n\t\tif iswild {\n\t\t\tif t.wildcard == nil {\n\t\t\t\tt.wildcard = NewTree()\n\t\t\t}\n\t\t\tif regexpStr != \"\" {\n\t\t\t\tif reg == \"\" {\n\t\t\t\t\trr := \"\"\n\t\t\t\t\tfor _, w := range wildcards {\n\t\t\t\t\t\tif w == \":splat\" {\n\t\t\t\t\t\t\trr = rr + \"(.+)/\"\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trr = rr + \"([^/]+)/\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tregexpStr = rr + regexpStr\n\t\t\t\t} else {\n\t\t\t\t\tregexpStr = \"/\" + regexpStr\n\t\t\t\t}\n\t\t\t} else if reg != \"\" {\n\t\t\t\tif seg == \"*.*\" {\n\t\t\t\t\tregexpStr = \"/([^.]+).(.+)\"\n\t\t\t\t\tparams = params[1:]\n\t\t\t\t} else {\n\t\t\t\t\tfor range params {\n\t\t\t\t\t\tregexpStr = \"/([^/]+)\" + regexpStr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif seg == \"*.*\" {\n\t\t\t\t\tparams = params[1:]\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.wildcard.addseg(segments[1:], route, append(wildcards, params...), reg+regexpStr)//递归调用\n\t\t} else {\n\t\t\tvar subTree *Tree\n\t\t\tfor _, sub := range t.fixrouters {\n\t\t\t\tif sub.prefix == seg {\n\t\t\t\t\tsubTree = sub\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif subTree == nil {\n\t\t\t\tsubTree = NewTree()\n\t\t\t\tsubTree.prefix = seg\n\t\t\t\tt.fixrouters = append(t.fixrouters, subTree)\n\t\t\t}\n\t\t\tsubTree.addseg(segments[1:], route, wildcards, reg)//递归调用\n\t\t}\n\t}\n}\n```\n至此路由树节点添加完成  \n\n这里需要提一下 splitSegment这个函数\n位置: beego/tree.go:489\n```Go\n// \"admin\" -> false, nil, \"\"\n// \":id\" -> true, [:id], \"\"\n// \"?:id\" -> true, [: :id], \"\"        : meaning can empty\n// \":id:int\" -> true, [:id], ([0-9]+)\n// \":name:string\" -> true, [:name], ([\\w]+)\n// \":id([0-9]+)\" -> true, [:id], ([0-9]+)\n// \":id([0-9]+)_:name\" -> true, [:id :name], ([0-9]+)_(.+)\n// \"cms_:id_:page.html\" -> true, [:id_ :page], cms_(.+)(.+).html\n// \"cms_:id(.+)_:page.html\" -> true, [:id :page], cms_(.+)_(.+).html\n// \"*\" -> true, [:splat], \"\"\n// \"*.*\" -> true,[. :path :ext], \"\"      . meaning separator\n//正则路由,用于对正则的 Segment进行解析\n//当 key中包含正则 返回true，否则返回false\n//返回值第二个为不同的参数\n//第三个为正则的规则\nfunc splitSegment(key string) (bool, []string, string)\n```\n\n## Final\n最终我们从调用beego.Router()到最后给 ControllerRegister.router成功添加路由树节点的过程就完成了  \n总结一下就是注册路由的过程就是在添加 ControllerRegister中的路由树的节点,而在 HTTP执行的过程中对这棵树进行搜索(这就到树的搜索方法了),从而判断接受到的请求应该怎么样的处理(对应的根据 Controller不同的类型调用不同的方法)  \n完成 HTTP请求的正常处理过程:D\n\n\n如果文章有误,非常希望能给我提出,好让我更正 :D\n","source":"_posts/Beego源码解析-二-路由机制.md","raw":"---\ntitle: Beego源码解析(二)-路由机制\ndate: 2016-08-01 00:22:08\ntags:\n  - Beego Framework\n---\n\n>上一篇文章[Beego源码解析(一)-配置项初始化流程](https://riccoqu.github.io/2016/07/30/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E2%80%94%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/)介绍了 Beego关于配置项初始化的流程。那么今天就来说说在 Beego中非常重要的**路由机制**.  \nBeego到现在 v1.6.1版本为止支持了:**固定路由**、**正则路由**、**自动路由**这三种路由方法.  \n关于这三种路由的详细用法可以参考官方给出的[**开发文档**](),这里面已经记录的很全面了.  \n\n所以我们今天这篇文章就是要介绍这三种路由是如何在 Beego内部实现的.  \n\n<!--more-->\n\n关于 Beego的源码注释可以见我的[**Github**](https://github.com/riccoqu/Beego-Comments)\n\n## 一个简单的示例\n让我们先从官网给出的示例开始,下面是会在浏览器中打印\"HelloWorld\"的一个Beego程序.\n```Go\npackage main\n\nimport(\n\t\"github.com/astaxie/beego\"\n)\n\ntype MainController struct {\n\tbeego.Controller\n}\n\nfunc (this *MainController) Get() {\n\tthis.Ctx.WriteString(\"Hello World\")\n}\n\nfunc main() {\n\t\tbeego.Router(\"/\",&MainController{})\n\t\tbeego.Run()\n}\n```\n\n我们需要先知道它干了什么:\n1. 自定义了一个内含 beego.Controller(这个类型后面会讲到)控制器的 MainController\n2. 重写了 MainController的 Get()方法,熟悉 Go语言的应该知道这个方法来自 Controller\n3. 在 main()函数中调用了 beego.Router()方法注册了路由\"/\"和一个 MainController实例\n4. 执行了 beego.Run()方法启用了 beego程序\n\n## 重要的类型和接口\n为了不在接下来的流程中打断,在介绍流程之前需要先了解 beego中关于路由的一些东西\n\n### ControllerInterface 接口\n\n源文件中的位置: beego/controller.go:90\n```Go\ntype ControllerInterface interface {\n\t\tInit(ct *context.Context,controllerName,actionName string,app interface{})\n\t\tPrepare()\n\t\tGet()\n\t\tPost()\n\t\tDelete()\n\t\tPut()\n\t\tHead()\n\t\tPatch()\n\t\tOptions()\n\t\tFinish()\n\t\tRender() error\n\t\tXSRFToken() string\n\t\tCheckXSRFCookie() bool\n\t\tHandlerFunc(fn string) bool\n\t\tURLMapping()\n}\n```\n\n这个接口定义了 15个方法,看名字就能够知道这是每个 Controller都需要实现的接口\n\n### Controller结构体\n\n位置 beego/controller.go:60\n```Go\ntype Controller struct {\n\n//context data\nCtx  *context.Context\nData map[interface{}]interface{}\n\n//route controller info\ncontrollerName string\nactionName     string\nmethodMapping  map[string]func() //method:routertree\ngotofunc       string\nAppController  interface{}\n\n// template data\nTplName        string\nLayout         string\nLayoutSections map[string]string // the key is the section name and the value is the template name\nTplExt         string\nEnableRender   bool\n\n// xsrf data\n_xsrfToken string\nXSRFExpire int\nEnableXSRF bool\n\n// session\nCruSession session.Store\n}\n```\n\n这个结构体保存了作为 Controller的一些必要的信息,一些基础的字段看名字就比较好理解  \n在这里的 context.Context(Beego中的上下文,封装了 HTTP的输入和输出)和 Session.Store(用于存储 Session)在以后的文章中会再提到  \n\n在这个源文件中的后面部分都是对 Controller的一些方法实现,我们会注意到 Controller实现了 ControllerInterface的方法,但是在一些方法实现中却是用 Ctx成员向客户端进行错误输出(例如 Get()方法)。  \n因为就像例子中给的一样,当我们需要自己定义 Controller,并且使用 Get()函数来完成对客户端 Get请求的处理时,我们就需要自己实现处理逻辑,这样就**覆盖**了本身输出错误的方法.而对于我们没有实现的方法(比如例子中的 Post()方法)没有重写,则对于客户端的 Post请求就会输出错误了\n\n### ControllerRegister结构体\n这是一个非常关键的数据结构,为什么说他关键呢?我们可以先看下 Beego中 App结构体的定义\n位置: beego/app.go\n```Go\ntype App struct {\n\tHandlers *ControllerRegister\n\tServer *http.Server\n}\n```\n\n关于 App需要说下,在程序中 App类型的变量**BeeApp**(beego/app.go:32)在 init()函数中会调用 NewApp()创建出唯一的一个Beego程序实例  \n可以看到在例子中 main()函数最后调用了 beego.Run()函数,这个函数会在设置完hooks(关于回调方法以后也会介绍)后进入 BeeApp.Run()函数并且在进入这个函数后就会根据配置项开始不同的　HTTP请求的处理(在 ControllerRegister实现的 ServeHTTP()方法中)\nApp中一共就两个变量,一个**Server**(标准包中 http.Server类型,这个不做介绍,需要的可以看 Go语言文档).  \n另外一个就是 **ControllerRegister**,这个 ControllerRegister顾名思义就是注册 Controller的管理器,那么如何管理的呢?接下来看定义\n\n位置: beego/router.go:115\n```Go\ntype ControllerRegister struct {\n\trouters map[string][]*Tree\n\tenableFilter bool\n\tfilters map[int][]*FilterRouter\n\tpool sync.Pool\n}\n```\n\n可以看到这篇文章的主角已经出现了, routers就是我们程序运行时所需要的路由表, routers的 key是我们注册的方法名(例如\"get\"、\"post\"等),而 value就是由注册的路由构建出来的路由树了(关于路由树,后面也会讲到).\n\n### ControllerInfo结构体\n这个结构体是用来保存我们自定义的控制器信息的,看下定义便知道  \n位置: beego/router.go:104\n```Go\ntype ControllerInfo struct {\n\tpattern string\t//模式\n\tcontrollerType reflect.Type//类型\n\tmethods map[string]string//支持的方法\n\thandler http.Handler//http.Handler接口\n\trunFunction FilterFunc\n\trouterType int//路由类型\n}\n```\n\n### Tree结构体\n```Go\ntype Tree struct {\n\t//路由前缀\n\tprefix string\n\t//不带正则的路由\n\tfixrouters []*Tree\n\t//通配符,如果设置并且查找 fixrouters失败时会来查找 wildcard\n\twildcard *Tree\n\t//叶子节点,如果设置并且查找 wildcard失败后会查找 leaves,里面保存了一些正则的信息\n\tleaves []*leafInfo\n}\n```\n\n### leafInfo结构体\n```Go\ntype leafInfo struct {\n\twildcards []string//通配符\n\tregexps *regexp.Regexp//正则对象\n\trunObject interface{}//一般保存得到的 ControllerInfo对象,在处理请求时会返回该对象,并调用处理方法\n}\n```\n这两个结构体就会构成一颗用来查找路由的路由树,通过结构体的定义我们应该不难看出关于正则的部分都会存放在叶子节点中.所以这个路由树的大致样子也比较好理解\n\n## 路由的注册过程\n在前面的实例中可以看到需要注册自己的 Controller时使用的是 beego.Router()函数(在官方开发文档中的基础路由部分也可以使用 beego.Get()方法注册路由,不过内部与用 beego.Router()注册方法相比都会使用 addToRouter()函数,所以也是比较相似的)  \n\n看下 beego.Router的原型:\n```Go\nbeego/app.go:211\nfunc Router(rootpath string,c ControllerInterface,mappingMethods ...string *App) {\n\t\tBeeApp.Handlers.Add(rootpath,c,mappingMethods...)\n\t\treturn BeeApp\n}\n```\n\n看到第一个参数是需要注册路由,而第二个参数是我们自定义实现了 ControllerInterface接口的控制器,第三个就是自定义路由中方法和处理函数的映射关系  \n函数内部实际调用了 App.ControllerRegister的Add()方法来注册  \n接下来看看 Add()方法做了什么:  \n位置: beego/router.go:144\n```Go\nfunc (p *ControllerRegister) Add(pattern string, c ControllerInterface, mappingMethods ...string) {\n\treflectVal := reflect.ValueOf(c)\t//反射获得 value\n\tt := reflect.Indirect(reflectVal).Type()//反射获得 type\n\tmethods := make(map[string]string)\n\tif len(mappingMethods) > 0 {\n\t\tsemi := strings.Split(mappingMethods[0], \";\")//切分出每个以';'分隔的自定义方法和对应的函数\n\t\tfor _, v := range semi {\n\t\t\tcolon := strings.Split(v, \":\")//切分出以':'分隔的方法名和对应的函数,colon[1]为处理的函数名\n\t\t\tif len(colon) != 2 {\n\t\t\t\tpanic(\"method mapping format is invalid\")\n\t\t\t}\n\t\t\tcomma := strings.Split(colon[0], \",\")//切分出以','分隔的方法名, comma包含了当前需要注册的所有方法名\n\t\t\tfor _, m := range comma {\n\t\t\t\tif _, ok := HTTPMETHOD[strings.ToUpper(m)]; m == \"*\" || ok {\n\t\t\t\t\t//如果方法名为通配符'*'或者在支持的方法列表中.并使用反射包中的方法获得一个绑定对应函数的　Value类型\n\t\t\t\t\t//如果返回的值有效,就将当前方法加入到 methods中\n\t\t\t\t\tif val := reflectVal.MethodByName(colon[1]); val.IsValid() {\n\t\t\t\t\t\tmethods[strings.ToUpper(m)] = colon[1]\n\t\t\t\t\t} else {\n\t\t\t\t\t//不支持方法时报错\n\t\t\t\t\t\tpanic(\"'\" + colon[1] + \"' method doesn't exist in the controller \" + t.Name())\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\tpanic(v + \" is an invalid method mapping. Method doesn't exist \" + m)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//添加 ControllerInfo类型来保存此项路由规则\n\troute := &controllerInfo{}\n\troute.pattern = pattern\n\troute.methods = methods\n\troute.routerType = routerTypeBeego\n\troute.controllerType = t\n\t//当传入的方法名为空时,给当前模式加入所有支持的方法\n\tif len(methods) == 0 {\n\t\tfor _, m := range HTTPMETHOD {\n\t\t\tp.addToRouter(m, pattern, route)\n\t\t}\n\t} else {\n\t\t//方法名不为空时,判断是否含有通配符 \"*\"\n\t\tfor k := range methods {\n\t\t\tif k == \"*\" {\n\t\t\t\tfor _, m := range HTTPMETHOD {\n\t\t\t\t\t//含有通配符,加入所有方法\n\t\t\t\t\tp.addToRouter(m, pattern, route)\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t\t//只加入指定的方法\n\t\t\t\t\tp.addToRouter(k, pattern, route)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n这是一个稍微长点的函数,不过通过注释可以看出这个函数做了几个工作:\n1. 解析了传入的 mappingMethods,得到其中包含的全部方法\n2. 用传入的4个参数构造出一个 ControllerInfo的实例,而这个实例中就保存了我们自定的控制器的 reflct.Type类型(可参考[ControllerInfo](#ControllerInfo结构体))  \n\n在函数的最后调用了 ControllerRegister的 addToRouter()方法\n\n位置: beego/router.go:199\n```Go\nfunc (p *ControllerRegister) addToRouter(method, pattern string, r *controllerInfo) {\n\tif !BConfig.RouterCaseSensitive {\n\t\tpattern = strings.ToLower(pattern)\n\t}\n\tif t, ok := p.routers[method]; ok {\n\t\t//如果方法对应的路由树存在就直接添加\n\t\tt.AddRouter(pattern, r)\n\t} else {\n\t\t//方法不存在这新创建一个路由树\n\t\tt := NewTree()\n\t\tt.AddRouter(pattern, r)\n\t\t//设定新方法的路由树\n\t\tp.routers[method] = t\n\t}\n}\n```\n这个方法比较短,主要是判断当前的方法是否在 ControllerRegister的成员 routers所支持的方法中  \n* 存在就直接插入对应的路由树  \n* 否则创建一个新的路由树  \n\n路由树节点的插入操作就是 Tree.AddRouter()方法\n\n位置: beego/tree.go:206\n```Go\nfunc (t *Tree) AddRouter(pattern string,runObject interface{}) {\n\tt.addseg(splitPath(pattern),runObject,nil,\"\")\n}\n```\n可以看出它只是把 pattern中的路径进行了切割(例如\"/admin/users\"切割成\"[\"admin\",\"users\"]\"),并返回一个 string类型的数组切片  \n那么接下来的目的就很明确了,我们需要使用 Tree提供的 addseg方法给路由树**添加节点**\n\n这个函数也是最终的一个函数了,函数的逻辑可以看注释\n\n```Go\nfunc (t *Tree) addseg(segments []string, route interface{}, wildcards []string, reg string) {\n\tif len(segments) == 0 {\n\t\tif reg != \"\" {\n\t\t\t//添加 leaves节点,并给 leaves添加正则规则\n\t\t\tt.leaves = append(t.leaves, &leafInfo{runObject: route, wildcards: wildcards, regexps: regexp.MustCompile(\"^\" + reg + \"$\")})\n\t\t} else {\n\t\t\tt.leaves = append(t.leaves, &leafInfo{runObject: route, wildcards: wildcards})\n\t\t}\n\t} else {\n\t\tseg := segments[0]\n\t\tiswild, params, regexpStr := splitSegment(seg)//splitSegment函数在后面介绍\n\t\t// if it's ? meaning can igone this, so add one more rule for it\n\t\tif len(params) > 0 && params[0] == \":\" {\n\t\t\t//当　params[0]为':'时,代表参数为空,开始解析下一个\n\t\t\tt.addseg(segments[1:], route, wildcards, reg)//递归调用\n\t\t\tparams = params[1:]\n\t\t}\n\t\t//Rule: /login/*/access match /login/2009/11/access\n\t\t//if already has *, and when loop the access, should as a regexpStr\n\t\t//全匹配方式,可参考　http://beego.me/docs/mvc/controller/router.md 的正则路由->全匹配方式\n\t\t// utils.InSlice()检查\":solat\"是否在wildcards中\n\t\tif !iswild && utils.InSlice(\":splat\", wildcards) {\n\t\t\t//如果使用了全匹配方式则继续使用正则解析\n\t\t\tiswild = true\n\t\t\tregexpStr = seg\n\t\t}\n\t\t//Rule: /user/:id/*\n\t\tif seg == \"*\" && len(wildcards) > 0 && reg == \"\" {\n\t\t\tregexpStr = \"(.+)\"\n\t\t}\n\t\t//包含有正则表达式　\n\t\tif iswild {\n\t\t\tif t.wildcard == nil {\n\t\t\t\tt.wildcard = NewTree()\n\t\t\t}\n\t\t\tif regexpStr != \"\" {\n\t\t\t\tif reg == \"\" {\n\t\t\t\t\trr := \"\"\n\t\t\t\t\tfor _, w := range wildcards {\n\t\t\t\t\t\tif w == \":splat\" {\n\t\t\t\t\t\t\trr = rr + \"(.+)/\"\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trr = rr + \"([^/]+)/\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tregexpStr = rr + regexpStr\n\t\t\t\t} else {\n\t\t\t\t\tregexpStr = \"/\" + regexpStr\n\t\t\t\t}\n\t\t\t} else if reg != \"\" {\n\t\t\t\tif seg == \"*.*\" {\n\t\t\t\t\tregexpStr = \"/([^.]+).(.+)\"\n\t\t\t\t\tparams = params[1:]\n\t\t\t\t} else {\n\t\t\t\t\tfor range params {\n\t\t\t\t\t\tregexpStr = \"/([^/]+)\" + regexpStr\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif seg == \"*.*\" {\n\t\t\t\t\tparams = params[1:]\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.wildcard.addseg(segments[1:], route, append(wildcards, params...), reg+regexpStr)//递归调用\n\t\t} else {\n\t\t\tvar subTree *Tree\n\t\t\tfor _, sub := range t.fixrouters {\n\t\t\t\tif sub.prefix == seg {\n\t\t\t\t\tsubTree = sub\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif subTree == nil {\n\t\t\t\tsubTree = NewTree()\n\t\t\t\tsubTree.prefix = seg\n\t\t\t\tt.fixrouters = append(t.fixrouters, subTree)\n\t\t\t}\n\t\t\tsubTree.addseg(segments[1:], route, wildcards, reg)//递归调用\n\t\t}\n\t}\n}\n```\n至此路由树节点添加完成  \n\n这里需要提一下 splitSegment这个函数\n位置: beego/tree.go:489\n```Go\n// \"admin\" -> false, nil, \"\"\n// \":id\" -> true, [:id], \"\"\n// \"?:id\" -> true, [: :id], \"\"        : meaning can empty\n// \":id:int\" -> true, [:id], ([0-9]+)\n// \":name:string\" -> true, [:name], ([\\w]+)\n// \":id([0-9]+)\" -> true, [:id], ([0-9]+)\n// \":id([0-9]+)_:name\" -> true, [:id :name], ([0-9]+)_(.+)\n// \"cms_:id_:page.html\" -> true, [:id_ :page], cms_(.+)(.+).html\n// \"cms_:id(.+)_:page.html\" -> true, [:id :page], cms_(.+)_(.+).html\n// \"*\" -> true, [:splat], \"\"\n// \"*.*\" -> true,[. :path :ext], \"\"      . meaning separator\n//正则路由,用于对正则的 Segment进行解析\n//当 key中包含正则 返回true，否则返回false\n//返回值第二个为不同的参数\n//第三个为正则的规则\nfunc splitSegment(key string) (bool, []string, string)\n```\n\n## Final\n最终我们从调用beego.Router()到最后给 ControllerRegister.router成功添加路由树节点的过程就完成了  \n总结一下就是注册路由的过程就是在添加 ControllerRegister中的路由树的节点,而在 HTTP执行的过程中对这棵树进行搜索(这就到树的搜索方法了),从而判断接受到的请求应该怎么样的处理(对应的根据 Controller不同的类型调用不同的方法)  \n完成 HTTP请求的正常处理过程:D\n\n\n如果文章有误,非常希望能给我提出,好让我更正 :D\n","slug":"Beego源码解析-二-路由机制","published":1,"updated":"2022-02-27T13:20:40.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl05d6hi100035emta1hy27as","content":"<blockquote>\n<p>上一篇文章<a href=\"https://riccoqu.github.io/2016/07/30/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E2%80%94%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/\">Beego源码解析(一)-配置项初始化流程</a>介绍了 Beego关于配置项初始化的流程。那么今天就来说说在 Beego中非常重要的<strong>路由机制</strong>.<br>Beego到现在 v1.6.1版本为止支持了:<strong>固定路由</strong>、<strong>正则路由</strong>、<strong>自动路由</strong>这三种路由方法.<br>关于这三种路由的详细用法可以参考官方给出的<a href=\"\"><strong>开发文档</strong></a>,这里面已经记录的很全面了.  </p>\n</blockquote>\n<p>所以我们今天这篇文章就是要介绍这三种路由是如何在 Beego内部实现的.  </p>\n<span id=\"more\"></span>\n\n<p>关于 Beego的源码注释可以见我的<a href=\"https://github.com/riccoqu/Beego-Comments\"><strong>Github</strong></a></p>\n<h2 id=\"一个简单的示例\"><a href=\"#一个简单的示例\" class=\"headerlink\" title=\"一个简单的示例\"></a>一个简单的示例</h2><p>让我们先从官网给出的示例开始,下面是会在浏览器中打印”HelloWorld”的一个Beego程序.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/astaxie/beego&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MainController <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbeego.Controller</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MainController)</span></span> Get() &#123;</span><br><span class=\"line\">\tthis.Ctx.WriteString(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tbeego.Router(<span class=\"string\">&quot;/&quot;</span>,&amp;MainController&#123;&#125;)</span><br><span class=\"line\">\t\tbeego.Run()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们需要先知道它干了什么:</p>\n<ol>\n<li>自定义了一个内含 beego.Controller(这个类型后面会讲到)控制器的 MainController</li>\n<li>重写了 MainController的 Get()方法,熟悉 Go语言的应该知道这个方法来自 Controller</li>\n<li>在 main()函数中调用了 beego.Router()方法注册了路由”&#x2F;“和一个 MainController实例</li>\n<li>执行了 beego.Run()方法启用了 beego程序</li>\n</ol>\n<h2 id=\"重要的类型和接口\"><a href=\"#重要的类型和接口\" class=\"headerlink\" title=\"重要的类型和接口\"></a>重要的类型和接口</h2><p>为了不在接下来的流程中打断,在介绍流程之前需要先了解 beego中关于路由的一些东西</p>\n<h3 id=\"ControllerInterface-接口\"><a href=\"#ControllerInterface-接口\" class=\"headerlink\" title=\"ControllerInterface 接口\"></a>ControllerInterface 接口</h3><p>源文件中的位置: beego&#x2F;controller.go:90</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ControllerInterface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t\tInit(ct *context.Context,controllerName,actionName <span class=\"type\">string</span>,app <span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\">\t\tPrepare()</span><br><span class=\"line\">\t\tGet()</span><br><span class=\"line\">\t\tPost()</span><br><span class=\"line\">\t\tDelete()</span><br><span class=\"line\">\t\tPut()</span><br><span class=\"line\">\t\tHead()</span><br><span class=\"line\">\t\tPatch()</span><br><span class=\"line\">\t\tOptions()</span><br><span class=\"line\">\t\tFinish()</span><br><span class=\"line\">\t\tRender() <span class=\"type\">error</span></span><br><span class=\"line\">\t\tXSRFToken() <span class=\"type\">string</span></span><br><span class=\"line\">\t\tCheckXSRFCookie() <span class=\"type\">bool</span></span><br><span class=\"line\">\t\tHandlerFunc(fn <span class=\"type\">string</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">\t\tURLMapping()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个接口定义了 15个方法,看名字就能够知道这是每个 Controller都需要实现的接口</p>\n<h3 id=\"Controller结构体\"><a href=\"#Controller结构体\" class=\"headerlink\" title=\"Controller结构体\"></a>Controller结构体</h3><p>位置 beego&#x2F;controller.go:60</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Controller <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//context data</span></span><br><span class=\"line\">Ctx  *context.Context</span><br><span class=\"line\">Data <span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//route controller info</span></span><br><span class=\"line\">controllerName <span class=\"type\">string</span></span><br><span class=\"line\">actionName     <span class=\"type\">string</span></span><br><span class=\"line\">methodMapping  <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"comment\">//method:routertree</span></span><br><span class=\"line\">gotofunc       <span class=\"type\">string</span></span><br><span class=\"line\">AppController  <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// template data</span></span><br><span class=\"line\">TplName        <span class=\"type\">string</span></span><br><span class=\"line\">Layout         <span class=\"type\">string</span></span><br><span class=\"line\">LayoutSections <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span> <span class=\"comment\">// the key is the section name and the value is the template name</span></span><br><span class=\"line\">TplExt         <span class=\"type\">string</span></span><br><span class=\"line\">EnableRender   <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// xsrf data</span></span><br><span class=\"line\">_xsrfToken <span class=\"type\">string</span></span><br><span class=\"line\">XSRFExpire <span class=\"type\">int</span></span><br><span class=\"line\">EnableXSRF <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// session</span></span><br><span class=\"line\">CruSession session.Store</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个结构体保存了作为 Controller的一些必要的信息,一些基础的字段看名字就比较好理解<br>在这里的 context.Context(Beego中的上下文,封装了 HTTP的输入和输出)和 Session.Store(用于存储 Session)在以后的文章中会再提到  </p>\n<p>在这个源文件中的后面部分都是对 Controller的一些方法实现,我们会注意到 Controller实现了 ControllerInterface的方法,但是在一些方法实现中却是用 Ctx成员向客户端进行错误输出(例如 Get()方法)。<br>因为就像例子中给的一样,当我们需要自己定义 Controller,并且使用 Get()函数来完成对客户端 Get请求的处理时,我们就需要自己实现处理逻辑,这样就<strong>覆盖</strong>了本身输出错误的方法.而对于我们没有实现的方法(比如例子中的 Post()方法)没有重写,则对于客户端的 Post请求就会输出错误了</p>\n<h3 id=\"ControllerRegister结构体\"><a href=\"#ControllerRegister结构体\" class=\"headerlink\" title=\"ControllerRegister结构体\"></a>ControllerRegister结构体</h3><p>这是一个非常关键的数据结构,为什么说他关键呢?我们可以先看下 Beego中 App结构体的定义<br>位置: beego&#x2F;app.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> App <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tHandlers *ControllerRegister</span><br><span class=\"line\">\tServer *http.Server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于 App需要说下,在程序中 App类型的变量<strong>BeeApp</strong>(beego&#x2F;app.go:32)在 init()函数中会调用 NewApp()创建出唯一的一个Beego程序实例<br>可以看到在例子中 main()函数最后调用了 beego.Run()函数,这个函数会在设置完hooks(关于回调方法以后也会介绍)后进入 BeeApp.Run()函数并且在进入这个函数后就会根据配置项开始不同的　HTTP请求的处理(在 ControllerRegister实现的 ServeHTTP()方法中)<br>App中一共就两个变量,一个<strong>Server</strong>(标准包中 http.Server类型,这个不做介绍,需要的可以看 Go语言文档).<br>另外一个就是 <strong>ControllerRegister</strong>,这个 ControllerRegister顾名思义就是注册 Controller的管理器,那么如何管理的呢?接下来看定义</p>\n<p>位置: beego&#x2F;router.go:115</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ControllerRegister <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\trouters <span class=\"keyword\">map</span>[<span class=\"type\">string</span>][]*Tree</span><br><span class=\"line\">\tenableFilter <span class=\"type\">bool</span></span><br><span class=\"line\">\tfilters <span class=\"keyword\">map</span>[<span class=\"type\">int</span>][]*FilterRouter</span><br><span class=\"line\">\tpool sync.Pool</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这篇文章的主角已经出现了, routers就是我们程序运行时所需要的路由表, routers的 key是我们注册的方法名(例如”get”、”post”等),而 value就是由注册的路由构建出来的路由树了(关于路由树,后面也会讲到).</p>\n<h3 id=\"ControllerInfo结构体\"><a href=\"#ControllerInfo结构体\" class=\"headerlink\" title=\"ControllerInfo结构体\"></a>ControllerInfo结构体</h3><p>这个结构体是用来保存我们自定义的控制器信息的,看下定义便知道<br>位置: beego&#x2F;router.go:104</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ControllerInfo <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tpattern <span class=\"type\">string</span>\t<span class=\"comment\">//模式</span></span><br><span class=\"line\">\tcontrollerType reflect.Type<span class=\"comment\">//类型</span></span><br><span class=\"line\">\tmethods <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span><span class=\"comment\">//支持的方法</span></span><br><span class=\"line\">\thandler http.Handler<span class=\"comment\">//http.Handler接口</span></span><br><span class=\"line\">\trunFunction FilterFunc</span><br><span class=\"line\">\trouterType <span class=\"type\">int</span><span class=\"comment\">//路由类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Tree结构体\"><a href=\"#Tree结构体\" class=\"headerlink\" title=\"Tree结构体\"></a>Tree结构体</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Tree <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//路由前缀</span></span><br><span class=\"line\">\tprefix <span class=\"type\">string</span></span><br><span class=\"line\">\t<span class=\"comment\">//不带正则的路由</span></span><br><span class=\"line\">\tfixrouters []*Tree</span><br><span class=\"line\">\t<span class=\"comment\">//通配符,如果设置并且查找 fixrouters失败时会来查找 wildcard</span></span><br><span class=\"line\">\twildcard *Tree</span><br><span class=\"line\">\t<span class=\"comment\">//叶子节点,如果设置并且查找 wildcard失败后会查找 leaves,里面保存了一些正则的信息</span></span><br><span class=\"line\">\tleaves []*leafInfo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"leafInfo结构体\"><a href=\"#leafInfo结构体\" class=\"headerlink\" title=\"leafInfo结构体\"></a>leafInfo结构体</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> leafInfo <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\twildcards []<span class=\"type\">string</span><span class=\"comment\">//通配符</span></span><br><span class=\"line\">\tregexps *regexp.Regexp<span class=\"comment\">//正则对象</span></span><br><span class=\"line\">\trunObject <span class=\"keyword\">interface</span>&#123;&#125;<span class=\"comment\">//一般保存得到的 ControllerInfo对象,在处理请求时会返回该对象,并调用处理方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两个结构体就会构成一颗用来查找路由的路由树,通过结构体的定义我们应该不难看出关于正则的部分都会存放在叶子节点中.所以这个路由树的大致样子也比较好理解</p>\n<h2 id=\"路由的注册过程\"><a href=\"#路由的注册过程\" class=\"headerlink\" title=\"路由的注册过程\"></a>路由的注册过程</h2><p>在前面的实例中可以看到需要注册自己的 Controller时使用的是 beego.Router()函数(在官方开发文档中的基础路由部分也可以使用 beego.Get()方法注册路由,不过内部与用 beego.Router()注册方法相比都会使用 addToRouter()函数,所以也是比较相似的)  </p>\n<p>看下 beego.Router的原型:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beego/app.<span class=\"keyword\">go</span>:<span class=\"number\">211</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Router</span><span class=\"params\">(rootpath <span class=\"type\">string</span>,c ControllerInterface,mappingMethods ...<span class=\"type\">string</span> *App)</span></span> &#123;</span><br><span class=\"line\">\t\tBeeApp.Handlers.Add(rootpath,c,mappingMethods...)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BeeApp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到第一个参数是需要注册路由,而第二个参数是我们自定义实现了 ControllerInterface接口的控制器,第三个就是自定义路由中方法和处理函数的映射关系<br>函数内部实际调用了 App.ControllerRegister的Add()方法来注册<br>接下来看看 Add()方法做了什么:<br>位置: beego&#x2F;router.go:144</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *ControllerRegister)</span></span> Add(pattern <span class=\"type\">string</span>, c ControllerInterface, mappingMethods ...<span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\treflectVal := reflect.ValueOf(c)\t<span class=\"comment\">//反射获得 value</span></span><br><span class=\"line\">\tt := reflect.Indirect(reflectVal).Type()<span class=\"comment\">//反射获得 type</span></span><br><span class=\"line\">\tmethods := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(mappingMethods) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tsemi := strings.Split(mappingMethods[<span class=\"number\">0</span>], <span class=\"string\">&quot;;&quot;</span>)<span class=\"comment\">//切分出每个以&#x27;;&#x27;分隔的自定义方法和对应的函数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> semi &#123;</span><br><span class=\"line\">\t\t\tcolon := strings.Split(v, <span class=\"string\">&quot;:&quot;</span>)<span class=\"comment\">//切分出以&#x27;:&#x27;分隔的方法名和对应的函数,colon[1]为处理的函数名</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(colon) != <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;method mapping format is invalid&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcomma := strings.Split(colon[<span class=\"number\">0</span>], <span class=\"string\">&quot;,&quot;</span>)<span class=\"comment\">//切分出以&#x27;,&#x27;分隔的方法名, comma包含了当前需要注册的所有方法名</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, m := <span class=\"keyword\">range</span> comma &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> _, ok := HTTPMETHOD[strings.ToUpper(m)]; m == <span class=\"string\">&quot;*&quot;</span> || ok &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//如果方法名为通配符&#x27;*&#x27;或者在支持的方法列表中.并使用反射包中的方法获得一个绑定对应函数的　Value类型</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//如果返回的值有效,就将当前方法加入到 methods中</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> val := reflectVal.MethodByName(colon[<span class=\"number\">1</span>]); val.IsValid() &#123;</span><br><span class=\"line\">\t\t\t\t\t\tmethods[strings.ToUpper(m)] = colon[<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//不支持方法时报错</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;&#x27;&quot;</span> + colon[<span class=\"number\">1</span>] + <span class=\"string\">&quot;&#x27; method doesn&#x27;t exist in the controller &quot;</span> + t.Name())</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">panic</span>(v + <span class=\"string\">&quot; is an invalid method mapping. Method doesn&#x27;t exist &quot;</span> + m)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//添加 ControllerInfo类型来保存此项路由规则</span></span><br><span class=\"line\">\troute := &amp;controllerInfo&#123;&#125;</span><br><span class=\"line\">\troute.pattern = pattern</span><br><span class=\"line\">\troute.methods = methods</span><br><span class=\"line\">\troute.routerType = routerTypeBeego</span><br><span class=\"line\">\troute.controllerType = t</span><br><span class=\"line\">\t<span class=\"comment\">//当传入的方法名为空时,给当前模式加入所有支持的方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(methods) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, m := <span class=\"keyword\">range</span> HTTPMETHOD &#123;</span><br><span class=\"line\">\t\t\tp.addToRouter(m, pattern, route)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//方法名不为空时,判断是否含有通配符 &quot;*&quot;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> k := <span class=\"keyword\">range</span> methods &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> k == <span class=\"string\">&quot;*&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> _, m := <span class=\"keyword\">range</span> HTTPMETHOD &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//含有通配符,加入所有方法</span></span><br><span class=\"line\">\t\t\t\t\tp.addToRouter(m, pattern, route)</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//只加入指定的方法</span></span><br><span class=\"line\">\t\t\t\t\tp.addToRouter(k, pattern, route)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个稍微长点的函数,不过通过注释可以看出这个函数做了几个工作:</p>\n<ol>\n<li>解析了传入的 mappingMethods,得到其中包含的全部方法</li>\n<li>用传入的4个参数构造出一个 ControllerInfo的实例,而这个实例中就保存了我们自定的控制器的 reflct.Type类型(可参考<a href=\"#ControllerInfo%E7%BB%93%E6%9E%84%E4%BD%93\">ControllerInfo</a>)</li>\n</ol>\n<p>在函数的最后调用了 ControllerRegister的 addToRouter()方法</p>\n<p>位置: beego&#x2F;router.go:199</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *ControllerRegister)</span></span> addToRouter(method, pattern <span class=\"type\">string</span>, r *controllerInfo) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !BConfig.RouterCaseSensitive &#123;</span><br><span class=\"line\">\t\tpattern = strings.ToLower(pattern)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t, ok := p.routers[method]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果方法对应的路由树存在就直接添加</span></span><br><span class=\"line\">\t\tt.AddRouter(pattern, r)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//方法不存在这新创建一个路由树</span></span><br><span class=\"line\">\t\tt := NewTree()</span><br><span class=\"line\">\t\tt.AddRouter(pattern, r)</span><br><span class=\"line\">\t\t<span class=\"comment\">//设定新方法的路由树</span></span><br><span class=\"line\">\t\tp.routers[method] = t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法比较短,主要是判断当前的方法是否在 ControllerRegister的成员 routers所支持的方法中  </p>\n<ul>\n<li>存在就直接插入对应的路由树  </li>\n<li>否则创建一个新的路由树</li>\n</ul>\n<p>路由树节点的插入操作就是 Tree.AddRouter()方法</p>\n<p>位置: beego&#x2F;tree.go:206</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tree)</span></span> AddRouter(pattern <span class=\"type\">string</span>,runObject <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\tt.addseg(splitPath(pattern),runObject,<span class=\"literal\">nil</span>,<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出它只是把 pattern中的路径进行了切割(例如”&#x2F;admin&#x2F;users”切割成”[“admin”,”users”]”),并返回一个 string类型的数组切片<br>那么接下来的目的就很明确了,我们需要使用 Tree提供的 addseg方法给路由树<strong>添加节点</strong></p>\n<p>这个函数也是最终的一个函数了,函数的逻辑可以看注释</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tree)</span></span> addseg(segments []<span class=\"type\">string</span>, route <span class=\"keyword\">interface</span>&#123;&#125;, wildcards []<span class=\"type\">string</span>, reg <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(segments) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> reg != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//添加 leaves节点,并给 leaves添加正则规则</span></span><br><span class=\"line\">\t\t\tt.leaves = <span class=\"built_in\">append</span>(t.leaves, &amp;leafInfo&#123;runObject: route, wildcards: wildcards, regexps: regexp.MustCompile(<span class=\"string\">&quot;^&quot;</span> + reg + <span class=\"string\">&quot;$&quot;</span>)&#125;)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tt.leaves = <span class=\"built_in\">append</span>(t.leaves, &amp;leafInfo&#123;runObject: route, wildcards: wildcards&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tseg := segments[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tiswild, params, regexpStr := splitSegment(seg)<span class=\"comment\">//splitSegment函数在后面介绍</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// if it&#x27;s ? meaning can igone this, so add one more rule for it</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(params) &gt; <span class=\"number\">0</span> &amp;&amp; params[<span class=\"number\">0</span>] == <span class=\"string\">&quot;:&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//当　params[0]为&#x27;:&#x27;时,代表参数为空,开始解析下一个</span></span><br><span class=\"line\">\t\t\tt.addseg(segments[<span class=\"number\">1</span>:], route, wildcards, reg)<span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t\t\tparams = params[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Rule: /login/*/access match /login/2009/11/access</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//if already has *, and when loop the access, should as a regexpStr</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//全匹配方式,可参考　http://beego.me/docs/mvc/controller/router.md 的正则路由-&gt;全匹配方式</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// utils.InSlice()检查&quot;:solat&quot;是否在wildcards中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !iswild &amp;&amp; utils.InSlice(<span class=\"string\">&quot;:splat&quot;</span>, wildcards) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果使用了全匹配方式则继续使用正则解析</span></span><br><span class=\"line\">\t\t\tiswild = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\tregexpStr = seg</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Rule: /user/:id/*</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> seg == <span class=\"string\">&quot;*&quot;</span> &amp;&amp; <span class=\"built_in\">len</span>(wildcards) &gt; <span class=\"number\">0</span> &amp;&amp; reg == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tregexpStr = <span class=\"string\">&quot;(.+)&quot;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//包含有正则表达式　</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> iswild &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> t.wildcard == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tt.wildcard = NewTree()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> regexpStr != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> reg == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t\trr := <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> wildcards &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> w == <span class=\"string\">&quot;:splat&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\trr = rr + <span class=\"string\">&quot;(.+)/&quot;</span></span><br><span class=\"line\">\t\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\trr = rr + <span class=\"string\">&quot;([^/]+)/&quot;</span></span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tregexpStr = rr + regexpStr</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tregexpStr = <span class=\"string\">&quot;/&quot;</span> + regexpStr</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> reg != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> seg == <span class=\"string\">&quot;*.*&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tregexpStr = <span class=\"string\">&quot;/([^.]+).(.+)&quot;</span></span><br><span class=\"line\">\t\t\t\t\tparams = params[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> <span class=\"keyword\">range</span> params &#123;</span><br><span class=\"line\">\t\t\t\t\t\tregexpStr = <span class=\"string\">&quot;/([^/]+)&quot;</span> + regexpStr</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> seg == <span class=\"string\">&quot;*.*&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tparams = params[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tt.wildcard.addseg(segments[<span class=\"number\">1</span>:], route, <span class=\"built_in\">append</span>(wildcards, params...), reg+regexpStr)<span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> subTree *Tree</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, sub := <span class=\"keyword\">range</span> t.fixrouters &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> sub.prefix == seg &#123;</span><br><span class=\"line\">\t\t\t\t\tsubTree = sub</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> subTree == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tsubTree = NewTree()</span><br><span class=\"line\">\t\t\t\tsubTree.prefix = seg</span><br><span class=\"line\">\t\t\t\tt.fixrouters = <span class=\"built_in\">append</span>(t.fixrouters, subTree)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tsubTree.addseg(segments[<span class=\"number\">1</span>:], route, wildcards, reg)<span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此路由树节点添加完成  </p>\n<p>这里需要提一下 splitSegment这个函数<br>位置: beego&#x2F;tree.go:489</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &quot;admin&quot; -&gt; false, nil, &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;:id&quot; -&gt; true, [:id], &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;?:id&quot; -&gt; true, [: :id], &quot;&quot;        : meaning can empty</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;:id:int&quot; -&gt; true, [:id], ([0-9]+)</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;:name:string&quot; -&gt; true, [:name], ([\\w]+)</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;:id([0-9]+)&quot; -&gt; true, [:id], ([0-9]+)</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;:id([0-9]+)_:name&quot; -&gt; true, [:id :name], ([0-9]+)_(.+)</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;cms_:id_:page.html&quot; -&gt; true, [:id_ :page], cms_(.+)(.+).html</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;cms_:id(.+)_:page.html&quot; -&gt; true, [:id :page], cms_(.+)_(.+).html</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;*&quot; -&gt; true, [:splat], &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;*.*&quot; -&gt; true,[. :path :ext], &quot;&quot;      . meaning separator</span></span><br><span class=\"line\"><span class=\"comment\">//正则路由,用于对正则的 Segment进行解析</span></span><br><span class=\"line\"><span class=\"comment\">//当 key中包含正则 返回true，否则返回false</span></span><br><span class=\"line\"><span class=\"comment\">//返回值第二个为不同的参数</span></span><br><span class=\"line\"><span class=\"comment\">//第三个为正则的规则</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">splitSegment</span><span class=\"params\">(key <span class=\"type\">string</span>)</span></span> (<span class=\"type\">bool</span>, []<span class=\"type\">string</span>, <span class=\"type\">string</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Final\"><a href=\"#Final\" class=\"headerlink\" title=\"Final\"></a>Final</h2><p>最终我们从调用beego.Router()到最后给 ControllerRegister.router成功添加路由树节点的过程就完成了<br>总结一下就是注册路由的过程就是在添加 ControllerRegister中的路由树的节点,而在 HTTP执行的过程中对这棵树进行搜索(这就到树的搜索方法了),从而判断接受到的请求应该怎么样的处理(对应的根据 Controller不同的类型调用不同的方法)<br>完成 HTTP请求的正常处理过程:D</p>\n<p>如果文章有误,非常希望能给我提出,好让我更正 :D</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上一篇文章<a href=\"https://riccoqu.github.io/2016/07/30/Beego%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-%E2%80%94%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/\">Beego源码解析(一)-配置项初始化流程</a>介绍了 Beego关于配置项初始化的流程。那么今天就来说说在 Beego中非常重要的<strong>路由机制</strong>.<br>Beego到现在 v1.6.1版本为止支持了:<strong>固定路由</strong>、<strong>正则路由</strong>、<strong>自动路由</strong>这三种路由方法.<br>关于这三种路由的详细用法可以参考官方给出的<a href=\"\"><strong>开发文档</strong></a>,这里面已经记录的很全面了.  </p>\n</blockquote>\n<p>所以我们今天这篇文章就是要介绍这三种路由是如何在 Beego内部实现的.  </p>","more":"<p>关于 Beego的源码注释可以见我的<a href=\"https://github.com/riccoqu/Beego-Comments\"><strong>Github</strong></a></p>\n<h2 id=\"一个简单的示例\"><a href=\"#一个简单的示例\" class=\"headerlink\" title=\"一个简单的示例\"></a>一个简单的示例</h2><p>让我们先从官网给出的示例开始,下面是会在浏览器中打印”HelloWorld”的一个Beego程序.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/astaxie/beego&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MainController <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbeego.Controller</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MainController)</span></span> Get() &#123;</span><br><span class=\"line\">\tthis.Ctx.WriteString(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tbeego.Router(<span class=\"string\">&quot;/&quot;</span>,&amp;MainController&#123;&#125;)</span><br><span class=\"line\">\t\tbeego.Run()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们需要先知道它干了什么:</p>\n<ol>\n<li>自定义了一个内含 beego.Controller(这个类型后面会讲到)控制器的 MainController</li>\n<li>重写了 MainController的 Get()方法,熟悉 Go语言的应该知道这个方法来自 Controller</li>\n<li>在 main()函数中调用了 beego.Router()方法注册了路由”&#x2F;“和一个 MainController实例</li>\n<li>执行了 beego.Run()方法启用了 beego程序</li>\n</ol>\n<h2 id=\"重要的类型和接口\"><a href=\"#重要的类型和接口\" class=\"headerlink\" title=\"重要的类型和接口\"></a>重要的类型和接口</h2><p>为了不在接下来的流程中打断,在介绍流程之前需要先了解 beego中关于路由的一些东西</p>\n<h3 id=\"ControllerInterface-接口\"><a href=\"#ControllerInterface-接口\" class=\"headerlink\" title=\"ControllerInterface 接口\"></a>ControllerInterface 接口</h3><p>源文件中的位置: beego&#x2F;controller.go:90</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ControllerInterface <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\t\tInit(ct *context.Context,controllerName,actionName <span class=\"type\">string</span>,app <span class=\"keyword\">interface</span>&#123;&#125;)</span><br><span class=\"line\">\t\tPrepare()</span><br><span class=\"line\">\t\tGet()</span><br><span class=\"line\">\t\tPost()</span><br><span class=\"line\">\t\tDelete()</span><br><span class=\"line\">\t\tPut()</span><br><span class=\"line\">\t\tHead()</span><br><span class=\"line\">\t\tPatch()</span><br><span class=\"line\">\t\tOptions()</span><br><span class=\"line\">\t\tFinish()</span><br><span class=\"line\">\t\tRender() <span class=\"type\">error</span></span><br><span class=\"line\">\t\tXSRFToken() <span class=\"type\">string</span></span><br><span class=\"line\">\t\tCheckXSRFCookie() <span class=\"type\">bool</span></span><br><span class=\"line\">\t\tHandlerFunc(fn <span class=\"type\">string</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">\t\tURLMapping()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个接口定义了 15个方法,看名字就能够知道这是每个 Controller都需要实现的接口</p>\n<h3 id=\"Controller结构体\"><a href=\"#Controller结构体\" class=\"headerlink\" title=\"Controller结构体\"></a>Controller结构体</h3><p>位置 beego&#x2F;controller.go:60</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Controller <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//context data</span></span><br><span class=\"line\">Ctx  *context.Context</span><br><span class=\"line\">Data <span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//route controller info</span></span><br><span class=\"line\">controllerName <span class=\"type\">string</span></span><br><span class=\"line\">actionName     <span class=\"type\">string</span></span><br><span class=\"line\">methodMapping  <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> <span class=\"comment\">//method:routertree</span></span><br><span class=\"line\">gotofunc       <span class=\"type\">string</span></span><br><span class=\"line\">AppController  <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// template data</span></span><br><span class=\"line\">TplName        <span class=\"type\">string</span></span><br><span class=\"line\">Layout         <span class=\"type\">string</span></span><br><span class=\"line\">LayoutSections <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span> <span class=\"comment\">// the key is the section name and the value is the template name</span></span><br><span class=\"line\">TplExt         <span class=\"type\">string</span></span><br><span class=\"line\">EnableRender   <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// xsrf data</span></span><br><span class=\"line\">_xsrfToken <span class=\"type\">string</span></span><br><span class=\"line\">XSRFExpire <span class=\"type\">int</span></span><br><span class=\"line\">EnableXSRF <span class=\"type\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// session</span></span><br><span class=\"line\">CruSession session.Store</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个结构体保存了作为 Controller的一些必要的信息,一些基础的字段看名字就比较好理解<br>在这里的 context.Context(Beego中的上下文,封装了 HTTP的输入和输出)和 Session.Store(用于存储 Session)在以后的文章中会再提到  </p>\n<p>在这个源文件中的后面部分都是对 Controller的一些方法实现,我们会注意到 Controller实现了 ControllerInterface的方法,但是在一些方法实现中却是用 Ctx成员向客户端进行错误输出(例如 Get()方法)。<br>因为就像例子中给的一样,当我们需要自己定义 Controller,并且使用 Get()函数来完成对客户端 Get请求的处理时,我们就需要自己实现处理逻辑,这样就<strong>覆盖</strong>了本身输出错误的方法.而对于我们没有实现的方法(比如例子中的 Post()方法)没有重写,则对于客户端的 Post请求就会输出错误了</p>\n<h3 id=\"ControllerRegister结构体\"><a href=\"#ControllerRegister结构体\" class=\"headerlink\" title=\"ControllerRegister结构体\"></a>ControllerRegister结构体</h3><p>这是一个非常关键的数据结构,为什么说他关键呢?我们可以先看下 Beego中 App结构体的定义<br>位置: beego&#x2F;app.go</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> App <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tHandlers *ControllerRegister</span><br><span class=\"line\">\tServer *http.Server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于 App需要说下,在程序中 App类型的变量<strong>BeeApp</strong>(beego&#x2F;app.go:32)在 init()函数中会调用 NewApp()创建出唯一的一个Beego程序实例<br>可以看到在例子中 main()函数最后调用了 beego.Run()函数,这个函数会在设置完hooks(关于回调方法以后也会介绍)后进入 BeeApp.Run()函数并且在进入这个函数后就会根据配置项开始不同的　HTTP请求的处理(在 ControllerRegister实现的 ServeHTTP()方法中)<br>App中一共就两个变量,一个<strong>Server</strong>(标准包中 http.Server类型,这个不做介绍,需要的可以看 Go语言文档).<br>另外一个就是 <strong>ControllerRegister</strong>,这个 ControllerRegister顾名思义就是注册 Controller的管理器,那么如何管理的呢?接下来看定义</p>\n<p>位置: beego&#x2F;router.go:115</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ControllerRegister <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\trouters <span class=\"keyword\">map</span>[<span class=\"type\">string</span>][]*Tree</span><br><span class=\"line\">\tenableFilter <span class=\"type\">bool</span></span><br><span class=\"line\">\tfilters <span class=\"keyword\">map</span>[<span class=\"type\">int</span>][]*FilterRouter</span><br><span class=\"line\">\tpool sync.Pool</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这篇文章的主角已经出现了, routers就是我们程序运行时所需要的路由表, routers的 key是我们注册的方法名(例如”get”、”post”等),而 value就是由注册的路由构建出来的路由树了(关于路由树,后面也会讲到).</p>\n<h3 id=\"ControllerInfo结构体\"><a href=\"#ControllerInfo结构体\" class=\"headerlink\" title=\"ControllerInfo结构体\"></a>ControllerInfo结构体</h3><p>这个结构体是用来保存我们自定义的控制器信息的,看下定义便知道<br>位置: beego&#x2F;router.go:104</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ControllerInfo <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tpattern <span class=\"type\">string</span>\t<span class=\"comment\">//模式</span></span><br><span class=\"line\">\tcontrollerType reflect.Type<span class=\"comment\">//类型</span></span><br><span class=\"line\">\tmethods <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span><span class=\"comment\">//支持的方法</span></span><br><span class=\"line\">\thandler http.Handler<span class=\"comment\">//http.Handler接口</span></span><br><span class=\"line\">\trunFunction FilterFunc</span><br><span class=\"line\">\trouterType <span class=\"type\">int</span><span class=\"comment\">//路由类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Tree结构体\"><a href=\"#Tree结构体\" class=\"headerlink\" title=\"Tree结构体\"></a>Tree结构体</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Tree <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//路由前缀</span></span><br><span class=\"line\">\tprefix <span class=\"type\">string</span></span><br><span class=\"line\">\t<span class=\"comment\">//不带正则的路由</span></span><br><span class=\"line\">\tfixrouters []*Tree</span><br><span class=\"line\">\t<span class=\"comment\">//通配符,如果设置并且查找 fixrouters失败时会来查找 wildcard</span></span><br><span class=\"line\">\twildcard *Tree</span><br><span class=\"line\">\t<span class=\"comment\">//叶子节点,如果设置并且查找 wildcard失败后会查找 leaves,里面保存了一些正则的信息</span></span><br><span class=\"line\">\tleaves []*leafInfo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"leafInfo结构体\"><a href=\"#leafInfo结构体\" class=\"headerlink\" title=\"leafInfo结构体\"></a>leafInfo结构体</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> leafInfo <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\twildcards []<span class=\"type\">string</span><span class=\"comment\">//通配符</span></span><br><span class=\"line\">\tregexps *regexp.Regexp<span class=\"comment\">//正则对象</span></span><br><span class=\"line\">\trunObject <span class=\"keyword\">interface</span>&#123;&#125;<span class=\"comment\">//一般保存得到的 ControllerInfo对象,在处理请求时会返回该对象,并调用处理方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两个结构体就会构成一颗用来查找路由的路由树,通过结构体的定义我们应该不难看出关于正则的部分都会存放在叶子节点中.所以这个路由树的大致样子也比较好理解</p>\n<h2 id=\"路由的注册过程\"><a href=\"#路由的注册过程\" class=\"headerlink\" title=\"路由的注册过程\"></a>路由的注册过程</h2><p>在前面的实例中可以看到需要注册自己的 Controller时使用的是 beego.Router()函数(在官方开发文档中的基础路由部分也可以使用 beego.Get()方法注册路由,不过内部与用 beego.Router()注册方法相比都会使用 addToRouter()函数,所以也是比较相似的)  </p>\n<p>看下 beego.Router的原型:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beego/app.<span class=\"keyword\">go</span>:<span class=\"number\">211</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Router</span><span class=\"params\">(rootpath <span class=\"type\">string</span>,c ControllerInterface,mappingMethods ...<span class=\"type\">string</span> *App)</span></span> &#123;</span><br><span class=\"line\">\t\tBeeApp.Handlers.Add(rootpath,c,mappingMethods...)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> BeeApp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>看到第一个参数是需要注册路由,而第二个参数是我们自定义实现了 ControllerInterface接口的控制器,第三个就是自定义路由中方法和处理函数的映射关系<br>函数内部实际调用了 App.ControllerRegister的Add()方法来注册<br>接下来看看 Add()方法做了什么:<br>位置: beego&#x2F;router.go:144</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *ControllerRegister)</span></span> Add(pattern <span class=\"type\">string</span>, c ControllerInterface, mappingMethods ...<span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\treflectVal := reflect.ValueOf(c)\t<span class=\"comment\">//反射获得 value</span></span><br><span class=\"line\">\tt := reflect.Indirect(reflectVal).Type()<span class=\"comment\">//反射获得 type</span></span><br><span class=\"line\">\tmethods := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">string</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(mappingMethods) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tsemi := strings.Split(mappingMethods[<span class=\"number\">0</span>], <span class=\"string\">&quot;;&quot;</span>)<span class=\"comment\">//切分出每个以&#x27;;&#x27;分隔的自定义方法和对应的函数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> semi &#123;</span><br><span class=\"line\">\t\t\tcolon := strings.Split(v, <span class=\"string\">&quot;:&quot;</span>)<span class=\"comment\">//切分出以&#x27;:&#x27;分隔的方法名和对应的函数,colon[1]为处理的函数名</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(colon) != <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;method mapping format is invalid&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcomma := strings.Split(colon[<span class=\"number\">0</span>], <span class=\"string\">&quot;,&quot;</span>)<span class=\"comment\">//切分出以&#x27;,&#x27;分隔的方法名, comma包含了当前需要注册的所有方法名</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, m := <span class=\"keyword\">range</span> comma &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> _, ok := HTTPMETHOD[strings.ToUpper(m)]; m == <span class=\"string\">&quot;*&quot;</span> || ok &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//如果方法名为通配符&#x27;*&#x27;或者在支持的方法列表中.并使用反射包中的方法获得一个绑定对应函数的　Value类型</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//如果返回的值有效,就将当前方法加入到 methods中</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> val := reflectVal.MethodByName(colon[<span class=\"number\">1</span>]); val.IsValid() &#123;</span><br><span class=\"line\">\t\t\t\t\t\tmethods[strings.ToUpper(m)] = colon[<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//不支持方法时报错</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;&#x27;&quot;</span> + colon[<span class=\"number\">1</span>] + <span class=\"string\">&quot;&#x27; method doesn&#x27;t exist in the controller &quot;</span> + t.Name())</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"built_in\">panic</span>(v + <span class=\"string\">&quot; is an invalid method mapping. Method doesn&#x27;t exist &quot;</span> + m)</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//添加 ControllerInfo类型来保存此项路由规则</span></span><br><span class=\"line\">\troute := &amp;controllerInfo&#123;&#125;</span><br><span class=\"line\">\troute.pattern = pattern</span><br><span class=\"line\">\troute.methods = methods</span><br><span class=\"line\">\troute.routerType = routerTypeBeego</span><br><span class=\"line\">\troute.controllerType = t</span><br><span class=\"line\">\t<span class=\"comment\">//当传入的方法名为空时,给当前模式加入所有支持的方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(methods) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> _, m := <span class=\"keyword\">range</span> HTTPMETHOD &#123;</span><br><span class=\"line\">\t\t\tp.addToRouter(m, pattern, route)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//方法名不为空时,判断是否含有通配符 &quot;*&quot;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> k := <span class=\"keyword\">range</span> methods &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> k == <span class=\"string\">&quot;*&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> _, m := <span class=\"keyword\">range</span> HTTPMETHOD &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//含有通配符,加入所有方法</span></span><br><span class=\"line\">\t\t\t\t\tp.addToRouter(m, pattern, route)</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//只加入指定的方法</span></span><br><span class=\"line\">\t\t\t\t\tp.addToRouter(k, pattern, route)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个稍微长点的函数,不过通过注释可以看出这个函数做了几个工作:</p>\n<ol>\n<li>解析了传入的 mappingMethods,得到其中包含的全部方法</li>\n<li>用传入的4个参数构造出一个 ControllerInfo的实例,而这个实例中就保存了我们自定的控制器的 reflct.Type类型(可参考<a href=\"#ControllerInfo%E7%BB%93%E6%9E%84%E4%BD%93\">ControllerInfo</a>)</li>\n</ol>\n<p>在函数的最后调用了 ControllerRegister的 addToRouter()方法</p>\n<p>位置: beego&#x2F;router.go:199</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *ControllerRegister)</span></span> addToRouter(method, pattern <span class=\"type\">string</span>, r *controllerInfo) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !BConfig.RouterCaseSensitive &#123;</span><br><span class=\"line\">\t\tpattern = strings.ToLower(pattern)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t, ok := p.routers[method]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果方法对应的路由树存在就直接添加</span></span><br><span class=\"line\">\t\tt.AddRouter(pattern, r)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//方法不存在这新创建一个路由树</span></span><br><span class=\"line\">\t\tt := NewTree()</span><br><span class=\"line\">\t\tt.AddRouter(pattern, r)</span><br><span class=\"line\">\t\t<span class=\"comment\">//设定新方法的路由树</span></span><br><span class=\"line\">\t\tp.routers[method] = t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法比较短,主要是判断当前的方法是否在 ControllerRegister的成员 routers所支持的方法中  </p>\n<ul>\n<li>存在就直接插入对应的路由树  </li>\n<li>否则创建一个新的路由树</li>\n</ul>\n<p>路由树节点的插入操作就是 Tree.AddRouter()方法</p>\n<p>位置: beego&#x2F;tree.go:206</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tree)</span></span> AddRouter(pattern <span class=\"type\">string</span>,runObject <span class=\"keyword\">interface</span>&#123;&#125;) &#123;</span><br><span class=\"line\">\tt.addseg(splitPath(pattern),runObject,<span class=\"literal\">nil</span>,<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出它只是把 pattern中的路径进行了切割(例如”&#x2F;admin&#x2F;users”切割成”[“admin”,”users”]”),并返回一个 string类型的数组切片<br>那么接下来的目的就很明确了,我们需要使用 Tree提供的 addseg方法给路由树<strong>添加节点</strong></p>\n<p>这个函数也是最终的一个函数了,函数的逻辑可以看注释</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *Tree)</span></span> addseg(segments []<span class=\"type\">string</span>, route <span class=\"keyword\">interface</span>&#123;&#125;, wildcards []<span class=\"type\">string</span>, reg <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(segments) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> reg != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//添加 leaves节点,并给 leaves添加正则规则</span></span><br><span class=\"line\">\t\t\tt.leaves = <span class=\"built_in\">append</span>(t.leaves, &amp;leafInfo&#123;runObject: route, wildcards: wildcards, regexps: regexp.MustCompile(<span class=\"string\">&quot;^&quot;</span> + reg + <span class=\"string\">&quot;$&quot;</span>)&#125;)</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tt.leaves = <span class=\"built_in\">append</span>(t.leaves, &amp;leafInfo&#123;runObject: route, wildcards: wildcards&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tseg := segments[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\tiswild, params, regexpStr := splitSegment(seg)<span class=\"comment\">//splitSegment函数在后面介绍</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// if it&#x27;s ? meaning can igone this, so add one more rule for it</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(params) &gt; <span class=\"number\">0</span> &amp;&amp; params[<span class=\"number\">0</span>] == <span class=\"string\">&quot;:&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//当　params[0]为&#x27;:&#x27;时,代表参数为空,开始解析下一个</span></span><br><span class=\"line\">\t\t\tt.addseg(segments[<span class=\"number\">1</span>:], route, wildcards, reg)<span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t\t\tparams = params[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Rule: /login/*/access match /login/2009/11/access</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//if already has *, and when loop the access, should as a regexpStr</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//全匹配方式,可参考　http://beego.me/docs/mvc/controller/router.md 的正则路由-&gt;全匹配方式</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// utils.InSlice()检查&quot;:solat&quot;是否在wildcards中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> !iswild &amp;&amp; utils.InSlice(<span class=\"string\">&quot;:splat&quot;</span>, wildcards) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果使用了全匹配方式则继续使用正则解析</span></span><br><span class=\"line\">\t\t\tiswild = <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\tregexpStr = seg</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//Rule: /user/:id/*</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> seg == <span class=\"string\">&quot;*&quot;</span> &amp;&amp; <span class=\"built_in\">len</span>(wildcards) &gt; <span class=\"number\">0</span> &amp;&amp; reg == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tregexpStr = <span class=\"string\">&quot;(.+)&quot;</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//包含有正则表达式　</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> iswild &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> t.wildcard == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tt.wildcard = NewTree()</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> regexpStr != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> reg == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t\trr := <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> _, w := <span class=\"keyword\">range</span> wildcards &#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> w == <span class=\"string\">&quot;:splat&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\trr = rr + <span class=\"string\">&quot;(.+)/&quot;</span></span><br><span class=\"line\">\t\t\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\trr = rr + <span class=\"string\">&quot;([^/]+)/&quot;</span></span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tregexpStr = rr + regexpStr</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tregexpStr = <span class=\"string\">&quot;/&quot;</span> + regexpStr</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> reg != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> seg == <span class=\"string\">&quot;*.*&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tregexpStr = <span class=\"string\">&quot;/([^.]+).(.+)&quot;</span></span><br><span class=\"line\">\t\t\t\t\tparams = params[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> <span class=\"keyword\">range</span> params &#123;</span><br><span class=\"line\">\t\t\t\t\t\tregexpStr = <span class=\"string\">&quot;/([^/]+)&quot;</span> + regexpStr</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> seg == <span class=\"string\">&quot;*.*&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t\t\tparams = params[<span class=\"number\">1</span>:]</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tt.wildcard.addseg(segments[<span class=\"number\">1</span>:], route, <span class=\"built_in\">append</span>(wildcards, params...), reg+regexpStr)<span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">var</span> subTree *Tree</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> _, sub := <span class=\"keyword\">range</span> t.fixrouters &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> sub.prefix == seg &#123;</span><br><span class=\"line\">\t\t\t\t\tsubTree = sub</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> subTree == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tsubTree = NewTree()</span><br><span class=\"line\">\t\t\t\tsubTree.prefix = seg</span><br><span class=\"line\">\t\t\t\tt.fixrouters = <span class=\"built_in\">append</span>(t.fixrouters, subTree)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tsubTree.addseg(segments[<span class=\"number\">1</span>:], route, wildcards, reg)<span class=\"comment\">//递归调用</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此路由树节点添加完成  </p>\n<p>这里需要提一下 splitSegment这个函数<br>位置: beego&#x2F;tree.go:489</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &quot;admin&quot; -&gt; false, nil, &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;:id&quot; -&gt; true, [:id], &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;?:id&quot; -&gt; true, [: :id], &quot;&quot;        : meaning can empty</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;:id:int&quot; -&gt; true, [:id], ([0-9]+)</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;:name:string&quot; -&gt; true, [:name], ([\\w]+)</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;:id([0-9]+)&quot; -&gt; true, [:id], ([0-9]+)</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;:id([0-9]+)_:name&quot; -&gt; true, [:id :name], ([0-9]+)_(.+)</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;cms_:id_:page.html&quot; -&gt; true, [:id_ :page], cms_(.+)(.+).html</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;cms_:id(.+)_:page.html&quot; -&gt; true, [:id :page], cms_(.+)_(.+).html</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;*&quot; -&gt; true, [:splat], &quot;&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// &quot;*.*&quot; -&gt; true,[. :path :ext], &quot;&quot;      . meaning separator</span></span><br><span class=\"line\"><span class=\"comment\">//正则路由,用于对正则的 Segment进行解析</span></span><br><span class=\"line\"><span class=\"comment\">//当 key中包含正则 返回true，否则返回false</span></span><br><span class=\"line\"><span class=\"comment\">//返回值第二个为不同的参数</span></span><br><span class=\"line\"><span class=\"comment\">//第三个为正则的规则</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">splitSegment</span><span class=\"params\">(key <span class=\"type\">string</span>)</span></span> (<span class=\"type\">bool</span>, []<span class=\"type\">string</span>, <span class=\"type\">string</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Final\"><a href=\"#Final\" class=\"headerlink\" title=\"Final\"></a>Final</h2><p>最终我们从调用beego.Router()到最后给 ControllerRegister.router成功添加路由树节点的过程就完成了<br>总结一下就是注册路由的过程就是在添加 ControllerRegister中的路由树的节点,而在 HTTP执行的过程中对这棵树进行搜索(这就到树的搜索方法了),从而判断接受到的请求应该怎么样的处理(对应的根据 Controller不同的类型调用不同的方法)<br>完成 HTTP请求的正常处理过程:D</p>\n<p>如果文章有误,非常希望能给我提出,好让我更正 :D</p>"},{"title":"C++ 中的 static 关键字","date":"2019-02-22T16:00:00.000Z","_content":"> **static** 是 c++ 的关键字，顾名思义是表示静态的含义。它在 c++ 中既可以修饰变量也可以修饰函数。那当我们使用 static 时，编译器究竟做了哪些事情呢？\n\n早先被问到 static 关键字，感觉既熟悉又陌生。熟悉是都知道如何去使用它，陌生又来自不知道它究竟对我们程序做了什么。今天就来好好复习下这个关键字，本文的重点也在第三部分。\n<!--more-->\n------\n### 目录\n- <a href=\"#1\">1 先说说 **extern**</a>\n  - <a href=\"#1.1\">1.1 **extern** 用于修饰变量</a>\n  - <a href=\"#1.2\">1.2 **extern** 用于修饰函数</a>\n  - <a href=\"#1.3\">1.3 **extern** 用于指定编译类型</a>\n- <a href=\"#2\">2 再讲讲 **static**</a>\n  - <a href=\"#1.2\">2.1 **static** 用于修饰变量</a>\n  - <a href=\"#2.2\">2.2 **static** 用于修饰函数</a>\n- <a href=\"#3\">3 关于 **text**、**bss** 与 **data** 段</a>\n  - <a href=\"#3.1\">3.1 局部变量的编译</a>\n  - <a href=\"#3.2\">3.2 全局变量的编译</a>\n------\n先看一下示例代码:  \ntest1.cpp\n```C++\n#include <iostream>\nextern int a_int;\nextern void func2();\n\nstatic char c_array[10000];\n\nvoid func1() {\n  static int a_tmp = 0;\n  std::cout << a_tmp++ << std::endl;\n  return;\n}\n\nint main(int argc, char **argv) {\n  a_int = 1;\n\n  //静态局部变量示例\n  for (auto i = 0; i < 5; i++) {\n    func1();\n  }\n\n  //比较静态全局变量的地址示例\n  std::cout << static_cast<const void *>(c_array) << std::endl;\n  func2();\n  return 0;\n}\n```\ntest2.cpp\n```C++\n#include <iostream>\n\nint a_int;\nstatic char c_array[1000];\nvoid func2() {\n  std::cout << static_cast<const void *>(c_array) << std::endl;\n  return 0;\n}\n\n```\n### <a name=\"1\">1 先说说 **extern**</a>\n**extern 关键字用于告诉编译器，在其他的模块中寻找相应的定义**\n\n为什么 static 前要先说  extern 呢？因为他们就像相互对立的一对关键字，所以 extern 与 static 一起用时编译器会报错～\n#### <a name=\"1.1\">1.1 **extern** 用于修饰变量</a>\n以示例代码中的 a_int 变量为例，假设其他的变量和函数不存在\n我们先**将 extern 关键字去掉(test1.cpp:2)**，然后执行步骤:    \n1.  编译`g++ -c -o test1.o test1.cpp`  \n2.  查看符号`nm test1.o`  \n\n```\n00000000000000d0 S _a_int\n```\n可以看到 a_int 为一个未初始化的符号。说明符号在 test1.o 中已经被定义了。此时直接编译（`g++ -o test1 test1.cpp`）是不会报错的。\n\n然后我们再**将 extern 关键字加上(test1.cpp:2)**，并重复上面步骤观察符号  \n`nm test1.o`  \n会发现 test1.o 中没有该符号的定义。并且再编译会报错：\n```\nUndefined symbols for architecture x86_64:\n  \"_a_int\", referenced from:\n      _main in test1-ed3c01.o\nld: symbol(s) not found for architecture x86_64\n```\n很明显，链接器没有找到 a_int 的定义。此时只需要将 test2.o 加入再编译（g++ -o test test1.cpp test2.cpp）就可以啦\n`注：此时如果去掉 main 函数中对 a_int 变量的引用，也可以编译通过，毕竟 a_int 在程序中实际没有用到`\n#### <a name=\"1.2\">1.2 **extern** 用于修饰函数</a>\n以示例代码中的 func2（） 函数为例  \n因为在 main 函数中调用了 func2（），所以需要在 main 之前进行函数声明。  但此时的函数声明无论加不加 extern 其实**并无多少区别**  \n#### <a name=\"1.3\">1.3 **extern** 用于指定编译类型</a>\n因为 C++ 编译时会进行 [name mangling[wiki]](https://en.wikipedia.org/wiki/Name_mangling)，导致所看到的函数与实际编译后的符号差距很大。在某些情况下会导致链接时找不到符号的问题  \n此时可以使用\n```C\nextern \"C\"\n{\n  ...\n}\n```\n这样在范围内的代码都将按照 C 的格式进行编译\n### <a name=\"2\">2 再讲讲 **static**</a>\nstatic 关键字在我看来的作用是\n1.  能够改变变量的存储方式\n2.  能够改变变量与函数的访问范围\n\n#### <a name=\"2.1\">2.1 **static** 用于修饰变量</a>\n我们都知道当程序经过编译后：\n- 函数体内的局部变量会保存在栈中，局部变量随着函数的调用和返回进行构造与析构，并且在函数返回后无法使用。\n- 全局变量保存在静态数据区直到程序退出时才会被析构掉。所以在整个程序内全局变量都可以使用(当然要考虑到作用域)。  \n\n对于**局部变量**，当我们在变量前加上 **static** 时，就是告诉了编译器将该变量放入静态数据区。既函数退出时不会将该变量析构掉，当我们下次再调用改函数依然可以取得内存中的这个变量。  \n例如 test1.cpp 中，每次调用 func1() 时 a_tmp 变量都不会被销毁，最后输出\n```\n0\n1\n2\n3\n4\n```\n\n对于**全局变量**，加上 static 关键字后该变量只能用于当前的文件。\n例如 test1.cpp 中的 c_array，加上 static 后只能在当前源文件使用。  \n此时如果我们再在 test2.cpp 中定义一个同名的全局静态数组进行编译（`g++ -o test test1.cpp test2.cpp`）并且输出他们的地址  \n```\ntest1.cpp[c_array]0x10bb5e100\ntest2.cpp[c_array]0x10bb60810\n```\n可以看到两个地址是不同的，所以虽说是同名的两个全局变量。但都经过 static 修饰后，他们实际还是两个地址不同相互独立的变量。\n\n那么再试一下，将 test1.cpp 中的\n```C++\nstatic char c_array[10000];\n```\n修改为\n```C++\nextern char c_array[10000];\n```\n然后再编译(`g++ -o test test1.cpp test2.cpp`)可以看到\n```\nUndefined symbols for architecture x86_64:\n  \"_c_array\", referenced from:\n      _main in test1-5d6201.o\nld: symbol(s) not found for architecture x86_64\n```\n这当然是因为 test2.cpp 中的 c_array 还是有 static 进行修饰的，导致我们无法在 test1.cpp 文件中访问到。那就将 static 去掉，看到结果\n```\ntest1.cpp[c_array]0x10b1e2100\ntest2.cpp[c_array]0x10b1e2100\n```\n它们的地址相同对应的同一块内存，是同一个变量！\n\n#### <a name=\"2.2\">2.2 **static** 用于修饰函数</a>\nstatic 对于函数于变量其实比较类似，它限定了函数只能在当前的模块中使用。  \n假如我们将 test2.cpp 中的 func2() 函数加上 **static** 关键字，那么编译（`g++ -o test test1.cpp test2.cpp`）也会报错找不到符号\n```\nUndefined symbols for architecture x86_64:\n  \"func2()\", referenced from:\n      _main in test1-80a5c0.o\nld: symbol(s) not found for architecture x86_64\n```\n### <a name=\"3\">3 关于 **text**、**bss** 与 **data** 段</a>\n---\n关于数据段、编译、链接方面的知识非常推荐看看  \n[<<程序员的自我修养:链接、装载与库>>](https://www.amazon.cn/dp/B0027VSA7U/ref=sr_1_1?ie=UTF8&qid=1550913082&sr=8-1&keywords=程序员的自我修养)\n#### <a name=\"3.1\">3.1 局部变量的编译</a>\n是否曾经好奇函数内的临时变量经过编译会变成什么样子？  \n\n假设我们写了如下代码，并编译成名为 test 的可执行文件\n```C++\nint main() {\n  char s1[11] = \"helloworld\";\n  char s2[11] = \"helloworld\";\n  return 0;\n}\n```\n那么可以通过 `objdump -DS test `观察到 main 函数中有如下片段（有省略）\n```\nDisassembly of section .text:\n.....\n00000000004005b0 <main>:\n4005b4:\t48 b8 68 65 6c 6c 6f \tmovabs $0x726f776f6c6c6568,%rax\n4005bb:\t77 6f 72\n4005be:\t48 89 45 f0          \tmov    %rax,-0x10(%rbp)\n4005c2:\t66 c7 45 f8 6c 64    \tmovw   $0x646c,-0x8(%rbp)\n4005c8:\tc6 45 fa 00          \tmovb   $0x0,-0x6(%rbp)\n4005cc:\t48 b8 68 65 6c 6c 6f \tmovabs $0x726f776f6c6c6568,%rax\n4005d3:\t77 6f 72\n4005d6:\t48 89 45 e0          \tmov    %rax,-0x20(%rbp)\n4005da:\t66 c7 45 e8 6c 64    \tmovw   $0x646c,-0x18(%rbp)\n4005e0:\tc6 45 ea 00          \tmovb   $0x0,-0x16(%rbp)\n......\n```\n观察下 0x646c 和 0x726f776f6c6c6568，转化成 ascii 就是  \n`100 108 114 111 119 111 108 108 101 104`\n对应的字符  \n'd' 'l' 'r' 'o' 'w' 'o' 'l' 'l' 'e' 'h'，看出来了吧，编译器将 \"helloworld\" 以立即数的方式写到了 text 段内。\n然后通过 `readelf -a test`会发现并没有 s1 与 s2 的符号。\n\n现在将代码改为这样又会如何？\n```C++\nstatic char s1[11] = \"helloworld\";\nstatic char s2[11] = \"helloworld\";\n```\n继续通过 `objdump -DS test`观察发现 main 中发生了改变\n```\nDisassembly of section .text:\n00000000004005b0 <main>:\n  4005b0:\t55                   \tpush   %rbp\n  4005b1:\t48 89 e5             \tmov    %rsp,%rbp\n  4005b4:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4005b9:\t5d                   \tpop    %rbp\n  4005ba:\tc3                   \tretq\n  4005bb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n```\n通过 `readelf -a test`可以看到新增了两个地址不同的符号，由此可见 static 确实改变了变量的存储方式\n```\nSymbol table '.symtab' contains 66 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n   37: 000000000060102c    11 OBJECT  LOCAL  DEFAULT   24 _ZZ4mainE2s2\n   38: 0000000000601037    11 OBJECT  LOCAL  DEFAULT   24 _ZZ4mainE2s1\n```\n那么如果指向常量呢?稍微改下\n```C++\nconst char *s1 = \"helloworld\";\nconst char *s2 = \"helloworld\";\n```\n继续通过 objdump 观察到 main 中有这两代码，很明显了 0x400660存储着我们的 \"helloworld\"的字符串常量\n```\n00000000004005b0 <main>:\n  4005b4:\t48 c7 45 f8 60 06 40 \tmovq   $0x400660,-0x8(%rbp)\n  4005bb:\t00\n  4005bc:\t48 c7 45 f0 60 06 40 \tmovq   $0x400660,-0x10(%rbp)\n```\n找到这个地址，发现这个地址属于 **.rodata** 段。这就是我们常说用来保存字面值常量的数据段。\n```\nDisassembly of section .rodata:\n0000000000400658 <__dso_handle>:\n\t...\n  400660:\t68 65 6c 6c 6f       \tpushq  $0x6f6c6c65\n  400665:\t77 6f                \tja     4006d6 <__dso_handle+0x7e>\n  400667:\t72 6c                \tjb     4006d5 <__dso_handle+0x7d>\n  400669:\t64                   \tfs\n```\n观察下十六进制的值，就是我们的 \"helloworld\" 没错啦。\n#### <a name=\"3.2\">3.2 全局变量的编译</a>\n那么对于全局变量又应该是如何存储的呢？  \n首先我们知道无论静态还是非静态的变量都应该存储在静态数据区。我们熟悉的静态数据区就有 **.bss** 和 **.data**。  \n**.bss** 在编译时实际上不占据空间，只有在运行时才会由被分配空间。那么还是来验证下\n```C++\nchar a_array[10000];\nstatic char b_array[10000];\nint main() {\n  return 0;\n}\n```\n编译一下(`g++ -o test test.cpp`)，然后通过 size 命令观察(`size test`)\n```\ntext\t   data\t    bss\t    dec\t    hex\tfilename\n1320\t    588\t  20048\t  21956\t   55c4\ttest\n```\n可以看出 a_array 和 b_array 都实际记录在 **.bss** 段，并且 **.data**段的大小显然不符合我们定义的数组大小。通过 `ll test`会发现文件大小不足10000 字节，所以可以肯定的是申请的这两个数组在编译时并为被分配内存。\n\n那么继续改一下看看\n```C++\nchar a_array[10000] = \"helloworld\";\nstatic char b_array[10000];\n```\n继续使用 `size  test`看下\n```\ntext\t   data\t    bss\t    dec\t    hex\tfilename\n1320\t  10616\t  10032\t  21968\t   55d0\ttest\n```\ndata 段和文件都多出了 10000 多字节！！！  \n这就是因为 a_array 进行了初始化，所以编译器为其分配了内存。同理如果 b_array 也进行了初始化，那么大小还会增加。  \n**tips:**  \n**如果进行了初始化，但是内存中还是 0 值的话，编译器依旧不会为其分配内存的，例如\n`int a_array[10000] = {0};`**\n\n------\n对于能指出文中的错误不胜感激！ :D\n","source":"_posts/C++ 中的 static 关键字.md","raw":"---\ntitle: C++ 中的 static 关键字\ndate: 2019-02-23\ntags:\n - C++\n---\n> **static** 是 c++ 的关键字，顾名思义是表示静态的含义。它在 c++ 中既可以修饰变量也可以修饰函数。那当我们使用 static 时，编译器究竟做了哪些事情呢？\n\n早先被问到 static 关键字，感觉既熟悉又陌生。熟悉是都知道如何去使用它，陌生又来自不知道它究竟对我们程序做了什么。今天就来好好复习下这个关键字，本文的重点也在第三部分。\n<!--more-->\n------\n### 目录\n- <a href=\"#1\">1 先说说 **extern**</a>\n  - <a href=\"#1.1\">1.1 **extern** 用于修饰变量</a>\n  - <a href=\"#1.2\">1.2 **extern** 用于修饰函数</a>\n  - <a href=\"#1.3\">1.3 **extern** 用于指定编译类型</a>\n- <a href=\"#2\">2 再讲讲 **static**</a>\n  - <a href=\"#1.2\">2.1 **static** 用于修饰变量</a>\n  - <a href=\"#2.2\">2.2 **static** 用于修饰函数</a>\n- <a href=\"#3\">3 关于 **text**、**bss** 与 **data** 段</a>\n  - <a href=\"#3.1\">3.1 局部变量的编译</a>\n  - <a href=\"#3.2\">3.2 全局变量的编译</a>\n------\n先看一下示例代码:  \ntest1.cpp\n```C++\n#include <iostream>\nextern int a_int;\nextern void func2();\n\nstatic char c_array[10000];\n\nvoid func1() {\n  static int a_tmp = 0;\n  std::cout << a_tmp++ << std::endl;\n  return;\n}\n\nint main(int argc, char **argv) {\n  a_int = 1;\n\n  //静态局部变量示例\n  for (auto i = 0; i < 5; i++) {\n    func1();\n  }\n\n  //比较静态全局变量的地址示例\n  std::cout << static_cast<const void *>(c_array) << std::endl;\n  func2();\n  return 0;\n}\n```\ntest2.cpp\n```C++\n#include <iostream>\n\nint a_int;\nstatic char c_array[1000];\nvoid func2() {\n  std::cout << static_cast<const void *>(c_array) << std::endl;\n  return 0;\n}\n\n```\n### <a name=\"1\">1 先说说 **extern**</a>\n**extern 关键字用于告诉编译器，在其他的模块中寻找相应的定义**\n\n为什么 static 前要先说  extern 呢？因为他们就像相互对立的一对关键字，所以 extern 与 static 一起用时编译器会报错～\n#### <a name=\"1.1\">1.1 **extern** 用于修饰变量</a>\n以示例代码中的 a_int 变量为例，假设其他的变量和函数不存在\n我们先**将 extern 关键字去掉(test1.cpp:2)**，然后执行步骤:    \n1.  编译`g++ -c -o test1.o test1.cpp`  \n2.  查看符号`nm test1.o`  \n\n```\n00000000000000d0 S _a_int\n```\n可以看到 a_int 为一个未初始化的符号。说明符号在 test1.o 中已经被定义了。此时直接编译（`g++ -o test1 test1.cpp`）是不会报错的。\n\n然后我们再**将 extern 关键字加上(test1.cpp:2)**，并重复上面步骤观察符号  \n`nm test1.o`  \n会发现 test1.o 中没有该符号的定义。并且再编译会报错：\n```\nUndefined symbols for architecture x86_64:\n  \"_a_int\", referenced from:\n      _main in test1-ed3c01.o\nld: symbol(s) not found for architecture x86_64\n```\n很明显，链接器没有找到 a_int 的定义。此时只需要将 test2.o 加入再编译（g++ -o test test1.cpp test2.cpp）就可以啦\n`注：此时如果去掉 main 函数中对 a_int 变量的引用，也可以编译通过，毕竟 a_int 在程序中实际没有用到`\n#### <a name=\"1.2\">1.2 **extern** 用于修饰函数</a>\n以示例代码中的 func2（） 函数为例  \n因为在 main 函数中调用了 func2（），所以需要在 main 之前进行函数声明。  但此时的函数声明无论加不加 extern 其实**并无多少区别**  \n#### <a name=\"1.3\">1.3 **extern** 用于指定编译类型</a>\n因为 C++ 编译时会进行 [name mangling[wiki]](https://en.wikipedia.org/wiki/Name_mangling)，导致所看到的函数与实际编译后的符号差距很大。在某些情况下会导致链接时找不到符号的问题  \n此时可以使用\n```C\nextern \"C\"\n{\n  ...\n}\n```\n这样在范围内的代码都将按照 C 的格式进行编译\n### <a name=\"2\">2 再讲讲 **static**</a>\nstatic 关键字在我看来的作用是\n1.  能够改变变量的存储方式\n2.  能够改变变量与函数的访问范围\n\n#### <a name=\"2.1\">2.1 **static** 用于修饰变量</a>\n我们都知道当程序经过编译后：\n- 函数体内的局部变量会保存在栈中，局部变量随着函数的调用和返回进行构造与析构，并且在函数返回后无法使用。\n- 全局变量保存在静态数据区直到程序退出时才会被析构掉。所以在整个程序内全局变量都可以使用(当然要考虑到作用域)。  \n\n对于**局部变量**，当我们在变量前加上 **static** 时，就是告诉了编译器将该变量放入静态数据区。既函数退出时不会将该变量析构掉，当我们下次再调用改函数依然可以取得内存中的这个变量。  \n例如 test1.cpp 中，每次调用 func1() 时 a_tmp 变量都不会被销毁，最后输出\n```\n0\n1\n2\n3\n4\n```\n\n对于**全局变量**，加上 static 关键字后该变量只能用于当前的文件。\n例如 test1.cpp 中的 c_array，加上 static 后只能在当前源文件使用。  \n此时如果我们再在 test2.cpp 中定义一个同名的全局静态数组进行编译（`g++ -o test test1.cpp test2.cpp`）并且输出他们的地址  \n```\ntest1.cpp[c_array]0x10bb5e100\ntest2.cpp[c_array]0x10bb60810\n```\n可以看到两个地址是不同的，所以虽说是同名的两个全局变量。但都经过 static 修饰后，他们实际还是两个地址不同相互独立的变量。\n\n那么再试一下，将 test1.cpp 中的\n```C++\nstatic char c_array[10000];\n```\n修改为\n```C++\nextern char c_array[10000];\n```\n然后再编译(`g++ -o test test1.cpp test2.cpp`)可以看到\n```\nUndefined symbols for architecture x86_64:\n  \"_c_array\", referenced from:\n      _main in test1-5d6201.o\nld: symbol(s) not found for architecture x86_64\n```\n这当然是因为 test2.cpp 中的 c_array 还是有 static 进行修饰的，导致我们无法在 test1.cpp 文件中访问到。那就将 static 去掉，看到结果\n```\ntest1.cpp[c_array]0x10b1e2100\ntest2.cpp[c_array]0x10b1e2100\n```\n它们的地址相同对应的同一块内存，是同一个变量！\n\n#### <a name=\"2.2\">2.2 **static** 用于修饰函数</a>\nstatic 对于函数于变量其实比较类似，它限定了函数只能在当前的模块中使用。  \n假如我们将 test2.cpp 中的 func2() 函数加上 **static** 关键字，那么编译（`g++ -o test test1.cpp test2.cpp`）也会报错找不到符号\n```\nUndefined symbols for architecture x86_64:\n  \"func2()\", referenced from:\n      _main in test1-80a5c0.o\nld: symbol(s) not found for architecture x86_64\n```\n### <a name=\"3\">3 关于 **text**、**bss** 与 **data** 段</a>\n---\n关于数据段、编译、链接方面的知识非常推荐看看  \n[<<程序员的自我修养:链接、装载与库>>](https://www.amazon.cn/dp/B0027VSA7U/ref=sr_1_1?ie=UTF8&qid=1550913082&sr=8-1&keywords=程序员的自我修养)\n#### <a name=\"3.1\">3.1 局部变量的编译</a>\n是否曾经好奇函数内的临时变量经过编译会变成什么样子？  \n\n假设我们写了如下代码，并编译成名为 test 的可执行文件\n```C++\nint main() {\n  char s1[11] = \"helloworld\";\n  char s2[11] = \"helloworld\";\n  return 0;\n}\n```\n那么可以通过 `objdump -DS test `观察到 main 函数中有如下片段（有省略）\n```\nDisassembly of section .text:\n.....\n00000000004005b0 <main>:\n4005b4:\t48 b8 68 65 6c 6c 6f \tmovabs $0x726f776f6c6c6568,%rax\n4005bb:\t77 6f 72\n4005be:\t48 89 45 f0          \tmov    %rax,-0x10(%rbp)\n4005c2:\t66 c7 45 f8 6c 64    \tmovw   $0x646c,-0x8(%rbp)\n4005c8:\tc6 45 fa 00          \tmovb   $0x0,-0x6(%rbp)\n4005cc:\t48 b8 68 65 6c 6c 6f \tmovabs $0x726f776f6c6c6568,%rax\n4005d3:\t77 6f 72\n4005d6:\t48 89 45 e0          \tmov    %rax,-0x20(%rbp)\n4005da:\t66 c7 45 e8 6c 64    \tmovw   $0x646c,-0x18(%rbp)\n4005e0:\tc6 45 ea 00          \tmovb   $0x0,-0x16(%rbp)\n......\n```\n观察下 0x646c 和 0x726f776f6c6c6568，转化成 ascii 就是  \n`100 108 114 111 119 111 108 108 101 104`\n对应的字符  \n'd' 'l' 'r' 'o' 'w' 'o' 'l' 'l' 'e' 'h'，看出来了吧，编译器将 \"helloworld\" 以立即数的方式写到了 text 段内。\n然后通过 `readelf -a test`会发现并没有 s1 与 s2 的符号。\n\n现在将代码改为这样又会如何？\n```C++\nstatic char s1[11] = \"helloworld\";\nstatic char s2[11] = \"helloworld\";\n```\n继续通过 `objdump -DS test`观察发现 main 中发生了改变\n```\nDisassembly of section .text:\n00000000004005b0 <main>:\n  4005b0:\t55                   \tpush   %rbp\n  4005b1:\t48 89 e5             \tmov    %rsp,%rbp\n  4005b4:\tb8 00 00 00 00       \tmov    $0x0,%eax\n  4005b9:\t5d                   \tpop    %rbp\n  4005ba:\tc3                   \tretq\n  4005bb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)\n```\n通过 `readelf -a test`可以看到新增了两个地址不同的符号，由此可见 static 确实改变了变量的存储方式\n```\nSymbol table '.symtab' contains 66 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n   37: 000000000060102c    11 OBJECT  LOCAL  DEFAULT   24 _ZZ4mainE2s2\n   38: 0000000000601037    11 OBJECT  LOCAL  DEFAULT   24 _ZZ4mainE2s1\n```\n那么如果指向常量呢?稍微改下\n```C++\nconst char *s1 = \"helloworld\";\nconst char *s2 = \"helloworld\";\n```\n继续通过 objdump 观察到 main 中有这两代码，很明显了 0x400660存储着我们的 \"helloworld\"的字符串常量\n```\n00000000004005b0 <main>:\n  4005b4:\t48 c7 45 f8 60 06 40 \tmovq   $0x400660,-0x8(%rbp)\n  4005bb:\t00\n  4005bc:\t48 c7 45 f0 60 06 40 \tmovq   $0x400660,-0x10(%rbp)\n```\n找到这个地址，发现这个地址属于 **.rodata** 段。这就是我们常说用来保存字面值常量的数据段。\n```\nDisassembly of section .rodata:\n0000000000400658 <__dso_handle>:\n\t...\n  400660:\t68 65 6c 6c 6f       \tpushq  $0x6f6c6c65\n  400665:\t77 6f                \tja     4006d6 <__dso_handle+0x7e>\n  400667:\t72 6c                \tjb     4006d5 <__dso_handle+0x7d>\n  400669:\t64                   \tfs\n```\n观察下十六进制的值，就是我们的 \"helloworld\" 没错啦。\n#### <a name=\"3.2\">3.2 全局变量的编译</a>\n那么对于全局变量又应该是如何存储的呢？  \n首先我们知道无论静态还是非静态的变量都应该存储在静态数据区。我们熟悉的静态数据区就有 **.bss** 和 **.data**。  \n**.bss** 在编译时实际上不占据空间，只有在运行时才会由被分配空间。那么还是来验证下\n```C++\nchar a_array[10000];\nstatic char b_array[10000];\nint main() {\n  return 0;\n}\n```\n编译一下(`g++ -o test test.cpp`)，然后通过 size 命令观察(`size test`)\n```\ntext\t   data\t    bss\t    dec\t    hex\tfilename\n1320\t    588\t  20048\t  21956\t   55c4\ttest\n```\n可以看出 a_array 和 b_array 都实际记录在 **.bss** 段，并且 **.data**段的大小显然不符合我们定义的数组大小。通过 `ll test`会发现文件大小不足10000 字节，所以可以肯定的是申请的这两个数组在编译时并为被分配内存。\n\n那么继续改一下看看\n```C++\nchar a_array[10000] = \"helloworld\";\nstatic char b_array[10000];\n```\n继续使用 `size  test`看下\n```\ntext\t   data\t    bss\t    dec\t    hex\tfilename\n1320\t  10616\t  10032\t  21968\t   55d0\ttest\n```\ndata 段和文件都多出了 10000 多字节！！！  \n这就是因为 a_array 进行了初始化，所以编译器为其分配了内存。同理如果 b_array 也进行了初始化，那么大小还会增加。  \n**tips:**  \n**如果进行了初始化，但是内存中还是 0 值的话，编译器依旧不会为其分配内存的，例如\n`int a_array[10000] = {0};`**\n\n------\n对于能指出文中的错误不胜感激！ :D\n","slug":"C++ 中的 static 关键字","published":1,"updated":"2022-02-27T14:12:17.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl05d6hi200045emt5x673j1z","content":"<blockquote>\n<p><strong>static</strong> 是 c++ 的关键字，顾名思义是表示静态的含义。它在 c++ 中既可以修饰变量也可以修饰函数。那当我们使用 static 时，编译器究竟做了哪些事情呢？</p>\n</blockquote>\n<p>早先被问到 static 关键字，感觉既熟悉又陌生。熟悉是都知道如何去使用它，陌生又来自不知道它究竟对我们程序做了什么。今天就来好好复习下这个关键字，本文的重点也在第三部分。</p>\n<span id=\"more\"></span>\n<hr>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><ul>\n<li><a href=\"#1\">1 先说说 <strong>extern</strong></a><ul>\n<li><a href=\"#1.1\">1.1 <strong>extern</strong> 用于修饰变量</a></li>\n<li><a href=\"#1.2\">1.2 <strong>extern</strong> 用于修饰函数</a></li>\n<li><a href=\"#1.3\">1.3 <strong>extern</strong> 用于指定编译类型</a></li>\n</ul>\n</li>\n<li><a href=\"#2\">2 再讲讲 <strong>static</strong></a><ul>\n<li><a href=\"#1.2\">2.1 <strong>static</strong> 用于修饰变量</a></li>\n<li><a href=\"#2.2\">2.2 <strong>static</strong> 用于修饰函数</a></li>\n</ul>\n</li>\n<li><a href=\"#3\">3 关于 <strong>text</strong>、<strong>bss</strong> 与 <strong>data</strong> 段</a><ul>\n<li><a href=\"#3.1\">3.1 局部变量的编译</a></li>\n<li><a href=\"#3.2\">3.2 全局变量的编译</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>先看一下示例代码:<br>test1.cpp</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> a_int;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> c_array[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">static</span> <span class=\"type\">int</span> a_tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; a_tmp++ &lt;&lt; std::endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">  a_int = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//静态局部变量示例</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">func1</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//比较静态全局变量的地址示例</span></span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">const</span> <span class=\"type\">void</span> *&gt;(c_array) &lt;&lt; std::endl;</span><br><span class=\"line\">  <span class=\"built_in\">func2</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>test2.cpp</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a_int;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> c_array[<span class=\"number\">1000</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">const</span> <span class=\"type\">void</span> *&gt;(c_array) &lt;&lt; std::endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-先说说-extern\"><a href=\"#1-先说说-extern\" class=\"headerlink\" title=\"1 先说说 extern\"></a><a name=\"1\">1 先说说 <strong>extern</strong></a></h3><p><strong>extern 关键字用于告诉编译器，在其他的模块中寻找相应的定义</strong></p>\n<p>为什么 static 前要先说  extern 呢？因为他们就像相互对立的一对关键字，所以 extern 与 static 一起用时编译器会报错～</p>\n<h4 id=\"1-1-extern-用于修饰变量\"><a href=\"#1-1-extern-用于修饰变量\" class=\"headerlink\" title=\"1.1 extern 用于修饰变量\"></a><a name=\"1.1\">1.1 <strong>extern</strong> 用于修饰变量</a></h4><p>以示例代码中的 a_int 变量为例，假设其他的变量和函数不存在<br>我们先**将 extern 关键字去掉(test1.cpp:2)**，然后执行步骤:    </p>\n<ol>\n<li>编译<code>g++ -c -o test1.o test1.cpp</code>  </li>\n<li>查看符号<code>nm test1.o</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000000000000d0 S _a_int</span><br></pre></td></tr></table></figure>\n<p>可以看到 a_int 为一个未初始化的符号。说明符号在 test1.o 中已经被定义了。此时直接编译（<code>g++ -o test1 test1.cpp</code>）是不会报错的。</p>\n<p>然后我们再**将 extern 关键字加上(test1.cpp:2)**，并重复上面步骤观察符号<br><code>nm test1.o</code><br>会发现 test1.o 中没有该符号的定义。并且再编译会报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined symbols for architecture x86_64:</span><br><span class=\"line\">  &quot;_a_int&quot;, referenced from:</span><br><span class=\"line\">      _main in test1-ed3c01.o</span><br><span class=\"line\">ld: symbol(s) not found for architecture x86_64</span><br></pre></td></tr></table></figure>\n<p>很明显，链接器没有找到 a_int 的定义。此时只需要将 test2.o 加入再编译（g++ -o test test1.cpp test2.cpp）就可以啦<br><code>注：此时如果去掉 main 函数中对 a_int 变量的引用，也可以编译通过，毕竟 a_int 在程序中实际没有用到</code></p>\n<h4 id=\"1-2-extern-用于修饰函数\"><a href=\"#1-2-extern-用于修饰函数\" class=\"headerlink\" title=\"1.2 extern 用于修饰函数\"></a><a name=\"1.2\">1.2 <strong>extern</strong> 用于修饰函数</a></h4><p>以示例代码中的 func2（） 函数为例<br>因为在 main 函数中调用了 func2（），所以需要在 main 之前进行函数声明。  但此时的函数声明无论加不加 extern 其实<strong>并无多少区别</strong>  </p>\n<h4 id=\"1-3-extern-用于指定编译类型\"><a href=\"#1-3-extern-用于指定编译类型\" class=\"headerlink\" title=\"1.3 extern 用于指定编译类型\"></a><a name=\"1.3\">1.3 <strong>extern</strong> 用于指定编译类型</a></h4><p>因为 C++ 编译时会进行 <a href=\"https://en.wikipedia.org/wiki/Name_mangling\">name mangling[wiki]</a>，导致所看到的函数与实际编译后的符号差距很大。在某些情况下会导致链接时找不到符号的问题<br>此时可以使用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样在范围内的代码都将按照 C 的格式进行编译</p>\n<h3 id=\"2-再讲讲-static\"><a href=\"#2-再讲讲-static\" class=\"headerlink\" title=\"2 再讲讲 static\"></a><a name=\"2\">2 再讲讲 <strong>static</strong></a></h3><p>static 关键字在我看来的作用是</p>\n<ol>\n<li>能够改变变量的存储方式</li>\n<li>能够改变变量与函数的访问范围</li>\n</ol>\n<h4 id=\"2-1-static-用于修饰变量\"><a href=\"#2-1-static-用于修饰变量\" class=\"headerlink\" title=\"2.1 static 用于修饰变量\"></a><a name=\"2.1\">2.1 <strong>static</strong> 用于修饰变量</a></h4><p>我们都知道当程序经过编译后：</p>\n<ul>\n<li>函数体内的局部变量会保存在栈中，局部变量随着函数的调用和返回进行构造与析构，并且在函数返回后无法使用。</li>\n<li>全局变量保存在静态数据区直到程序退出时才会被析构掉。所以在整个程序内全局变量都可以使用(当然要考虑到作用域)。</li>\n</ul>\n<p>对于<strong>局部变量</strong>，当我们在变量前加上 <strong>static</strong> 时，就是告诉了编译器将该变量放入静态数据区。既函数退出时不会将该变量析构掉，当我们下次再调用改函数依然可以取得内存中的这个变量。<br>例如 test1.cpp 中，每次调用 func1() 时 a_tmp 变量都不会被销毁，最后输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p>对于<strong>全局变量</strong>，加上 static 关键字后该变量只能用于当前的文件。<br>例如 test1.cpp 中的 c_array，加上 static 后只能在当前源文件使用。<br>此时如果我们再在 test2.cpp 中定义一个同名的全局静态数组进行编译（<code>g++ -o test test1.cpp test2.cpp</code>）并且输出他们的地址  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test1.cpp[c_array]0x10bb5e100</span><br><span class=\"line\">test2.cpp[c_array]0x10bb60810</span><br></pre></td></tr></table></figure>\n<p>可以看到两个地址是不同的，所以虽说是同名的两个全局变量。但都经过 static 修饰后，他们实际还是两个地址不同相互独立的变量。</p>\n<p>那么再试一下，将 test1.cpp 中的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> c_array[<span class=\"number\">10000</span>];</span><br></pre></td></tr></table></figure>\n<p>修改为</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">char</span> c_array[<span class=\"number\">10000</span>];</span><br></pre></td></tr></table></figure>\n<p>然后再编译(<code>g++ -o test test1.cpp test2.cpp</code>)可以看到</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined symbols for architecture x86_64:</span><br><span class=\"line\">  &quot;_c_array&quot;, referenced from:</span><br><span class=\"line\">      _main in test1-5d6201.o</span><br><span class=\"line\">ld: symbol(s) not found for architecture x86_64</span><br></pre></td></tr></table></figure>\n<p>这当然是因为 test2.cpp 中的 c_array 还是有 static 进行修饰的，导致我们无法在 test1.cpp 文件中访问到。那就将 static 去掉，看到结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test1.cpp[c_array]0x10b1e2100</span><br><span class=\"line\">test2.cpp[c_array]0x10b1e2100</span><br></pre></td></tr></table></figure>\n<p>它们的地址相同对应的同一块内存，是同一个变量！</p>\n<h4 id=\"2-2-static-用于修饰函数\"><a href=\"#2-2-static-用于修饰函数\" class=\"headerlink\" title=\"2.2 static 用于修饰函数\"></a><a name=\"2.2\">2.2 <strong>static</strong> 用于修饰函数</a></h4><p>static 对于函数于变量其实比较类似，它限定了函数只能在当前的模块中使用。<br>假如我们将 test2.cpp 中的 func2() 函数加上 <strong>static</strong> 关键字，那么编译（<code>g++ -o test test1.cpp test2.cpp</code>）也会报错找不到符号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined symbols for architecture x86_64:</span><br><span class=\"line\">  &quot;func2()&quot;, referenced from:</span><br><span class=\"line\">      _main in test1-80a5c0.o</span><br><span class=\"line\">ld: symbol(s) not found for architecture x86_64</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-关于-text、bss-与-data-段\"><a href=\"#3-关于-text、bss-与-data-段\" class=\"headerlink\" title=\"3 关于 text、bss 与 data 段\"></a><a name=\"3\">3 关于 <strong>text</strong>、<strong>bss</strong> 与 <strong>data</strong> 段</a></h3><hr>\n<p>关于数据段、编译、链接方面的知识非常推荐看看<br><a href=\"https://www.amazon.cn/dp/B0027VSA7U/ref=sr_1_1?ie=UTF8&qid=1550913082&sr=8-1&keywords=%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB\">&lt;&lt;程序员的自我修养:链接、装载与库&gt;&gt;</a></p>\n<h4 id=\"3-1-局部变量的编译\"><a href=\"#3-1-局部变量的编译\" class=\"headerlink\" title=\"3.1 局部变量的编译\"></a><a name=\"3.1\">3.1 局部变量的编译</a></h4><p>是否曾经好奇函数内的临时变量经过编译会变成什么样子？  </p>\n<p>假设我们写了如下代码，并编译成名为 test 的可执行文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s1[<span class=\"number\">11</span>] = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\">  <span class=\"type\">char</span> s2[<span class=\"number\">11</span>] = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么可以通过 <code>objdump -DS test </code>观察到 main 函数中有如下片段（有省略）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\">.....</span><br><span class=\"line\">00000000004005b0 &lt;main&gt;:</span><br><span class=\"line\">4005b4:\t48 b8 68 65 6c 6c 6f \tmovabs $0x726f776f6c6c6568,%rax</span><br><span class=\"line\">4005bb:\t77 6f 72</span><br><span class=\"line\">4005be:\t48 89 45 f0          \tmov    %rax,-0x10(%rbp)</span><br><span class=\"line\">4005c2:\t66 c7 45 f8 6c 64    \tmovw   $0x646c,-0x8(%rbp)</span><br><span class=\"line\">4005c8:\tc6 45 fa 00          \tmovb   $0x0,-0x6(%rbp)</span><br><span class=\"line\">4005cc:\t48 b8 68 65 6c 6c 6f \tmovabs $0x726f776f6c6c6568,%rax</span><br><span class=\"line\">4005d3:\t77 6f 72</span><br><span class=\"line\">4005d6:\t48 89 45 e0          \tmov    %rax,-0x20(%rbp)</span><br><span class=\"line\">4005da:\t66 c7 45 e8 6c 64    \tmovw   $0x646c,-0x18(%rbp)</span><br><span class=\"line\">4005e0:\tc6 45 ea 00          \tmovb   $0x0,-0x16(%rbp)</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>观察下 0x646c 和 0x726f776f6c6c6568，转化成 ascii 就是<br><code>100 108 114 111 119 111 108 108 101 104</code><br>对应的字符<br>‘d’ ‘l’ ‘r’ ‘o’ ‘w’ ‘o’ ‘l’ ‘l’ ‘e’ ‘h’，看出来了吧，编译器将 “helloworld” 以立即数的方式写到了 text 段内。<br>然后通过 <code>readelf -a test</code>会发现并没有 s1 与 s2 的符号。</p>\n<p>现在将代码改为这样又会如何？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> s1[<span class=\"number\">11</span>] = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> s2[<span class=\"number\">11</span>] = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>继续通过 <code>objdump -DS test</code>观察发现 main 中发生了改变</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\">00000000004005b0 &lt;main&gt;:</span><br><span class=\"line\">  4005b0:\t55                   \tpush   %rbp</span><br><span class=\"line\">  4005b1:\t48 89 e5             \tmov    %rsp,%rbp</span><br><span class=\"line\">  4005b4:\tb8 00 00 00 00       \tmov    $0x0,%eax</span><br><span class=\"line\">  4005b9:\t5d                   \tpop    %rbp</span><br><span class=\"line\">  4005ba:\tc3                   \tretq</span><br><span class=\"line\">  4005bb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure>\n<p>通过 <code>readelf -a test</code>可以看到新增了两个地址不同的符号，由此可见 static 确实改变了变量的存储方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Symbol table &#x27;.symtab&#x27; contains 66 entries:</span><br><span class=\"line\">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class=\"line\">   37: 000000000060102c    11 OBJECT  LOCAL  DEFAULT   24 _ZZ4mainE2s2</span><br><span class=\"line\">   38: 0000000000601037    11 OBJECT  LOCAL  DEFAULT   24 _ZZ4mainE2s1</span><br></pre></td></tr></table></figure>\n<p>那么如果指向常量呢?稍微改下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *s1 = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *s2 = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>继续通过 objdump 观察到 main 中有这两代码，很明显了 0x400660存储着我们的 “helloworld”的字符串常量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000000004005b0 &lt;main&gt;:</span><br><span class=\"line\">  4005b4:\t48 c7 45 f8 60 06 40 \tmovq   $0x400660,-0x8(%rbp)</span><br><span class=\"line\">  4005bb:\t00</span><br><span class=\"line\">  4005bc:\t48 c7 45 f0 60 06 40 \tmovq   $0x400660,-0x10(%rbp)</span><br></pre></td></tr></table></figure>\n<p>找到这个地址，发现这个地址属于 <strong>.rodata</strong> 段。这就是我们常说用来保存字面值常量的数据段。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Disassembly of section .rodata:</span><br><span class=\"line\">0000000000400658 &lt;__dso_handle&gt;:</span><br><span class=\"line\">\t...</span><br><span class=\"line\">  400660:\t68 65 6c 6c 6f       \tpushq  $0x6f6c6c65</span><br><span class=\"line\">  400665:\t77 6f                \tja     4006d6 &lt;__dso_handle+0x7e&gt;</span><br><span class=\"line\">  400667:\t72 6c                \tjb     4006d5 &lt;__dso_handle+0x7d&gt;</span><br><span class=\"line\">  400669:\t64                   \tfs</span><br></pre></td></tr></table></figure>\n<p>观察下十六进制的值，就是我们的 “helloworld” 没错啦。</p>\n<h4 id=\"3-2-全局变量的编译\"><a href=\"#3-2-全局变量的编译\" class=\"headerlink\" title=\"3.2 全局变量的编译\"></a><a name=\"3.2\">3.2 全局变量的编译</a></h4><p>那么对于全局变量又应该是如何存储的呢？<br>首先我们知道无论静态还是非静态的变量都应该存储在静态数据区。我们熟悉的静态数据区就有 <strong>.bss</strong> 和 <strong>.data</strong>。<br><strong>.bss</strong> 在编译时实际上不占据空间，只有在运行时才会由被分配空间。那么还是来验证下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> a_array[<span class=\"number\">10000</span>];</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> b_array[<span class=\"number\">10000</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译一下(<code>g++ -o test test.cpp</code>)，然后通过 size 命令观察(<code>size test</code>)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text\t   data\t    bss\t    dec\t    hex\tfilename</span><br><span class=\"line\">1320\t    588\t  20048\t  21956\t   55c4\ttest</span><br></pre></td></tr></table></figure>\n<p>可以看出 a_array 和 b_array 都实际记录在 <strong>.bss</strong> 段，并且 <strong>.data</strong>段的大小显然不符合我们定义的数组大小。通过 <code>ll test</code>会发现文件大小不足10000 字节，所以可以肯定的是申请的这两个数组在编译时并为被分配内存。</p>\n<p>那么继续改一下看看</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> a_array[<span class=\"number\">10000</span>] = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> b_array[<span class=\"number\">10000</span>];</span><br></pre></td></tr></table></figure>\n<p>继续使用 <code>size  test</code>看下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text\t   data\t    bss\t    dec\t    hex\tfilename</span><br><span class=\"line\">1320\t  10616\t  10032\t  21968\t   55d0\ttest</span><br></pre></td></tr></table></figure>\n<p>data 段和文件都多出了 10000 多字节！！！<br>这就是因为 a_array 进行了初始化，所以编译器为其分配了内存。同理如果 b_array 也进行了初始化，那么大小还会增加。<br><strong>tips:</strong><br><strong>如果进行了初始化，但是内存中还是 0 值的话，编译器依旧不会为其分配内存的，例如<br><code>int a_array[10000] = &#123;0&#125;;</code></strong></p>\n<hr>\n<p>对于能指出文中的错误不胜感激！ :D</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong>static</strong> 是 c++ 的关键字，顾名思义是表示静态的含义。它在 c++ 中既可以修饰变量也可以修饰函数。那当我们使用 static 时，编译器究竟做了哪些事情呢？</p>\n</blockquote>\n<p>早先被问到 static 关键字，感觉既熟悉又陌生。熟悉是都知道如何去使用它，陌生又来自不知道它究竟对我们程序做了什么。今天就来好好复习下这个关键字，本文的重点也在第三部分。</p>","more":"<hr>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><ul>\n<li><a href=\"#1\">1 先说说 <strong>extern</strong></a><ul>\n<li><a href=\"#1.1\">1.1 <strong>extern</strong> 用于修饰变量</a></li>\n<li><a href=\"#1.2\">1.2 <strong>extern</strong> 用于修饰函数</a></li>\n<li><a href=\"#1.3\">1.3 <strong>extern</strong> 用于指定编译类型</a></li>\n</ul>\n</li>\n<li><a href=\"#2\">2 再讲讲 <strong>static</strong></a><ul>\n<li><a href=\"#1.2\">2.1 <strong>static</strong> 用于修饰变量</a></li>\n<li><a href=\"#2.2\">2.2 <strong>static</strong> 用于修饰函数</a></li>\n</ul>\n</li>\n<li><a href=\"#3\">3 关于 <strong>text</strong>、<strong>bss</strong> 与 <strong>data</strong> 段</a><ul>\n<li><a href=\"#3.1\">3.1 局部变量的编译</a></li>\n<li><a href=\"#3.2\">3.2 全局变量的编译</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>先看一下示例代码:<br>test1.cpp</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> a_int;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> c_array[<span class=\"number\">10000</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">static</span> <span class=\"type\">int</span> a_tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">  std::cout &lt;&lt; a_tmp++ &lt;&lt; std::endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> **argv)</span> </span>&#123;</span><br><span class=\"line\">  a_int = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//静态局部变量示例</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">func1</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//比较静态全局变量的地址示例</span></span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">const</span> <span class=\"type\">void</span> *&gt;(c_array) &lt;&lt; std::endl;</span><br><span class=\"line\">  <span class=\"built_in\">func2</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>test2.cpp</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a_int;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> c_array[<span class=\"number\">1000</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">const</span> <span class=\"type\">void</span> *&gt;(c_array) &lt;&lt; std::endl;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-先说说-extern\"><a href=\"#1-先说说-extern\" class=\"headerlink\" title=\"1 先说说 extern\"></a><a name=\"1\">1 先说说 <strong>extern</strong></a></h3><p><strong>extern 关键字用于告诉编译器，在其他的模块中寻找相应的定义</strong></p>\n<p>为什么 static 前要先说  extern 呢？因为他们就像相互对立的一对关键字，所以 extern 与 static 一起用时编译器会报错～</p>\n<h4 id=\"1-1-extern-用于修饰变量\"><a href=\"#1-1-extern-用于修饰变量\" class=\"headerlink\" title=\"1.1 extern 用于修饰变量\"></a><a name=\"1.1\">1.1 <strong>extern</strong> 用于修饰变量</a></h4><p>以示例代码中的 a_int 变量为例，假设其他的变量和函数不存在<br>我们先**将 extern 关键字去掉(test1.cpp:2)**，然后执行步骤:    </p>\n<ol>\n<li>编译<code>g++ -c -o test1.o test1.cpp</code>  </li>\n<li>查看符号<code>nm test1.o</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000000000000d0 S _a_int</span><br></pre></td></tr></table></figure>\n<p>可以看到 a_int 为一个未初始化的符号。说明符号在 test1.o 中已经被定义了。此时直接编译（<code>g++ -o test1 test1.cpp</code>）是不会报错的。</p>\n<p>然后我们再**将 extern 关键字加上(test1.cpp:2)**，并重复上面步骤观察符号<br><code>nm test1.o</code><br>会发现 test1.o 中没有该符号的定义。并且再编译会报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined symbols for architecture x86_64:</span><br><span class=\"line\">  &quot;_a_int&quot;, referenced from:</span><br><span class=\"line\">      _main in test1-ed3c01.o</span><br><span class=\"line\">ld: symbol(s) not found for architecture x86_64</span><br></pre></td></tr></table></figure>\n<p>很明显，链接器没有找到 a_int 的定义。此时只需要将 test2.o 加入再编译（g++ -o test test1.cpp test2.cpp）就可以啦<br><code>注：此时如果去掉 main 函数中对 a_int 变量的引用，也可以编译通过，毕竟 a_int 在程序中实际没有用到</code></p>\n<h4 id=\"1-2-extern-用于修饰函数\"><a href=\"#1-2-extern-用于修饰函数\" class=\"headerlink\" title=\"1.2 extern 用于修饰函数\"></a><a name=\"1.2\">1.2 <strong>extern</strong> 用于修饰函数</a></h4><p>以示例代码中的 func2（） 函数为例<br>因为在 main 函数中调用了 func2（），所以需要在 main 之前进行函数声明。  但此时的函数声明无论加不加 extern 其实<strong>并无多少区别</strong>  </p>\n<h4 id=\"1-3-extern-用于指定编译类型\"><a href=\"#1-3-extern-用于指定编译类型\" class=\"headerlink\" title=\"1.3 extern 用于指定编译类型\"></a><a name=\"1.3\">1.3 <strong>extern</strong> 用于指定编译类型</a></h4><p>因为 C++ 编译时会进行 <a href=\"https://en.wikipedia.org/wiki/Name_mangling\">name mangling[wiki]</a>，导致所看到的函数与实际编译后的符号差距很大。在某些情况下会导致链接时找不到符号的问题<br>此时可以使用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样在范围内的代码都将按照 C 的格式进行编译</p>\n<h3 id=\"2-再讲讲-static\"><a href=\"#2-再讲讲-static\" class=\"headerlink\" title=\"2 再讲讲 static\"></a><a name=\"2\">2 再讲讲 <strong>static</strong></a></h3><p>static 关键字在我看来的作用是</p>\n<ol>\n<li>能够改变变量的存储方式</li>\n<li>能够改变变量与函数的访问范围</li>\n</ol>\n<h4 id=\"2-1-static-用于修饰变量\"><a href=\"#2-1-static-用于修饰变量\" class=\"headerlink\" title=\"2.1 static 用于修饰变量\"></a><a name=\"2.1\">2.1 <strong>static</strong> 用于修饰变量</a></h4><p>我们都知道当程序经过编译后：</p>\n<ul>\n<li>函数体内的局部变量会保存在栈中，局部变量随着函数的调用和返回进行构造与析构，并且在函数返回后无法使用。</li>\n<li>全局变量保存在静态数据区直到程序退出时才会被析构掉。所以在整个程序内全局变量都可以使用(当然要考虑到作用域)。</li>\n</ul>\n<p>对于<strong>局部变量</strong>，当我们在变量前加上 <strong>static</strong> 时，就是告诉了编译器将该变量放入静态数据区。既函数退出时不会将该变量析构掉，当我们下次再调用改函数依然可以取得内存中的这个变量。<br>例如 test1.cpp 中，每次调用 func1() 时 a_tmp 变量都不会被销毁，最后输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n\n<p>对于<strong>全局变量</strong>，加上 static 关键字后该变量只能用于当前的文件。<br>例如 test1.cpp 中的 c_array，加上 static 后只能在当前源文件使用。<br>此时如果我们再在 test2.cpp 中定义一个同名的全局静态数组进行编译（<code>g++ -o test test1.cpp test2.cpp</code>）并且输出他们的地址  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test1.cpp[c_array]0x10bb5e100</span><br><span class=\"line\">test2.cpp[c_array]0x10bb60810</span><br></pre></td></tr></table></figure>\n<p>可以看到两个地址是不同的，所以虽说是同名的两个全局变量。但都经过 static 修饰后，他们实际还是两个地址不同相互独立的变量。</p>\n<p>那么再试一下，将 test1.cpp 中的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> c_array[<span class=\"number\">10000</span>];</span><br></pre></td></tr></table></figure>\n<p>修改为</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">char</span> c_array[<span class=\"number\">10000</span>];</span><br></pre></td></tr></table></figure>\n<p>然后再编译(<code>g++ -o test test1.cpp test2.cpp</code>)可以看到</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined symbols for architecture x86_64:</span><br><span class=\"line\">  &quot;_c_array&quot;, referenced from:</span><br><span class=\"line\">      _main in test1-5d6201.o</span><br><span class=\"line\">ld: symbol(s) not found for architecture x86_64</span><br></pre></td></tr></table></figure>\n<p>这当然是因为 test2.cpp 中的 c_array 还是有 static 进行修饰的，导致我们无法在 test1.cpp 文件中访问到。那就将 static 去掉，看到结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test1.cpp[c_array]0x10b1e2100</span><br><span class=\"line\">test2.cpp[c_array]0x10b1e2100</span><br></pre></td></tr></table></figure>\n<p>它们的地址相同对应的同一块内存，是同一个变量！</p>\n<h4 id=\"2-2-static-用于修饰函数\"><a href=\"#2-2-static-用于修饰函数\" class=\"headerlink\" title=\"2.2 static 用于修饰函数\"></a><a name=\"2.2\">2.2 <strong>static</strong> 用于修饰函数</a></h4><p>static 对于函数于变量其实比较类似，它限定了函数只能在当前的模块中使用。<br>假如我们将 test2.cpp 中的 func2() 函数加上 <strong>static</strong> 关键字，那么编译（<code>g++ -o test test1.cpp test2.cpp</code>）也会报错找不到符号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined symbols for architecture x86_64:</span><br><span class=\"line\">  &quot;func2()&quot;, referenced from:</span><br><span class=\"line\">      _main in test1-80a5c0.o</span><br><span class=\"line\">ld: symbol(s) not found for architecture x86_64</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-关于-text、bss-与-data-段\"><a href=\"#3-关于-text、bss-与-data-段\" class=\"headerlink\" title=\"3 关于 text、bss 与 data 段\"></a><a name=\"3\">3 关于 <strong>text</strong>、<strong>bss</strong> 与 <strong>data</strong> 段</a></h3><hr>\n<p>关于数据段、编译、链接方面的知识非常推荐看看<br><a href=\"https://www.amazon.cn/dp/B0027VSA7U/ref=sr_1_1?ie=UTF8&qid=1550913082&sr=8-1&keywords=%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB\">&lt;&lt;程序员的自我修养:链接、装载与库&gt;&gt;</a></p>\n<h4 id=\"3-1-局部变量的编译\"><a href=\"#3-1-局部变量的编译\" class=\"headerlink\" title=\"3.1 局部变量的编译\"></a><a name=\"3.1\">3.1 局部变量的编译</a></h4><p>是否曾经好奇函数内的临时变量经过编译会变成什么样子？  </p>\n<p>假设我们写了如下代码，并编译成名为 test 的可执行文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s1[<span class=\"number\">11</span>] = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\">  <span class=\"type\">char</span> s2[<span class=\"number\">11</span>] = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么可以通过 <code>objdump -DS test </code>观察到 main 函数中有如下片段（有省略）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\">.....</span><br><span class=\"line\">00000000004005b0 &lt;main&gt;:</span><br><span class=\"line\">4005b4:\t48 b8 68 65 6c 6c 6f \tmovabs $0x726f776f6c6c6568,%rax</span><br><span class=\"line\">4005bb:\t77 6f 72</span><br><span class=\"line\">4005be:\t48 89 45 f0          \tmov    %rax,-0x10(%rbp)</span><br><span class=\"line\">4005c2:\t66 c7 45 f8 6c 64    \tmovw   $0x646c,-0x8(%rbp)</span><br><span class=\"line\">4005c8:\tc6 45 fa 00          \tmovb   $0x0,-0x6(%rbp)</span><br><span class=\"line\">4005cc:\t48 b8 68 65 6c 6c 6f \tmovabs $0x726f776f6c6c6568,%rax</span><br><span class=\"line\">4005d3:\t77 6f 72</span><br><span class=\"line\">4005d6:\t48 89 45 e0          \tmov    %rax,-0x20(%rbp)</span><br><span class=\"line\">4005da:\t66 c7 45 e8 6c 64    \tmovw   $0x646c,-0x18(%rbp)</span><br><span class=\"line\">4005e0:\tc6 45 ea 00          \tmovb   $0x0,-0x16(%rbp)</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure>\n<p>观察下 0x646c 和 0x726f776f6c6c6568，转化成 ascii 就是<br><code>100 108 114 111 119 111 108 108 101 104</code><br>对应的字符<br>‘d’ ‘l’ ‘r’ ‘o’ ‘w’ ‘o’ ‘l’ ‘l’ ‘e’ ‘h’，看出来了吧，编译器将 “helloworld” 以立即数的方式写到了 text 段内。<br>然后通过 <code>readelf -a test</code>会发现并没有 s1 与 s2 的符号。</p>\n<p>现在将代码改为这样又会如何？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> s1[<span class=\"number\">11</span>] = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> s2[<span class=\"number\">11</span>] = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>继续通过 <code>objdump -DS test</code>观察发现 main 中发生了改变</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Disassembly of section .text:</span><br><span class=\"line\">00000000004005b0 &lt;main&gt;:</span><br><span class=\"line\">  4005b0:\t55                   \tpush   %rbp</span><br><span class=\"line\">  4005b1:\t48 89 e5             \tmov    %rsp,%rbp</span><br><span class=\"line\">  4005b4:\tb8 00 00 00 00       \tmov    $0x0,%eax</span><br><span class=\"line\">  4005b9:\t5d                   \tpop    %rbp</span><br><span class=\"line\">  4005ba:\tc3                   \tretq</span><br><span class=\"line\">  4005bb:\t0f 1f 44 00 00       \tnopl   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure>\n<p>通过 <code>readelf -a test</code>可以看到新增了两个地址不同的符号，由此可见 static 确实改变了变量的存储方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Symbol table &#x27;.symtab&#x27; contains 66 entries:</span><br><span class=\"line\">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class=\"line\">   37: 000000000060102c    11 OBJECT  LOCAL  DEFAULT   24 _ZZ4mainE2s2</span><br><span class=\"line\">   38: 0000000000601037    11 OBJECT  LOCAL  DEFAULT   24 _ZZ4mainE2s1</span><br></pre></td></tr></table></figure>\n<p>那么如果指向常量呢?稍微改下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *s1 = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *s2 = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>继续通过 objdump 观察到 main 中有这两代码，很明显了 0x400660存储着我们的 “helloworld”的字符串常量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000000004005b0 &lt;main&gt;:</span><br><span class=\"line\">  4005b4:\t48 c7 45 f8 60 06 40 \tmovq   $0x400660,-0x8(%rbp)</span><br><span class=\"line\">  4005bb:\t00</span><br><span class=\"line\">  4005bc:\t48 c7 45 f0 60 06 40 \tmovq   $0x400660,-0x10(%rbp)</span><br></pre></td></tr></table></figure>\n<p>找到这个地址，发现这个地址属于 <strong>.rodata</strong> 段。这就是我们常说用来保存字面值常量的数据段。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Disassembly of section .rodata:</span><br><span class=\"line\">0000000000400658 &lt;__dso_handle&gt;:</span><br><span class=\"line\">\t...</span><br><span class=\"line\">  400660:\t68 65 6c 6c 6f       \tpushq  $0x6f6c6c65</span><br><span class=\"line\">  400665:\t77 6f                \tja     4006d6 &lt;__dso_handle+0x7e&gt;</span><br><span class=\"line\">  400667:\t72 6c                \tjb     4006d5 &lt;__dso_handle+0x7d&gt;</span><br><span class=\"line\">  400669:\t64                   \tfs</span><br></pre></td></tr></table></figure>\n<p>观察下十六进制的值，就是我们的 “helloworld” 没错啦。</p>\n<h4 id=\"3-2-全局变量的编译\"><a href=\"#3-2-全局变量的编译\" class=\"headerlink\" title=\"3.2 全局变量的编译\"></a><a name=\"3.2\">3.2 全局变量的编译</a></h4><p>那么对于全局变量又应该是如何存储的呢？<br>首先我们知道无论静态还是非静态的变量都应该存储在静态数据区。我们熟悉的静态数据区就有 <strong>.bss</strong> 和 <strong>.data</strong>。<br><strong>.bss</strong> 在编译时实际上不占据空间，只有在运行时才会由被分配空间。那么还是来验证下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> a_array[<span class=\"number\">10000</span>];</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> b_array[<span class=\"number\">10000</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译一下(<code>g++ -o test test.cpp</code>)，然后通过 size 命令观察(<code>size test</code>)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text\t   data\t    bss\t    dec\t    hex\tfilename</span><br><span class=\"line\">1320\t    588\t  20048\t  21956\t   55c4\ttest</span><br></pre></td></tr></table></figure>\n<p>可以看出 a_array 和 b_array 都实际记录在 <strong>.bss</strong> 段，并且 <strong>.data</strong>段的大小显然不符合我们定义的数组大小。通过 <code>ll test</code>会发现文件大小不足10000 字节，所以可以肯定的是申请的这两个数组在编译时并为被分配内存。</p>\n<p>那么继续改一下看看</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> a_array[<span class=\"number\">10000</span>] = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> b_array[<span class=\"number\">10000</span>];</span><br></pre></td></tr></table></figure>\n<p>继续使用 <code>size  test</code>看下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text\t   data\t    bss\t    dec\t    hex\tfilename</span><br><span class=\"line\">1320\t  10616\t  10032\t  21968\t   55d0\ttest</span><br></pre></td></tr></table></figure>\n<p>data 段和文件都多出了 10000 多字节！！！<br>这就是因为 a_array 进行了初始化，所以编译器为其分配了内存。同理如果 b_array 也进行了初始化，那么大小还会增加。<br><strong>tips:</strong><br><strong>如果进行了初始化，但是内存中还是 0 值的话，编译器依旧不会为其分配内存的，例如<br><code>int a_array[10000] = &#123;0&#125;;</code></strong></p>\n<hr>\n<p>对于能指出文中的错误不胜感激！ :D</p>"},{"title":"Linux日志文件与Syslog函数介绍","date":"2016-03-23T16:00:00.000Z","_content":"\n\n在我们程序运行的过程中,由于需要不间断的运行。当发生错误的时候就得产生错误的信息并且反馈给管理人员知道。特别的对于运行于后台的daemon程序,产生的日志消息更是能够帮助我们更加清楚全面的掌握我们程序的运行状况。\n除此之外,Linux系统中各种大大小小的消息和错误都会使用日志,所以通过日志分析也能够让我们知道系统出了什么问题,以及是否有不当的操作等等,这也是众多系统管理员的一大利器!\n\n今天我们就谈谈在Linux平台上如何使用日志。\n<!--more-->\n\n------\n# **syslog服务**\n在具体的使用前我们需要先了解日志服务的一个deamon——rsyslogd。\nrsyslogd相比较于syslogd提供了更多的服务,在我使用的Ubuntu15.10下,也是自带了rsyslogd。\nrsyslog为我们提供日志的服务。它像众多的deamon程序一样默默的提供着服务。  \n在Bash下输入\n```\nps aux|grep rsyslogd\n```\n得到如下\n![rsyslog](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog01.png)\n可以看出rsyslog是一个由父进程为init的进程的守护进程。  \n它也就是为我们提供日志服务的进程了!  \n那么,这个进程为我们产生的日志消息又在哪呢?  \n`/var/log/`目录下,有各种各样的消息日志在等着我们查看呢,快去先看一眼吧!  \n## **日志文件内容的一般形式**\n如果我们打开`/var/log/`这个目录一看,就会发现有很多的文件,除无后缀的文件外还包括以`.log`结尾和以`.数字`结尾的文件(这与后面会说到的\"日志文件轮替\"相关)。\n让我们先随便打开一个文件\n![日志格式示例](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog02.png)\n这是从我系统中`/var/log/syslog`文件截取的一段,可以看到其中包含的日志信息格式:\n`[日期][主机][模块][信息]`\n所传达的意思就是:  \n>3月22日的18:03:44　由Innocence这台主机的dnsmasq[PID为1441]传来的消息,消息内容为\"using nameserver 115.159.55.17#53\"\n\n怎么样,这样的消息格式是不是很简单明了?\n## **服务类型**\nrsyslogd为我们提供了很多种的服务类型,如果你在Bash中`man syslog`一下,就可以在facility参数里看到全部的服务啦。\n这里列举**一部分**后面会用到的:\n\n- LOG_AUTH——认证系统:login、su等\n- LOG_AUTHPRIV——同上,单值登陆到对应用户的可读文件中\n- LOG_MAIL——电子邮件系统\n- LOG_DAEMON——其他系统守护进程\n- LOG_NEWS——网络新闻系统\n- LOG_LOCAL0 through LOG_LOCAL7\n\n这些都是rsyslogd支持的服务名称,那么这些是什么意思呢?\n举个例子来说:  \n在一些与邮件相关的软件中设计日志文件记录时，都会主动调用rsyslogd内的mail服务名称(LOG_MAIL),所以不管多少种不同的软件程序,由它们的日志消息在rsyslogd看来都是mail这一类型的服务了。所以我们只需要在软件中将消息统统抛给rsyslogd,再通过修改配置文件就能够让它帮我们组织管理日志文件了。   \n——后面会有更详细的解释\n\n## **信息等级**\n既然我们已经有了记录消息的地方,那么不同的消息也要分个轻重缓急吧?  \n如果是严重到会导致系统崩溃的错误消息,那么我们也当然希望能够越早知道越好的喽!  \n同样,还是在`man syslog`中,我们可以在`level`参数中看到消息的等级了!\n\n- LOG_EMERG\n- LOG_ALERT\n- LOG_CRIT\n- LOG_ERR\n- LOG_WARNING\n- LOG_NOTICE\n- LOG_INFO\n- LOG_DEBUG\n\n严重程度从上往下递减。这里的信息等级与上面提到过的服务类型都与我们接下来要说的rsyslogd的配置文件有关\n\n## **rsyslogd的配置文件**\n虽然是deamon进程,但是我们也可以通过配置文件来进行控制达到自己的目的  \n打开`/etc/rsyslog.conf`这个文件,让我们一步一步来解读...  \n在这个文件头部有一行注释\n```\n#Default logging rules can be found in /etc/rsyslog.d/50-default.conf\n```\n说明了默认的日志规则在`/etc/rstslog.d/50-default.conf`下,那让我们马上去打开那个文件!  \n以下为截取的一部分该文件的内容\n```\nauth,authpriv. *       /var/log/auth.log\nmail.err               /var/log/mail.err\nnews.crit              /var/log/news/news.crit\nnews.err               /var/log/news/news/err\ndaemon.*;mail.*;\\\n\tnews.err;\\\n\t*.=debuf;*.=info;\\\n\t*.=notice;*.=warn  |/dev/xconsole\n```\n是不是已经看出一点配置文件的味道了?\n\n## **syslog.conf的书写规则**\n现在我们已经知道了日志文件,rsyslogd服务的服务类型与消息级别。就到我们可以动手的时候了!\n在上面的文件中我截取了部分的文件内容,如下\n```\nmail.err                /var/log/mail.err\nnews.crit              -/var/log/news/news.crit\nnews.err               /var/log/news/news/err\n```\n在这个文件中`.`前面的字母表示上面提到的服务名。`.`后面表示消息的等级  \n例如:当我们写`mail.err   /var/log/mail.err`的时候意思就是把所有`mail`服务类型的并且消息等级大于`err`的消息记录在`/var/log/mail.err`这个文件中!,其实也很简单是吧?  \n**注意!**第二行中文件路径名前有一个`-`是什么意思呢?可以认为该项信息将存储在内存中,直到产生的信息足够大时才放回进磁盘内,这样处理对于频繁产生的信息可以增加访问的性能!\n\n- `.`  代表比后面还要高的消息等级都会记录下来\n- `.=` 代表只有后面的这个消息等级会被记录下来\n- `.!` 代表除了后面的这个消息等级,其他的都会被记录下来\n\n那么如果我们想记录除了mail和news的所有服务类型的所有级别的信息应该怎么写呢?\n```\n*.*;news,mail.none /var/log/message\n或者\n*.*;news.none;mail.none /var/log/message\n```\n上面两个都是可以的!  \n从上面我们可以看出\n\n- 支持通配符`*`\n- 能够将服务名以`,`连接,并在最后再加消息级别\n- 能够通过`;`分割开不同的服务和消息级别\n\n那么远程主机呢?\n只要将消息的去向改为`@主机名`或`@IP地址`就可以啦!  \nrsyslogd默认使用514端口。\n___\n# **syslog API**\n## **openlog、syslog、closelog函数**\nLinux下通过包含`<syslog.h>`头文件就可以使用rsyslogd服务了!\n```\n#include<syslog.h>\nvoid openlog(const char *ident,int option,int facility);\nvoid syslog(int priority,const char *format,...);\nvoid closelog(void);\n```\n**注:**`openlog`的调用是可以选择的,如果不调用`openlog`则会在第一次调用`syslog`时自动调用`openlog`。调用`closelog`也是可以选择的,它只是关闭被用于与rsyslogd进程通信的描述符。`ident`参数是加在消息前的一段字符串,通常将其设置为程序名称。\n\n**option**用于openlog()的option参数可以是以下几个的组合  \n`LOG_CONS`如果送到system   logger时发生问题，直接写入系统console。   \n`LOG_NDELAY`立即开启连接(通常，连接是在第一次写入讯息时才打开的)。      \n`LOG_PERROR`将讯息也同时送到stderr      \n`LOG_PID`将PID含入所有讯息中      \n**facility** 该参数用来指定何种程式在记录讯息，这可让设定档来设定何种讯息如何处理  \n`LOG_AUTH`认证系统：login、su、getty等  \n`LOG_AUTHPRIV`同LOG_AUTH，但只登录到所选择的单个用户可读的文件中  \n`LOG_CRON`cron守护进程  \n`LOG_DAEMON`其他系统守护进程，如routed  \n`LOG_FTP`文件传输协议：ftpd、tftpd  \n`LOG_KERN`内核产生的消息  \n`LOG_LOCAL0~LOG_LOCAL7`为本地使用保留  \n`LOG_LPR`系统打印机缓冲池：lpr、lpd  \n`LOG_MAIL`电子邮件系统  \n`LOG_NEWS`网络新闻系统  \n`LOG_SYSLOG`由syslogd（8）产生的内部消息  \n`LOG_USER`随机用户进程产生的消息  \n`LOG_UUCP`UUCP子系统  \n**level**决定讯息的重要性(以下的等级重要性逐次递减)  \n`LOG_EMERG`紧急情况  \n`LOG_ALERT`应该被立即改正的问题，如系统数据库破坏  \n`LOG_CRIT`重要情况，如硬盘错误  \n`LOG_ERR`错误  \n`LOG_WARNING`警告信息  \n`LOG_NOTICE`不是错误情况，但是可能需要处理  \n`LOG_INFO`情报信息  \n`LOG_DEBUG`包含情报的信息，通常旨在调试一个程序时使用  \n更多的信息请参考man手册`man syslog`\n## **一个小小的示例**\n现在让我们打开`/etc/rsyslog.conf`  \n并在最后写下这么一段...\n![](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog04.png)\n然后重启rsyslog服务让配置文件生效...\n![](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog05.png)\n写一个小小的C程序来调用syslogAPI...\n![](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog06.png)\n运行后发现目录下多了个mytest文件!里面正是我们发送的消息!\n![](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog07.png)\n怎么样,是不是简单又好用!\n___\n# **日志文件的轮替--logrotate**\n什么是日志文件的轮替?  \n当越来越多的日志消息塞满我们的文件的时候,多么希望它能够按照我们需要的方式以一天为单位保存消息啊!没错,logrotate可以帮我们做到。  \n我们可以通过对logrotate配置规则使得日志文件按我们的方式组织和更新,这样可就方便多了。  \nrsyslog进程是在系统启动时启动的daemon,但是logrotate却是在cron下在规定的时间到达后才被启动进行日志文件的轮替工作。所以我们可以在`/etc/cron.daily`文件夹中找到`logrotate`就是记录了每天要进行的日志文件轮替的行为。\n\n## **logrotate的配置文件**\n是啊,什么都少不了配置文件。通过配置文件才能使得程序完成我们的需求。  \nlogrotate的配置文件位于`/etc/logrotate.conf`,同样让我们通过一小段配置文件来理解  \n![](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog03.png)\n可以看到,我们在rsyslogd的配置文件中书写的是不同消息的存放文件规则,那么在logrotate的配置文件中我们则写的是日志文件的替换规则。这规则就是:  \n```\n文件名{\n\t\t参数1\n\t\t参数2\n\t\t·\n\t\t·\n\t\t·\n}\n```\n我们可以通过`man logrotate`来获取所有的参数和详细描述。这里列出一部分:\n\n- `daily` 指定转储周期为每天\n* `weekly` 指定转储周期为每周\n* `monthly` 指定转储周期为每月\n* `compress` 通过gzip 压缩转储以后的日志\n* `nocompress` 不需要压缩时，用这个参数\n* `copytruncate` 用于还在打开中的日志文件，把当前日志备份并截断\n* `nocopytruncate` 备份日志文件但是不截断\n* `create mode(文件权限) owner(拥有者) group(组)` 转储文件，使用指定的文件模式创建新的日志文件\n* `nocreate` 不建立新的日志文件\n* `delaycompress` 和 compress 一起使用时，转储的日志文件到下一次转储时才压缩\n* `nodelaycompress` 覆盖 delaycompress 选项，转储同时压缩。\n* `errors address` 转储时的错误信息发送到指定的Email 地址\n* `ifempty` 即使是空文件也转储，(logrotate 的缺省选项)\n* `notifempty` 如果是空文件的话，不转储\n* `mail address` 把转储的日志文件发送到指定的E-mail 地址\n* `nomail` 转储时不发送日志文件\n* `olddir directory` 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统\n* `noolddir` 转储后的日志文件和当前日志文件放在同一个目录下\n* `prerotate/endscript` 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行\n* `postrotate/endscript` 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行\n* `rotate count` 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份\n* `tabootext [+] LIST` 让logrotate 不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~\n* `size SIZE` 当日志文件到达指定的大小时才转储，Size 可以指定 bytes (缺省)以及KB (sizek)或者MB (sizem)\n\n那么我们现在再看`/var/log/`下的文件。比如syslog日志文件。当logrotate被启动工作时,如果满足了配置文件的规则。就会将`syslog`改名为`syslog.1`并新创建一个`syslog`文件用于最新消息的记录,当文件再次被轮替时,数字递增并且创建新文件,于是就有了`syslog`、`syslog.1`、`syslog.3`的三个文件。后两个作为记录保存,如果规则中需要压缩的话文件也会被压缩保存的~    \n这样对于那些`.gz``.数字.gz`结尾的文件是什么意思是不也就理解了?\n","source":"_posts/Linux日志文件与Syslog函数介绍.md","raw":"---\ntitle: Linux日志文件与Syslog函数介绍\ndate: 2016-03-24\ntags:\n - Linux\n---\n\n\n在我们程序运行的过程中,由于需要不间断的运行。当发生错误的时候就得产生错误的信息并且反馈给管理人员知道。特别的对于运行于后台的daemon程序,产生的日志消息更是能够帮助我们更加清楚全面的掌握我们程序的运行状况。\n除此之外,Linux系统中各种大大小小的消息和错误都会使用日志,所以通过日志分析也能够让我们知道系统出了什么问题,以及是否有不当的操作等等,这也是众多系统管理员的一大利器!\n\n今天我们就谈谈在Linux平台上如何使用日志。\n<!--more-->\n\n------\n# **syslog服务**\n在具体的使用前我们需要先了解日志服务的一个deamon——rsyslogd。\nrsyslogd相比较于syslogd提供了更多的服务,在我使用的Ubuntu15.10下,也是自带了rsyslogd。\nrsyslog为我们提供日志的服务。它像众多的deamon程序一样默默的提供着服务。  \n在Bash下输入\n```\nps aux|grep rsyslogd\n```\n得到如下\n![rsyslog](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog01.png)\n可以看出rsyslog是一个由父进程为init的进程的守护进程。  \n它也就是为我们提供日志服务的进程了!  \n那么,这个进程为我们产生的日志消息又在哪呢?  \n`/var/log/`目录下,有各种各样的消息日志在等着我们查看呢,快去先看一眼吧!  \n## **日志文件内容的一般形式**\n如果我们打开`/var/log/`这个目录一看,就会发现有很多的文件,除无后缀的文件外还包括以`.log`结尾和以`.数字`结尾的文件(这与后面会说到的\"日志文件轮替\"相关)。\n让我们先随便打开一个文件\n![日志格式示例](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog02.png)\n这是从我系统中`/var/log/syslog`文件截取的一段,可以看到其中包含的日志信息格式:\n`[日期][主机][模块][信息]`\n所传达的意思就是:  \n>3月22日的18:03:44　由Innocence这台主机的dnsmasq[PID为1441]传来的消息,消息内容为\"using nameserver 115.159.55.17#53\"\n\n怎么样,这样的消息格式是不是很简单明了?\n## **服务类型**\nrsyslogd为我们提供了很多种的服务类型,如果你在Bash中`man syslog`一下,就可以在facility参数里看到全部的服务啦。\n这里列举**一部分**后面会用到的:\n\n- LOG_AUTH——认证系统:login、su等\n- LOG_AUTHPRIV——同上,单值登陆到对应用户的可读文件中\n- LOG_MAIL——电子邮件系统\n- LOG_DAEMON——其他系统守护进程\n- LOG_NEWS——网络新闻系统\n- LOG_LOCAL0 through LOG_LOCAL7\n\n这些都是rsyslogd支持的服务名称,那么这些是什么意思呢?\n举个例子来说:  \n在一些与邮件相关的软件中设计日志文件记录时，都会主动调用rsyslogd内的mail服务名称(LOG_MAIL),所以不管多少种不同的软件程序,由它们的日志消息在rsyslogd看来都是mail这一类型的服务了。所以我们只需要在软件中将消息统统抛给rsyslogd,再通过修改配置文件就能够让它帮我们组织管理日志文件了。   \n——后面会有更详细的解释\n\n## **信息等级**\n既然我们已经有了记录消息的地方,那么不同的消息也要分个轻重缓急吧?  \n如果是严重到会导致系统崩溃的错误消息,那么我们也当然希望能够越早知道越好的喽!  \n同样,还是在`man syslog`中,我们可以在`level`参数中看到消息的等级了!\n\n- LOG_EMERG\n- LOG_ALERT\n- LOG_CRIT\n- LOG_ERR\n- LOG_WARNING\n- LOG_NOTICE\n- LOG_INFO\n- LOG_DEBUG\n\n严重程度从上往下递减。这里的信息等级与上面提到过的服务类型都与我们接下来要说的rsyslogd的配置文件有关\n\n## **rsyslogd的配置文件**\n虽然是deamon进程,但是我们也可以通过配置文件来进行控制达到自己的目的  \n打开`/etc/rsyslog.conf`这个文件,让我们一步一步来解读...  \n在这个文件头部有一行注释\n```\n#Default logging rules can be found in /etc/rsyslog.d/50-default.conf\n```\n说明了默认的日志规则在`/etc/rstslog.d/50-default.conf`下,那让我们马上去打开那个文件!  \n以下为截取的一部分该文件的内容\n```\nauth,authpriv. *       /var/log/auth.log\nmail.err               /var/log/mail.err\nnews.crit              /var/log/news/news.crit\nnews.err               /var/log/news/news/err\ndaemon.*;mail.*;\\\n\tnews.err;\\\n\t*.=debuf;*.=info;\\\n\t*.=notice;*.=warn  |/dev/xconsole\n```\n是不是已经看出一点配置文件的味道了?\n\n## **syslog.conf的书写规则**\n现在我们已经知道了日志文件,rsyslogd服务的服务类型与消息级别。就到我们可以动手的时候了!\n在上面的文件中我截取了部分的文件内容,如下\n```\nmail.err                /var/log/mail.err\nnews.crit              -/var/log/news/news.crit\nnews.err               /var/log/news/news/err\n```\n在这个文件中`.`前面的字母表示上面提到的服务名。`.`后面表示消息的等级  \n例如:当我们写`mail.err   /var/log/mail.err`的时候意思就是把所有`mail`服务类型的并且消息等级大于`err`的消息记录在`/var/log/mail.err`这个文件中!,其实也很简单是吧?  \n**注意!**第二行中文件路径名前有一个`-`是什么意思呢?可以认为该项信息将存储在内存中,直到产生的信息足够大时才放回进磁盘内,这样处理对于频繁产生的信息可以增加访问的性能!\n\n- `.`  代表比后面还要高的消息等级都会记录下来\n- `.=` 代表只有后面的这个消息等级会被记录下来\n- `.!` 代表除了后面的这个消息等级,其他的都会被记录下来\n\n那么如果我们想记录除了mail和news的所有服务类型的所有级别的信息应该怎么写呢?\n```\n*.*;news,mail.none /var/log/message\n或者\n*.*;news.none;mail.none /var/log/message\n```\n上面两个都是可以的!  \n从上面我们可以看出\n\n- 支持通配符`*`\n- 能够将服务名以`,`连接,并在最后再加消息级别\n- 能够通过`;`分割开不同的服务和消息级别\n\n那么远程主机呢?\n只要将消息的去向改为`@主机名`或`@IP地址`就可以啦!  \nrsyslogd默认使用514端口。\n___\n# **syslog API**\n## **openlog、syslog、closelog函数**\nLinux下通过包含`<syslog.h>`头文件就可以使用rsyslogd服务了!\n```\n#include<syslog.h>\nvoid openlog(const char *ident,int option,int facility);\nvoid syslog(int priority,const char *format,...);\nvoid closelog(void);\n```\n**注:**`openlog`的调用是可以选择的,如果不调用`openlog`则会在第一次调用`syslog`时自动调用`openlog`。调用`closelog`也是可以选择的,它只是关闭被用于与rsyslogd进程通信的描述符。`ident`参数是加在消息前的一段字符串,通常将其设置为程序名称。\n\n**option**用于openlog()的option参数可以是以下几个的组合  \n`LOG_CONS`如果送到system   logger时发生问题，直接写入系统console。   \n`LOG_NDELAY`立即开启连接(通常，连接是在第一次写入讯息时才打开的)。      \n`LOG_PERROR`将讯息也同时送到stderr      \n`LOG_PID`将PID含入所有讯息中      \n**facility** 该参数用来指定何种程式在记录讯息，这可让设定档来设定何种讯息如何处理  \n`LOG_AUTH`认证系统：login、su、getty等  \n`LOG_AUTHPRIV`同LOG_AUTH，但只登录到所选择的单个用户可读的文件中  \n`LOG_CRON`cron守护进程  \n`LOG_DAEMON`其他系统守护进程，如routed  \n`LOG_FTP`文件传输协议：ftpd、tftpd  \n`LOG_KERN`内核产生的消息  \n`LOG_LOCAL0~LOG_LOCAL7`为本地使用保留  \n`LOG_LPR`系统打印机缓冲池：lpr、lpd  \n`LOG_MAIL`电子邮件系统  \n`LOG_NEWS`网络新闻系统  \n`LOG_SYSLOG`由syslogd（8）产生的内部消息  \n`LOG_USER`随机用户进程产生的消息  \n`LOG_UUCP`UUCP子系统  \n**level**决定讯息的重要性(以下的等级重要性逐次递减)  \n`LOG_EMERG`紧急情况  \n`LOG_ALERT`应该被立即改正的问题，如系统数据库破坏  \n`LOG_CRIT`重要情况，如硬盘错误  \n`LOG_ERR`错误  \n`LOG_WARNING`警告信息  \n`LOG_NOTICE`不是错误情况，但是可能需要处理  \n`LOG_INFO`情报信息  \n`LOG_DEBUG`包含情报的信息，通常旨在调试一个程序时使用  \n更多的信息请参考man手册`man syslog`\n## **一个小小的示例**\n现在让我们打开`/etc/rsyslog.conf`  \n并在最后写下这么一段...\n![](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog04.png)\n然后重启rsyslog服务让配置文件生效...\n![](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog05.png)\n写一个小小的C程序来调用syslogAPI...\n![](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog06.png)\n运行后发现目录下多了个mytest文件!里面正是我们发送的消息!\n![](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog07.png)\n怎么样,是不是简单又好用!\n___\n# **日志文件的轮替--logrotate**\n什么是日志文件的轮替?  \n当越来越多的日志消息塞满我们的文件的时候,多么希望它能够按照我们需要的方式以一天为单位保存消息啊!没错,logrotate可以帮我们做到。  \n我们可以通过对logrotate配置规则使得日志文件按我们的方式组织和更新,这样可就方便多了。  \nrsyslog进程是在系统启动时启动的daemon,但是logrotate却是在cron下在规定的时间到达后才被启动进行日志文件的轮替工作。所以我们可以在`/etc/cron.daily`文件夹中找到`logrotate`就是记录了每天要进行的日志文件轮替的行为。\n\n## **logrotate的配置文件**\n是啊,什么都少不了配置文件。通过配置文件才能使得程序完成我们的需求。  \nlogrotate的配置文件位于`/etc/logrotate.conf`,同样让我们通过一小段配置文件来理解  \n![](http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog03.png)\n可以看到,我们在rsyslogd的配置文件中书写的是不同消息的存放文件规则,那么在logrotate的配置文件中我们则写的是日志文件的替换规则。这规则就是:  \n```\n文件名{\n\t\t参数1\n\t\t参数2\n\t\t·\n\t\t·\n\t\t·\n}\n```\n我们可以通过`man logrotate`来获取所有的参数和详细描述。这里列出一部分:\n\n- `daily` 指定转储周期为每天\n* `weekly` 指定转储周期为每周\n* `monthly` 指定转储周期为每月\n* `compress` 通过gzip 压缩转储以后的日志\n* `nocompress` 不需要压缩时，用这个参数\n* `copytruncate` 用于还在打开中的日志文件，把当前日志备份并截断\n* `nocopytruncate` 备份日志文件但是不截断\n* `create mode(文件权限) owner(拥有者) group(组)` 转储文件，使用指定的文件模式创建新的日志文件\n* `nocreate` 不建立新的日志文件\n* `delaycompress` 和 compress 一起使用时，转储的日志文件到下一次转储时才压缩\n* `nodelaycompress` 覆盖 delaycompress 选项，转储同时压缩。\n* `errors address` 转储时的错误信息发送到指定的Email 地址\n* `ifempty` 即使是空文件也转储，(logrotate 的缺省选项)\n* `notifempty` 如果是空文件的话，不转储\n* `mail address` 把转储的日志文件发送到指定的E-mail 地址\n* `nomail` 转储时不发送日志文件\n* `olddir directory` 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统\n* `noolddir` 转储后的日志文件和当前日志文件放在同一个目录下\n* `prerotate/endscript` 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行\n* `postrotate/endscript` 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行\n* `rotate count` 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份\n* `tabootext [+] LIST` 让logrotate 不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~\n* `size SIZE` 当日志文件到达指定的大小时才转储，Size 可以指定 bytes (缺省)以及KB (sizek)或者MB (sizem)\n\n那么我们现在再看`/var/log/`下的文件。比如syslog日志文件。当logrotate被启动工作时,如果满足了配置文件的规则。就会将`syslog`改名为`syslog.1`并新创建一个`syslog`文件用于最新消息的记录,当文件再次被轮替时,数字递增并且创建新文件,于是就有了`syslog`、`syslog.1`、`syslog.3`的三个文件。后两个作为记录保存,如果规则中需要压缩的话文件也会被压缩保存的~    \n这样对于那些`.gz``.数字.gz`结尾的文件是什么意思是不也就理解了?\n","slug":"Linux日志文件与Syslog函数介绍","published":1,"updated":"2022-02-27T13:20:40.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl05d6hi300055emtf7fe4kpf","content":"<p>在我们程序运行的过程中,由于需要不间断的运行。当发生错误的时候就得产生错误的信息并且反馈给管理人员知道。特别的对于运行于后台的daemon程序,产生的日志消息更是能够帮助我们更加清楚全面的掌握我们程序的运行状况。<br>除此之外,Linux系统中各种大大小小的消息和错误都会使用日志,所以通过日志分析也能够让我们知道系统出了什么问题,以及是否有不当的操作等等,这也是众多系统管理员的一大利器!</p>\n<p>今天我们就谈谈在Linux平台上如何使用日志。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h1 id=\"syslog服务\"><a href=\"#syslog服务\" class=\"headerlink\" title=\"syslog服务\"></a><strong>syslog服务</strong></h1><p>在具体的使用前我们需要先了解日志服务的一个deamon——rsyslogd。<br>rsyslogd相比较于syslogd提供了更多的服务,在我使用的Ubuntu15.10下,也是自带了rsyslogd。<br>rsyslog为我们提供日志的服务。它像众多的deamon程序一样默默的提供着服务。<br>在Bash下输入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps aux|grep rsyslogd</span><br></pre></td></tr></table></figure>\n<p>得到如下<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog01.png\" alt=\"rsyslog\"><br>可以看出rsyslog是一个由父进程为init的进程的守护进程。<br>它也就是为我们提供日志服务的进程了!<br>那么,这个进程为我们产生的日志消息又在哪呢?<br><code>/var/log/</code>目录下,有各种各样的消息日志在等着我们查看呢,快去先看一眼吧!  </p>\n<h2 id=\"日志文件内容的一般形式\"><a href=\"#日志文件内容的一般形式\" class=\"headerlink\" title=\"日志文件内容的一般形式\"></a><strong>日志文件内容的一般形式</strong></h2><p>如果我们打开<code>/var/log/</code>这个目录一看,就会发现有很多的文件,除无后缀的文件外还包括以<code>.log</code>结尾和以<code>.数字</code>结尾的文件(这与后面会说到的”日志文件轮替”相关)。<br>让我们先随便打开一个文件<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog02.png\" alt=\"日志格式示例\"><br>这是从我系统中<code>/var/log/syslog</code>文件截取的一段,可以看到其中包含的日志信息格式:<br><code>[日期][主机][模块][信息]</code><br>所传达的意思就是:  </p>\n<blockquote>\n<p>3月22日的18:03:44　由Innocence这台主机的dnsmasq[PID为1441]传来的消息,消息内容为”using nameserver 115.159.55.17#53”</p>\n</blockquote>\n<p>怎么样,这样的消息格式是不是很简单明了?</p>\n<h2 id=\"服务类型\"><a href=\"#服务类型\" class=\"headerlink\" title=\"服务类型\"></a><strong>服务类型</strong></h2><p>rsyslogd为我们提供了很多种的服务类型,如果你在Bash中<code>man syslog</code>一下,就可以在facility参数里看到全部的服务啦。<br>这里列举<strong>一部分</strong>后面会用到的:</p>\n<ul>\n<li>LOG_AUTH——认证系统:login、su等</li>\n<li>LOG_AUTHPRIV——同上,单值登陆到对应用户的可读文件中</li>\n<li>LOG_MAIL——电子邮件系统</li>\n<li>LOG_DAEMON——其他系统守护进程</li>\n<li>LOG_NEWS——网络新闻系统</li>\n<li>LOG_LOCAL0 through LOG_LOCAL7</li>\n</ul>\n<p>这些都是rsyslogd支持的服务名称,那么这些是什么意思呢?<br>举个例子来说:<br>在一些与邮件相关的软件中设计日志文件记录时，都会主动调用rsyslogd内的mail服务名称(LOG_MAIL),所以不管多少种不同的软件程序,由它们的日志消息在rsyslogd看来都是mail这一类型的服务了。所以我们只需要在软件中将消息统统抛给rsyslogd,再通过修改配置文件就能够让它帮我们组织管理日志文件了。<br>——后面会有更详细的解释</p>\n<h2 id=\"信息等级\"><a href=\"#信息等级\" class=\"headerlink\" title=\"信息等级\"></a><strong>信息等级</strong></h2><p>既然我们已经有了记录消息的地方,那么不同的消息也要分个轻重缓急吧?<br>如果是严重到会导致系统崩溃的错误消息,那么我们也当然希望能够越早知道越好的喽!<br>同样,还是在<code>man syslog</code>中,我们可以在<code>level</code>参数中看到消息的等级了!</p>\n<ul>\n<li>LOG_EMERG</li>\n<li>LOG_ALERT</li>\n<li>LOG_CRIT</li>\n<li>LOG_ERR</li>\n<li>LOG_WARNING</li>\n<li>LOG_NOTICE</li>\n<li>LOG_INFO</li>\n<li>LOG_DEBUG</li>\n</ul>\n<p>严重程度从上往下递减。这里的信息等级与上面提到过的服务类型都与我们接下来要说的rsyslogd的配置文件有关</p>\n<h2 id=\"rsyslogd的配置文件\"><a href=\"#rsyslogd的配置文件\" class=\"headerlink\" title=\"rsyslogd的配置文件\"></a><strong>rsyslogd的配置文件</strong></h2><p>虽然是deamon进程,但是我们也可以通过配置文件来进行控制达到自己的目的<br>打开<code>/etc/rsyslog.conf</code>这个文件,让我们一步一步来解读…<br>在这个文件头部有一行注释</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#Default logging rules can be found in /etc/rsyslog.d/50-default.conf</span><br></pre></td></tr></table></figure>\n<p>说明了默认的日志规则在<code>/etc/rstslog.d/50-default.conf</code>下,那让我们马上去打开那个文件!<br>以下为截取的一部分该文件的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auth,authpriv. *       /var/log/auth.log</span><br><span class=\"line\">mail.err               /var/log/mail.err</span><br><span class=\"line\">news.crit              /var/log/news/news.crit</span><br><span class=\"line\">news.err               /var/log/news/news/err</span><br><span class=\"line\">daemon.*;mail.*;\\</span><br><span class=\"line\">\tnews.err;\\</span><br><span class=\"line\">\t*.=debuf;*.=info;\\</span><br><span class=\"line\">\t*.=notice;*.=warn  |/dev/xconsole</span><br></pre></td></tr></table></figure>\n<p>是不是已经看出一点配置文件的味道了?</p>\n<h2 id=\"syslog-conf的书写规则\"><a href=\"#syslog-conf的书写规则\" class=\"headerlink\" title=\"syslog.conf的书写规则\"></a><strong>syslog.conf的书写规则</strong></h2><p>现在我们已经知道了日志文件,rsyslogd服务的服务类型与消息级别。就到我们可以动手的时候了!<br>在上面的文件中我截取了部分的文件内容,如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mail.err                /var/log/mail.err</span><br><span class=\"line\">news.crit              -/var/log/news/news.crit</span><br><span class=\"line\">news.err               /var/log/news/news/err</span><br></pre></td></tr></table></figure>\n<p>在这个文件中<code>.</code>前面的字母表示上面提到的服务名。<code>.</code>后面表示消息的等级<br>例如:当我们写<code>mail.err   /var/log/mail.err</code>的时候意思就是把所有<code>mail</code>服务类型的并且消息等级大于<code>err</code>的消息记录在<code>/var/log/mail.err</code>这个文件中!,其实也很简单是吧?<br>**注意!**第二行中文件路径名前有一个<code>-</code>是什么意思呢?可以认为该项信息将存储在内存中,直到产生的信息足够大时才放回进磁盘内,这样处理对于频繁产生的信息可以增加访问的性能!</p>\n<ul>\n<li><code>.</code>  代表比后面还要高的消息等级都会记录下来</li>\n<li><code>.=</code> 代表只有后面的这个消息等级会被记录下来</li>\n<li><code>.!</code> 代表除了后面的这个消息等级,其他的都会被记录下来</li>\n</ul>\n<p>那么如果我们想记录除了mail和news的所有服务类型的所有级别的信息应该怎么写呢?</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*.*;news,mail.none /var/log/message</span><br><span class=\"line\">或者</span><br><span class=\"line\">*.*;news.none;mail.none /var/log/message</span><br></pre></td></tr></table></figure>\n<p>上面两个都是可以的!<br>从上面我们可以看出</p>\n<ul>\n<li>支持通配符<code>*</code></li>\n<li>能够将服务名以<code>,</code>连接,并在最后再加消息级别</li>\n<li>能够通过<code>;</code>分割开不同的服务和消息级别</li>\n</ul>\n<p>那么远程主机呢?<br>只要将消息的去向改为<code>@主机名</code>或<code>@IP地址</code>就可以啦!<br>rsyslogd默认使用514端口。</p>\n<hr>\n<h1 id=\"syslog-API\"><a href=\"#syslog-API\" class=\"headerlink\" title=\"syslog API\"></a><strong>syslog API</strong></h1><h2 id=\"openlog、syslog、closelog函数\"><a href=\"#openlog、syslog、closelog函数\" class=\"headerlink\" title=\"openlog、syslog、closelog函数\"></a><strong>openlog、syslog、closelog函数</strong></h2><p>Linux下通过包含<code>&lt;syslog.h&gt;</code>头文件就可以使用rsyslogd服务了!</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;syslog.h&gt;</span><br><span class=\"line\">void openlog(const char *ident,int option,int facility);</span><br><span class=\"line\">void syslog(int priority,const char *format,...);</span><br><span class=\"line\">void closelog(void);</span><br></pre></td></tr></table></figure>\n<p><strong>注:</strong><code>openlog</code>的调用是可以选择的,如果不调用<code>openlog</code>则会在第一次调用<code>syslog</code>时自动调用<code>openlog</code>。调用<code>closelog</code>也是可以选择的,它只是关闭被用于与rsyslogd进程通信的描述符。<code>ident</code>参数是加在消息前的一段字符串,通常将其设置为程序名称。</p>\n<p><strong>option</strong>用于openlog()的option参数可以是以下几个的组合<br><code>LOG_CONS</code>如果送到system   logger时发生问题，直接写入系统console。<br><code>LOG_NDELAY</code>立即开启连接(通常，连接是在第一次写入讯息时才打开的)。<br><code>LOG_PERROR</code>将讯息也同时送到stderr<br><code>LOG_PID</code>将PID含入所有讯息中<br><strong>facility</strong> 该参数用来指定何种程式在记录讯息，这可让设定档来设定何种讯息如何处理<br><code>LOG_AUTH</code>认证系统：login、su、getty等<br><code>LOG_AUTHPRIV</code>同LOG_AUTH，但只登录到所选择的单个用户可读的文件中<br><code>LOG_CRON</code>cron守护进程<br><code>LOG_DAEMON</code>其他系统守护进程，如routed<br><code>LOG_FTP</code>文件传输协议：ftpd、tftpd<br><code>LOG_KERN</code>内核产生的消息<br><code>LOG_LOCAL0~LOG_LOCAL7</code>为本地使用保留<br><code>LOG_LPR</code>系统打印机缓冲池：lpr、lpd<br><code>LOG_MAIL</code>电子邮件系统<br><code>LOG_NEWS</code>网络新闻系统<br><code>LOG_SYSLOG</code>由syslogd（8）产生的内部消息<br><code>LOG_USER</code>随机用户进程产生的消息<br><code>LOG_UUCP</code>UUCP子系统<br><strong>level</strong>决定讯息的重要性(以下的等级重要性逐次递减)<br><code>LOG_EMERG</code>紧急情况<br><code>LOG_ALERT</code>应该被立即改正的问题，如系统数据库破坏<br><code>LOG_CRIT</code>重要情况，如硬盘错误<br><code>LOG_ERR</code>错误<br><code>LOG_WARNING</code>警告信息<br><code>LOG_NOTICE</code>不是错误情况，但是可能需要处理<br><code>LOG_INFO</code>情报信息<br><code>LOG_DEBUG</code>包含情报的信息，通常旨在调试一个程序时使用<br>更多的信息请参考man手册<code>man syslog</code></p>\n<h2 id=\"一个小小的示例\"><a href=\"#一个小小的示例\" class=\"headerlink\" title=\"一个小小的示例\"></a><strong>一个小小的示例</strong></h2><p>现在让我们打开<code>/etc/rsyslog.conf</code><br>并在最后写下这么一段…<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog04.png\"><br>然后重启rsyslog服务让配置文件生效…<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog05.png\"><br>写一个小小的C程序来调用syslogAPI…<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog06.png\"><br>运行后发现目录下多了个mytest文件!里面正是我们发送的消息!<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog07.png\"><br>怎么样,是不是简单又好用!</p>\n<hr>\n<h1 id=\"日志文件的轮替–logrotate\"><a href=\"#日志文件的轮替–logrotate\" class=\"headerlink\" title=\"日志文件的轮替–logrotate\"></a><strong>日志文件的轮替–logrotate</strong></h1><p>什么是日志文件的轮替?<br>当越来越多的日志消息塞满我们的文件的时候,多么希望它能够按照我们需要的方式以一天为单位保存消息啊!没错,logrotate可以帮我们做到。<br>我们可以通过对logrotate配置规则使得日志文件按我们的方式组织和更新,这样可就方便多了。<br>rsyslog进程是在系统启动时启动的daemon,但是logrotate却是在cron下在规定的时间到达后才被启动进行日志文件的轮替工作。所以我们可以在<code>/etc/cron.daily</code>文件夹中找到<code>logrotate</code>就是记录了每天要进行的日志文件轮替的行为。</p>\n<h2 id=\"logrotate的配置文件\"><a href=\"#logrotate的配置文件\" class=\"headerlink\" title=\"logrotate的配置文件\"></a><strong>logrotate的配置文件</strong></h2><p>是啊,什么都少不了配置文件。通过配置文件才能使得程序完成我们的需求。<br>logrotate的配置文件位于<code>/etc/logrotate.conf</code>,同样让我们通过一小段配置文件来理解<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog03.png\"><br>可以看到,我们在rsyslogd的配置文件中书写的是不同消息的存放文件规则,那么在logrotate的配置文件中我们则写的是日志文件的替换规则。这规则就是:  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件名&#123;</span><br><span class=\"line\">\t\t参数1</span><br><span class=\"line\">\t\t参数2</span><br><span class=\"line\">\t\t·</span><br><span class=\"line\">\t\t·</span><br><span class=\"line\">\t\t·</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以通过<code>man logrotate</code>来获取所有的参数和详细描述。这里列出一部分:</p>\n<ul>\n<li><code>daily</code> 指定转储周期为每天</li>\n</ul>\n<ul>\n<li><code>weekly</code> 指定转储周期为每周</li>\n<li><code>monthly</code> 指定转储周期为每月</li>\n<li><code>compress</code> 通过gzip 压缩转储以后的日志</li>\n<li><code>nocompress</code> 不需要压缩时，用这个参数</li>\n<li><code>copytruncate</code> 用于还在打开中的日志文件，把当前日志备份并截断</li>\n<li><code>nocopytruncate</code> 备份日志文件但是不截断</li>\n<li><code>create mode(文件权限) owner(拥有者) group(组)</code> 转储文件，使用指定的文件模式创建新的日志文件</li>\n<li><code>nocreate</code> 不建立新的日志文件</li>\n<li><code>delaycompress</code> 和 compress 一起使用时，转储的日志文件到下一次转储时才压缩</li>\n<li><code>nodelaycompress</code> 覆盖 delaycompress 选项，转储同时压缩。</li>\n<li><code>errors address</code> 转储时的错误信息发送到指定的Email 地址</li>\n<li><code>ifempty</code> 即使是空文件也转储，(logrotate 的缺省选项)</li>\n<li><code>notifempty</code> 如果是空文件的话，不转储</li>\n<li><code>mail address</code> 把转储的日志文件发送到指定的E-mail 地址</li>\n<li><code>nomail</code> 转储时不发送日志文件</li>\n<li><code>olddir directory</code> 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统</li>\n<li><code>noolddir</code> 转储后的日志文件和当前日志文件放在同一个目录下</li>\n<li><code>prerotate/endscript</code> 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行</li>\n<li><code>postrotate/endscript</code> 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行</li>\n<li><code>rotate count</code> 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份</li>\n<li><code>tabootext [+] LIST</code> 让logrotate 不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~</li>\n<li><code>size SIZE</code> 当日志文件到达指定的大小时才转储，Size 可以指定 bytes (缺省)以及KB (sizek)或者MB (sizem)</li>\n</ul>\n<p>那么我们现在再看<code>/var/log/</code>下的文件。比如syslog日志文件。当logrotate被启动工作时,如果满足了配置文件的规则。就会将<code>syslog</code>改名为<code>syslog.1</code>并新创建一个<code>syslog</code>文件用于最新消息的记录,当文件再次被轮替时,数字递增并且创建新文件,于是就有了<code>syslog</code>、<code>syslog.1</code>、<code>syslog.3</code>的三个文件。后两个作为记录保存,如果规则中需要压缩的话文件也会被压缩保存的~<br>这样对于那些<code>.gz``.数字.gz</code>结尾的文件是什么意思是不也就理解了?</p>\n","site":{"data":{}},"excerpt":"<p>在我们程序运行的过程中,由于需要不间断的运行。当发生错误的时候就得产生错误的信息并且反馈给管理人员知道。特别的对于运行于后台的daemon程序,产生的日志消息更是能够帮助我们更加清楚全面的掌握我们程序的运行状况。<br>除此之外,Linux系统中各种大大小小的消息和错误都会使用日志,所以通过日志分析也能够让我们知道系统出了什么问题,以及是否有不当的操作等等,这也是众多系统管理员的一大利器!</p>\n<p>今天我们就谈谈在Linux平台上如何使用日志。</p>","more":"<hr>\n<h1 id=\"syslog服务\"><a href=\"#syslog服务\" class=\"headerlink\" title=\"syslog服务\"></a><strong>syslog服务</strong></h1><p>在具体的使用前我们需要先了解日志服务的一个deamon——rsyslogd。<br>rsyslogd相比较于syslogd提供了更多的服务,在我使用的Ubuntu15.10下,也是自带了rsyslogd。<br>rsyslog为我们提供日志的服务。它像众多的deamon程序一样默默的提供着服务。<br>在Bash下输入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps aux|grep rsyslogd</span><br></pre></td></tr></table></figure>\n<p>得到如下<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog01.png\" alt=\"rsyslog\"><br>可以看出rsyslog是一个由父进程为init的进程的守护进程。<br>它也就是为我们提供日志服务的进程了!<br>那么,这个进程为我们产生的日志消息又在哪呢?<br><code>/var/log/</code>目录下,有各种各样的消息日志在等着我们查看呢,快去先看一眼吧!  </p>\n<h2 id=\"日志文件内容的一般形式\"><a href=\"#日志文件内容的一般形式\" class=\"headerlink\" title=\"日志文件内容的一般形式\"></a><strong>日志文件内容的一般形式</strong></h2><p>如果我们打开<code>/var/log/</code>这个目录一看,就会发现有很多的文件,除无后缀的文件外还包括以<code>.log</code>结尾和以<code>.数字</code>结尾的文件(这与后面会说到的”日志文件轮替”相关)。<br>让我们先随便打开一个文件<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog02.png\" alt=\"日志格式示例\"><br>这是从我系统中<code>/var/log/syslog</code>文件截取的一段,可以看到其中包含的日志信息格式:<br><code>[日期][主机][模块][信息]</code><br>所传达的意思就是:  </p>\n<blockquote>\n<p>3月22日的18:03:44　由Innocence这台主机的dnsmasq[PID为1441]传来的消息,消息内容为”using nameserver 115.159.55.17#53”</p>\n</blockquote>\n<p>怎么样,这样的消息格式是不是很简单明了?</p>\n<h2 id=\"服务类型\"><a href=\"#服务类型\" class=\"headerlink\" title=\"服务类型\"></a><strong>服务类型</strong></h2><p>rsyslogd为我们提供了很多种的服务类型,如果你在Bash中<code>man syslog</code>一下,就可以在facility参数里看到全部的服务啦。<br>这里列举<strong>一部分</strong>后面会用到的:</p>\n<ul>\n<li>LOG_AUTH——认证系统:login、su等</li>\n<li>LOG_AUTHPRIV——同上,单值登陆到对应用户的可读文件中</li>\n<li>LOG_MAIL——电子邮件系统</li>\n<li>LOG_DAEMON——其他系统守护进程</li>\n<li>LOG_NEWS——网络新闻系统</li>\n<li>LOG_LOCAL0 through LOG_LOCAL7</li>\n</ul>\n<p>这些都是rsyslogd支持的服务名称,那么这些是什么意思呢?<br>举个例子来说:<br>在一些与邮件相关的软件中设计日志文件记录时，都会主动调用rsyslogd内的mail服务名称(LOG_MAIL),所以不管多少种不同的软件程序,由它们的日志消息在rsyslogd看来都是mail这一类型的服务了。所以我们只需要在软件中将消息统统抛给rsyslogd,再通过修改配置文件就能够让它帮我们组织管理日志文件了。<br>——后面会有更详细的解释</p>\n<h2 id=\"信息等级\"><a href=\"#信息等级\" class=\"headerlink\" title=\"信息等级\"></a><strong>信息等级</strong></h2><p>既然我们已经有了记录消息的地方,那么不同的消息也要分个轻重缓急吧?<br>如果是严重到会导致系统崩溃的错误消息,那么我们也当然希望能够越早知道越好的喽!<br>同样,还是在<code>man syslog</code>中,我们可以在<code>level</code>参数中看到消息的等级了!</p>\n<ul>\n<li>LOG_EMERG</li>\n<li>LOG_ALERT</li>\n<li>LOG_CRIT</li>\n<li>LOG_ERR</li>\n<li>LOG_WARNING</li>\n<li>LOG_NOTICE</li>\n<li>LOG_INFO</li>\n<li>LOG_DEBUG</li>\n</ul>\n<p>严重程度从上往下递减。这里的信息等级与上面提到过的服务类型都与我们接下来要说的rsyslogd的配置文件有关</p>\n<h2 id=\"rsyslogd的配置文件\"><a href=\"#rsyslogd的配置文件\" class=\"headerlink\" title=\"rsyslogd的配置文件\"></a><strong>rsyslogd的配置文件</strong></h2><p>虽然是deamon进程,但是我们也可以通过配置文件来进行控制达到自己的目的<br>打开<code>/etc/rsyslog.conf</code>这个文件,让我们一步一步来解读…<br>在这个文件头部有一行注释</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#Default logging rules can be found in /etc/rsyslog.d/50-default.conf</span><br></pre></td></tr></table></figure>\n<p>说明了默认的日志规则在<code>/etc/rstslog.d/50-default.conf</code>下,那让我们马上去打开那个文件!<br>以下为截取的一部分该文件的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">auth,authpriv. *       /var/log/auth.log</span><br><span class=\"line\">mail.err               /var/log/mail.err</span><br><span class=\"line\">news.crit              /var/log/news/news.crit</span><br><span class=\"line\">news.err               /var/log/news/news/err</span><br><span class=\"line\">daemon.*;mail.*;\\</span><br><span class=\"line\">\tnews.err;\\</span><br><span class=\"line\">\t*.=debuf;*.=info;\\</span><br><span class=\"line\">\t*.=notice;*.=warn  |/dev/xconsole</span><br></pre></td></tr></table></figure>\n<p>是不是已经看出一点配置文件的味道了?</p>\n<h2 id=\"syslog-conf的书写规则\"><a href=\"#syslog-conf的书写规则\" class=\"headerlink\" title=\"syslog.conf的书写规则\"></a><strong>syslog.conf的书写规则</strong></h2><p>现在我们已经知道了日志文件,rsyslogd服务的服务类型与消息级别。就到我们可以动手的时候了!<br>在上面的文件中我截取了部分的文件内容,如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mail.err                /var/log/mail.err</span><br><span class=\"line\">news.crit              -/var/log/news/news.crit</span><br><span class=\"line\">news.err               /var/log/news/news/err</span><br></pre></td></tr></table></figure>\n<p>在这个文件中<code>.</code>前面的字母表示上面提到的服务名。<code>.</code>后面表示消息的等级<br>例如:当我们写<code>mail.err   /var/log/mail.err</code>的时候意思就是把所有<code>mail</code>服务类型的并且消息等级大于<code>err</code>的消息记录在<code>/var/log/mail.err</code>这个文件中!,其实也很简单是吧?<br>**注意!**第二行中文件路径名前有一个<code>-</code>是什么意思呢?可以认为该项信息将存储在内存中,直到产生的信息足够大时才放回进磁盘内,这样处理对于频繁产生的信息可以增加访问的性能!</p>\n<ul>\n<li><code>.</code>  代表比后面还要高的消息等级都会记录下来</li>\n<li><code>.=</code> 代表只有后面的这个消息等级会被记录下来</li>\n<li><code>.!</code> 代表除了后面的这个消息等级,其他的都会被记录下来</li>\n</ul>\n<p>那么如果我们想记录除了mail和news的所有服务类型的所有级别的信息应该怎么写呢?</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*.*;news,mail.none /var/log/message</span><br><span class=\"line\">或者</span><br><span class=\"line\">*.*;news.none;mail.none /var/log/message</span><br></pre></td></tr></table></figure>\n<p>上面两个都是可以的!<br>从上面我们可以看出</p>\n<ul>\n<li>支持通配符<code>*</code></li>\n<li>能够将服务名以<code>,</code>连接,并在最后再加消息级别</li>\n<li>能够通过<code>;</code>分割开不同的服务和消息级别</li>\n</ul>\n<p>那么远程主机呢?<br>只要将消息的去向改为<code>@主机名</code>或<code>@IP地址</code>就可以啦!<br>rsyslogd默认使用514端口。</p>\n<hr>\n<h1 id=\"syslog-API\"><a href=\"#syslog-API\" class=\"headerlink\" title=\"syslog API\"></a><strong>syslog API</strong></h1><h2 id=\"openlog、syslog、closelog函数\"><a href=\"#openlog、syslog、closelog函数\" class=\"headerlink\" title=\"openlog、syslog、closelog函数\"></a><strong>openlog、syslog、closelog函数</strong></h2><p>Linux下通过包含<code>&lt;syslog.h&gt;</code>头文件就可以使用rsyslogd服务了!</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;syslog.h&gt;</span><br><span class=\"line\">void openlog(const char *ident,int option,int facility);</span><br><span class=\"line\">void syslog(int priority,const char *format,...);</span><br><span class=\"line\">void closelog(void);</span><br></pre></td></tr></table></figure>\n<p><strong>注:</strong><code>openlog</code>的调用是可以选择的,如果不调用<code>openlog</code>则会在第一次调用<code>syslog</code>时自动调用<code>openlog</code>。调用<code>closelog</code>也是可以选择的,它只是关闭被用于与rsyslogd进程通信的描述符。<code>ident</code>参数是加在消息前的一段字符串,通常将其设置为程序名称。</p>\n<p><strong>option</strong>用于openlog()的option参数可以是以下几个的组合<br><code>LOG_CONS</code>如果送到system   logger时发生问题，直接写入系统console。<br><code>LOG_NDELAY</code>立即开启连接(通常，连接是在第一次写入讯息时才打开的)。<br><code>LOG_PERROR</code>将讯息也同时送到stderr<br><code>LOG_PID</code>将PID含入所有讯息中<br><strong>facility</strong> 该参数用来指定何种程式在记录讯息，这可让设定档来设定何种讯息如何处理<br><code>LOG_AUTH</code>认证系统：login、su、getty等<br><code>LOG_AUTHPRIV</code>同LOG_AUTH，但只登录到所选择的单个用户可读的文件中<br><code>LOG_CRON</code>cron守护进程<br><code>LOG_DAEMON</code>其他系统守护进程，如routed<br><code>LOG_FTP</code>文件传输协议：ftpd、tftpd<br><code>LOG_KERN</code>内核产生的消息<br><code>LOG_LOCAL0~LOG_LOCAL7</code>为本地使用保留<br><code>LOG_LPR</code>系统打印机缓冲池：lpr、lpd<br><code>LOG_MAIL</code>电子邮件系统<br><code>LOG_NEWS</code>网络新闻系统<br><code>LOG_SYSLOG</code>由syslogd（8）产生的内部消息<br><code>LOG_USER</code>随机用户进程产生的消息<br><code>LOG_UUCP</code>UUCP子系统<br><strong>level</strong>决定讯息的重要性(以下的等级重要性逐次递减)<br><code>LOG_EMERG</code>紧急情况<br><code>LOG_ALERT</code>应该被立即改正的问题，如系统数据库破坏<br><code>LOG_CRIT</code>重要情况，如硬盘错误<br><code>LOG_ERR</code>错误<br><code>LOG_WARNING</code>警告信息<br><code>LOG_NOTICE</code>不是错误情况，但是可能需要处理<br><code>LOG_INFO</code>情报信息<br><code>LOG_DEBUG</code>包含情报的信息，通常旨在调试一个程序时使用<br>更多的信息请参考man手册<code>man syslog</code></p>\n<h2 id=\"一个小小的示例\"><a href=\"#一个小小的示例\" class=\"headerlink\" title=\"一个小小的示例\"></a><strong>一个小小的示例</strong></h2><p>现在让我们打开<code>/etc/rsyslog.conf</code><br>并在最后写下这么一段…<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog04.png\"><br>然后重启rsyslog服务让配置文件生效…<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog05.png\"><br>写一个小小的C程序来调用syslogAPI…<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog06.png\"><br>运行后发现目录下多了个mytest文件!里面正是我们发送的消息!<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog07.png\"><br>怎么样,是不是简单又好用!</p>\n<hr>\n<h1 id=\"日志文件的轮替–logrotate\"><a href=\"#日志文件的轮替–logrotate\" class=\"headerlink\" title=\"日志文件的轮替–logrotate\"></a><strong>日志文件的轮替–logrotate</strong></h1><p>什么是日志文件的轮替?<br>当越来越多的日志消息塞满我们的文件的时候,多么希望它能够按照我们需要的方式以一天为单位保存消息啊!没错,logrotate可以帮我们做到。<br>我们可以通过对logrotate配置规则使得日志文件按我们的方式组织和更新,这样可就方便多了。<br>rsyslog进程是在系统启动时启动的daemon,但是logrotate却是在cron下在规定的时间到达后才被启动进行日志文件的轮替工作。所以我们可以在<code>/etc/cron.daily</code>文件夹中找到<code>logrotate</code>就是记录了每天要进行的日志文件轮替的行为。</p>\n<h2 id=\"logrotate的配置文件\"><a href=\"#logrotate的配置文件\" class=\"headerlink\" title=\"logrotate的配置文件\"></a><strong>logrotate的配置文件</strong></h2><p>是啊,什么都少不了配置文件。通过配置文件才能使得程序完成我们的需求。<br>logrotate的配置文件位于<code>/etc/logrotate.conf</code>,同样让我们通过一小段配置文件来理解<br><img src=\"http://7xrxgj.com1.z0.glb.clouddn.com/Linux-syslog03.png\"><br>可以看到,我们在rsyslogd的配置文件中书写的是不同消息的存放文件规则,那么在logrotate的配置文件中我们则写的是日志文件的替换规则。这规则就是:  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件名&#123;</span><br><span class=\"line\">\t\t参数1</span><br><span class=\"line\">\t\t参数2</span><br><span class=\"line\">\t\t·</span><br><span class=\"line\">\t\t·</span><br><span class=\"line\">\t\t·</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以通过<code>man logrotate</code>来获取所有的参数和详细描述。这里列出一部分:</p>\n<ul>\n<li><code>daily</code> 指定转储周期为每天</li>\n</ul>\n<ul>\n<li><code>weekly</code> 指定转储周期为每周</li>\n<li><code>monthly</code> 指定转储周期为每月</li>\n<li><code>compress</code> 通过gzip 压缩转储以后的日志</li>\n<li><code>nocompress</code> 不需要压缩时，用这个参数</li>\n<li><code>copytruncate</code> 用于还在打开中的日志文件，把当前日志备份并截断</li>\n<li><code>nocopytruncate</code> 备份日志文件但是不截断</li>\n<li><code>create mode(文件权限) owner(拥有者) group(组)</code> 转储文件，使用指定的文件模式创建新的日志文件</li>\n<li><code>nocreate</code> 不建立新的日志文件</li>\n<li><code>delaycompress</code> 和 compress 一起使用时，转储的日志文件到下一次转储时才压缩</li>\n<li><code>nodelaycompress</code> 覆盖 delaycompress 选项，转储同时压缩。</li>\n<li><code>errors address</code> 转储时的错误信息发送到指定的Email 地址</li>\n<li><code>ifempty</code> 即使是空文件也转储，(logrotate 的缺省选项)</li>\n<li><code>notifempty</code> 如果是空文件的话，不转储</li>\n<li><code>mail address</code> 把转储的日志文件发送到指定的E-mail 地址</li>\n<li><code>nomail</code> 转储时不发送日志文件</li>\n<li><code>olddir directory</code> 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统</li>\n<li><code>noolddir</code> 转储后的日志文件和当前日志文件放在同一个目录下</li>\n<li><code>prerotate/endscript</code> 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行</li>\n<li><code>postrotate/endscript</code> 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行</li>\n<li><code>rotate count</code> 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份</li>\n<li><code>tabootext [+] LIST</code> 让logrotate 不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~</li>\n<li><code>size SIZE</code> 当日志文件到达指定的大小时才转储，Size 可以指定 bytes (缺省)以及KB (sizek)或者MB (sizem)</li>\n</ul>\n<p>那么我们现在再看<code>/var/log/</code>下的文件。比如syslog日志文件。当logrotate被启动工作时,如果满足了配置文件的规则。就会将<code>syslog</code>改名为<code>syslog.1</code>并新创建一个<code>syslog</code>文件用于最新消息的记录,当文件再次被轮替时,数字递增并且创建新文件,于是就有了<code>syslog</code>、<code>syslog.1</code>、<code>syslog.3</code>的三个文件。后两个作为记录保存,如果规则中需要压缩的话文件也会被压缩保存的~<br>这样对于那些<code>.gz``.数字.gz</code>结尾的文件是什么意思是不也就理解了?</p>"},{"title":"初窥OS段页式管理概貌","date":"2015-11-12T16:00:00.000Z","reward":true,"_content":"\n>\"那是在一个还只有汇编语言的时代，一只满怀梦想的新手程序猿刚刚完成了一个小程序。“保存，运行，完美！”。可是好奇心强的他发现一些很有意思的事情:\n\n>- 为何一个64kb的程序能够在一个只有32kb内存的电脑里运行?\n>- 为什么运行中的程序能够互不干扰,结束后又能继续运行新的程序?\"\n\n>于是新奇的翻开书,发现了操作系统背着程序员偷偷做的一系列幕后工作。。。\n\n<!--more-->\n\n# **地址空间**\n\n这一切让我先从我们平常最熟悉的程序开始说起,以便先了解两个基本的概念：\n#### **1.虚拟地址**\n\tdata segment\n\ttab db 'hello world$'  ;\n\tdata ends\n\tcode segment\n\tassume cs:code, ds:data  ;\n\tstart:\n\t\t\tmov ax,data\n\t        mov ds,ax        \n\t        lea dx,tab\n\t        mov ah,9h\n\t        int 21h\n\t        mov ah,4ch\n\t        int 21h        \n\t code  ends\n\t        end start   \n\n- 这是一个用汇编写的HelloWorld程序。程序中有**数据段**(datasegment)和**代码段**(code segment),关于段页式管理的部分后面再说。这里每行代码的的偏移地址我们记做它为**虚拟地址**，因为这个地址只是在程序中是从0开始增加,运行时会被映射而产生变化的地址,所以它并不是真实的物理地址而是属于逻辑上划分的。(多亏有虚拟空间这个东西,要不我们以后写代码还得考虑每条的地理位置简直心累！)\n\n- 例如第一个mov指令(mov ax,data)，我们可以看作在代码段内的偏移地址为0，而第二条指令(mov ds,ax)的偏移地址则应该为:**上一条的虚拟地址+上一条指令的长度**。\n\n#### **2.虚拟内存**\n\n- 在最早的计算机中是没有存储器这个抽象的概念，这就意味这每个程序猿在写程序的时候直接用的是**物理地址**！在这种简单粗暴的寻址方式下出现的就是无数令人抓狂的问题。程序中的每条指令需要在内存中有固定的位置，如果位置上有别人正在运行,那么就是一切崩溃的开始(╯‵□′)╯︵┻━┻。甚至用户程序可能一个不小心就会毁掉操作系统！\n\n- 所以为了**宇宙和平**！操作系统为每个进程提供相互独立的内存地址空间就变的刻不容缓。于是乎出现了一种**存储器抽象:地址空间**。它可以令操作系统在程序运行时完成对进程的**保护**和**重定位**,使得进程之间的运行相互不干扰，我们在程序之中只需要像上面的汇编一样代码从地址0开始一行一行的编写代码，等需要运行的时候再由操作系统将准备运行的程序进行重定位到内存上一个空闲的地方。这是不是很棒！\n\n- 尽管地址空间解决了很大一部分问题,但是为了满足日益膨胀的软件规模,现有的内存已经或多或少不够用了,聪明的计算机大神们为了解决这些问题又用了一种新的技术:**虚拟内存**。虚拟内存的出现使得我们可以运行比内存容量大的多的程序。虚拟内存让每个程序有了自己的地址空间(上面提到的那个玩意儿)，这个空间被分成了多个块，每一块称作“**页面**“，可以理解所谓分页就是将我们的程序中的代码在逻辑上分成一块一块的，每一块的划分单位就是页面。运行程序时页面经由硬件执行必要的映射，使得我们程序中的虚拟地址成为我们计算机内存中真正的物理地址,完成了将程序的一部分真正的映射到了内存中\n>这就是这篇文章要介绍的分页管理!看到这里脑中对虚拟内存和页面还没有概念？别着急，接着往下看就慢慢清楚了！)\n\n\n----------\n\n\n# **让程序跑起来!**\n![这里写图片描述](http://img.blog.csdn.net/20151113110518869)\n\n- 图中左边是我们是**页表**(可以理解为一张记录页面与页框映射关系的一样表)。如果我们以4K为页面的大小单元的话(不是必须,但为普遍),我们的程序就需要:64/4=16个页面(就这样被切成了16块(｀･д･´))。但是，糟糕的问题是,真实的计算机中只有右边那可怜的32K内存,所以实际上它只能在真实的内存中保存8个**页框**(通常页面和页框的大小是相等的，因为他们需要进行后面提到的映射)。\n\n- 假设程序刚开始运行时可能会用到程序中0页,1页，2页，3页，4页，5页，9页，11页中的代码。那么当程序运行的时候在真实内存中就需要更新页表(就是将我们需要用到的页面和叶框建立映射关系),并将我们需要用到的页加载到实际内存中,这样就建立好了映射关系(图中的箭头)。图中左边为已经建立好映射关系的页表。\n\n#### **这里是第一种情况—命中**\n\n- **注意!程序开始运行了!**当我们的程序运行到0~4K行代码的时候,程序中使用到的一条 虚拟地址 会被送到一个叫**内存管理单元(MMU)**的地方,MMU发现这条虚拟地址位于页表的第0页，于是它查询页表(页面就是页表中的索引，页表的索引从0开始,例如页面2就是页表中的第三项)发现第0页中存在内容(不存在内容的地方都打上的x),然后读取内容(页框编号)，接着这条虚拟地址中页面编号的部分就被替换为取出的页框编号部分,形成了真实的物理地址!\n\n#### **下面是另一种情况—缺页**\n\n- 那么当我们的程序运行到24k~28k（页面7）的时候,传送的虚拟地址经MMU查询页表后发现页表中没有这个内容（标志为x）,也就是说真实内存中没有对应的页框！这时候MMU发出一个**缺页中断**,使得CPU陷入到操作系统。操作系统会在页表中通过页表置换算法找到一个可以移除的表项，然后将导致陷入中断的的那部分程序加载入内存,更新页表,使得页面7有了对应的页框，然后重新启动引起陷阱的指令，这样就完成了页表的更新。当然被如果程序运行到了被移除的那个表项对应的页面上就会又掉进陷阱(陷入操作系统)，继续更新页表。。。\n\n>(这就是分页的基本过程，看完如果没有深入骨髓的理解就请点击右上角。。。好吧，我就随便说说哈。。。这里只需要有个大致的理解页面管理系统是如何运作的就好~(～o￣▽￣)～o)。\n\n### 接下来就是细腻的重点——**页表**\n话不多说直接上图:\n![这里写图片描述](http://img.blog.csdn.net/20151113121634038)\n注:在我们刚刚的程序中主机有16位地址线。\n\n- 在虚拟地址中,16位的虚拟地址前4位(足够能表示我们分出来的16个页面)作为页面的编号,后12位(表示内存大小为4096个字节)则为**偏移地址**。\n#### **地址映射的步骤**\n- 那让我们看看如果在程序中有个语句要访问地址:8196(二进制为:0010 00000000000100,注意中间那个忧伤的空格)这个地址时事实又是怎么样的呢？\n\n 1.MMU发现8196这个地址存在于第3页(8k~12k),查询得到内容为110(也就是6)\n\n 2.检查页表第3表项中的状态标志(测试状态标志再后面，别着急后面会说明页表项)发现标志为'1'(即该页面对应的页框存在于内存中),一切测试通过!\n\n 3.最重要的最后一步:将得到的3位**页框编号**加上虚拟地址中的12位**偏移地址**，这样就形成了**15位的物理地址**，虚拟地址就这样完成了从8196映射到了内存中24580(位于页7 24k~28k)这个**物理地址**了!\n\n 以上就是分页管理映射的大概流程。\n\n### 接下来需要知道的是—**页表项**\n\n在上一个图中我们当我们取得一个页框的时候并不能仅仅只是进行数位的替换,还需要测试页表项的许多位，\n继续放图:\n![这里写图片描述](http://img.blog.csdn.net/20151113105401242)\n\n- **高速缓存位**:可以禁止页面被缓存,CPU希望IO等设备从接口直接取得数据,而不是从内存中一个缓存的副本中。\n\n- **访问位**:当前页被访问时会被设置，此位可以帮助操作系统的页面置换算法。\n\n- **修改位**:当前页内容被修改后该位会被设置,当页面置换算法决定需要从表项中移除此页面时如果发现被修改了则需要将修改后的数据重新写入硬盘中。如果没被修改则可以直接丢弃。\n\n- **保护位**:说明了当前页面允许执行的操作（读/写/执行 等，这个位在平常的系统权限管理中相当重要!）。\n\n- **是否存在位**:表明了当前页框是否存在于内存当中,此位可以用来判断是否缺页。\n\n\n以上的这些位都是在查询页表的过程中被测试的。比如代码段的页面会被设置为只读，如果一不小心程序企图写入这个页面，那么操作系统就会发出一个信号给进程并停止进程，告诉它”你摊上大事了!”Σ( ° △ °|||)︴\n\n\n## 更快!更快!更快!——**快表**\n- 在使用分页管理后使得内存的管理更加方便了，但是有一个问题一直在头上萦绕不去\"如果我们每次关于内存的操作都要完整的查询一次整个页表的话那无疑是非常没有效率并且非常笨的\"。机智的计算机大神们在这个问题出现后'噔'的一下计算机大神们就想出了可以利用**检测缓冲区(TLB也就是\"快表\")**这个设备解决这个问题。\n\n- 快表就是将**少量且常用**的**页面**放在一个区域(硬件或内存,取决于具体实现)中,每次的查询操作会先在快表中寻找,如果命中且符合测试条件(即测试各种标志位),则直接在快表中取出页框号,然后执行地址映射的流程。如果在快表内未命中则会进行正常的页表查询(在内存中),并在快表中淘汰一个页表项给这个新的页面替换。\n- TLB可以使用硬件也可以使用软件实现。\n\n 1.当在软件TLB中未差找到页表项但是内存中有时，就会发生一个\"**软中断**\",接着就会更新一下TLB(从内存中将页表项读入TLB)。\n\n 2.如果在 TLB和 内存中都未找到页表项时就会发生一个\"**硬中断**\",此时则会从硬盘中读取页面并更新TLB。所以我们页可以想象到硬中断相比软中断来说要耗费巨大的时间。\n\n\n----------\n\n\n# **拥抱更大的内存!**\n### **32位计算机的到来**\n时代在进步，很快计算机发展到了32位，这也使得有了更大虚拟地址空间和物理内存。再像之前那样将所有表项都放在一个页表中显然会带来效率等各种问题(比如32位机支持最大4GB内存,那么我们需要的页表项的数目为:(4*1024*1024)/4=1048576项,足足有一百多万项!)。于是又一个解决办法出现了。。。\n#### **—多级页表**\n嘿!上图:\n![这里写图片描述](http://img.blog.csdn.net/20151113105455525)\n多级页表就如名字一样有很多层的划分，这里以2级页表举例(再多也一样，只是更加复杂)\n\n- 想一下当我们还在16位CPU的时代，通过将**后12位作为偏移地址，前4为作为页面编号**解决了分页问题，成功的跑起了那个小程序。与时俱进的我们怎么能够满足于现状!为了拥抱更大的内存。\n\n- 我们需要将当前的32位地址进行**重新的划分:前10位为目录，中间10位为页面，后12位为偏移地址**。(想象一下顶级页表可以有2^10=1024个项，而每个二级页表可以表4k*1024=4MB的空间，也就是说一个顶级页表可以表4MB×1024=4GB的空间，这刚好是32位计算机能支持的最大内存)。\n\n- 当我们查找一条虚拟地址时，通过:\n **1.前10位索引查找到顶级页表中的二级页表地址**\n **2.通过虚拟地址的中间10位索引到二级页表中的页表项**\n **3.接下来就使用查找到的页表项中的页框号加上虚拟地址最后的12位偏移地址**组成了真实的物理地址!\n\n- 在一个进程执行的时候它实际上也许只需要几个页表。当程序一不小心访问到其他页面的时候无法通过标志位测试而回给操作系统发出”缺页中断“,操作系统检测到了这个进程又企图访问我们不想让它看到的地方，于是又发给它个信号说”你又摊上大事了!”Σ( ° △ °|||)︴，然后无情关闭了它。\n\n\n----------\n### **64位需要更机智的页表方法**\n\n>虽然多级页表在32位机上有一个很好的表现，但是时代又进步了!64位计算机开始普遍。\n>地址空间增长到了2^64,如果页面大小依旧为4kb，那么需要有一个2^52个表项的页表。再如果每个表项8个字节，那么需要多么大的容量你们可以自己算一算(美到不敢想象～)。\n那么问题就又来了。。。\n不过既然我们有2^64这么大的虚拟地址空间，而仅仅只有几个G可怜的小内存那么咱们之前用过的分页肯定就是不能继续再使用了。如果我们。。。换一下?**是的!**\n——我们可以改变由虚拟地址映射物理地址的做法而直接由物理地址映射到虚拟地址!这么一变我们的页表就变小的可以接受了。。。这就是\n#### **—倒排列表**\n- 先抛出**缺点**:倒排列表虽然会缩小页表的规模，但是它会使得从虚拟地址到物理地址的转化过程变得相当困难(反向查找，想想就难受)。\n\n- 当然有缺点我们就要克服缺点!这次又该轮到TLB出场了,由TLB缓存住经常使用的页面可以大大加快效率。但是如果发生缺页时我们应该怎么办？一条条翻完整个倒排页表来找嘛？—**怎么会!**那可不得累死了。。。∑(っ°Д°;)っ。\n\n- 所以机智的计算机大神们又带来的新的解决方案—**散列**!通过将虚拟页面进行散列,如果将散列的虚拟页面与物理页面一样多，那么冲突链都会是可以接受的范围。所以通过**散列+TLB**的方法成功的将我们从超过3000万GB的页表中释放出来!\no(*￣▽￣*)ブ这可得好好庆祝下。。。\n\n\n----------\n\n\n# **关于各种页面置换算法**\n#### **（额。那又是一个大坑。。 ╮(╯_╰)╭）**\n\n所以这里就贴部分算法的百度连接大家有兴趣的可以看看～\n\n\n1.[最佳页面置换算法](http://baike.baidu.com/link?url=8kFsLNxCkL6ZRQ1qInfj40MCrscXKdFaDMlQnDsT-TuUEXDPj_kU80MQbrFTXZa7XpWEHYi_g5d5Krd0y22ob_)  \n2.最近未使用页面置换算法(么有链接额。。)\n3.[先进先出页面置换算法](http://baike.baidu.com/view/9932283.htm)\n4.[第二次机会页面置换算法](http://baike.baidu.com/view/5015063.htm)\n5.[时钟页面置换算法](http://baike.baidu.com/link?url=kbCAbFPDXXwEF4IWsBIcFFygCDjIeJ_6ib80LRRrzgM_CFpS2Ks3G8mXqF1s0iSVpX-f_Jf8zx2asSpi-C943_)\n6.[最近最少使用页面算法](http://wenku.baidu.com/link?url=I66I9aDoWU0PVNEMHpYln4P0G4ej0oY-5rqeoaPzGNHrfAdxpvgX0p_hq8CtL8Vksyoc3KNwbuGuZRKknzvTWi4_eGBIlqmA0G3BYczLnzO)\n7.[工作集页面置换算法](DWg4lIV3Jg27fRuB2H1wInOvqEhEcEzJaQMXCHzVvgHEnu94tHsZOM283eytRUuDD6Vmk72I8Wgqe7J9lnJHDDwoRNLtnxlIPlXAcbd1o1e)\n8.工作集时钟页面置换算法(么有链接额。。)\n\n\n----------\n\n\n# **段页式管理**\n分段的实现我们都不会陌生，程序就是由许许多多的段构成并且在内存中运行的。\n段的大小可以是不固定的，相反页的大小是固定的。但是如果在操作系统中只有段的存在必然会与分区管理一样容易产生内存碎片(好慌~)。如果我门将段的管理与页的管理相结合。。。\n那么就是又一个新的管理方式!!!(好累...(┙>∧<)┙へ┻┻)\n\n段页式管理其实就是在段的偏移地址里面容纳了页面号组成了**段+页面+偏移地址**的虚拟地址格式，所以理解了分页管理这里也很容易 o(*≧▽≦)ツ┏━┓。\n\n在操作系统中则为进程维护了一张类似这样的几张表:\n![这里写图片描述](http://img.blog.csdn.net/20151113105527579)\n\n- 没错，了解了前面的分页管理方式后我们应该可以很明白的看懂这个的地址转换方式。现在让我们回顾下开头的汇编程序，找到那个**code segment**,这就是**段**!当我们程序发现要执行code段的时候将段描述符所指向页表的**地址**加载入**寄存器**(方便接下来指令的快速查找)。然后就是通过虚拟地址的中间的页面号在页表中查找对应的页表项。再然后的然后就你就会噢的一下都懂了～\n>一切似乎又有了熟悉的味道。。。(￣▽￣\") 。。。\n\n\n 最后附上参考资料:《现代操作系统》-Andrew S.Tanenbaum\n\n如有错误希望能得到指点,不胜感激 :D\n","source":"_posts/初窥OS段页式管理概貌.md","raw":"---\ntitle: 初窥OS段页式管理概貌\ndate: 2015-11-13\nreward: true\ntags:\n - Linux\n - Operating System\n - 内存管理\n---\n\n>\"那是在一个还只有汇编语言的时代，一只满怀梦想的新手程序猿刚刚完成了一个小程序。“保存，运行，完美！”。可是好奇心强的他发现一些很有意思的事情:\n\n>- 为何一个64kb的程序能够在一个只有32kb内存的电脑里运行?\n>- 为什么运行中的程序能够互不干扰,结束后又能继续运行新的程序?\"\n\n>于是新奇的翻开书,发现了操作系统背着程序员偷偷做的一系列幕后工作。。。\n\n<!--more-->\n\n# **地址空间**\n\n这一切让我先从我们平常最熟悉的程序开始说起,以便先了解两个基本的概念：\n#### **1.虚拟地址**\n\tdata segment\n\ttab db 'hello world$'  ;\n\tdata ends\n\tcode segment\n\tassume cs:code, ds:data  ;\n\tstart:\n\t\t\tmov ax,data\n\t        mov ds,ax        \n\t        lea dx,tab\n\t        mov ah,9h\n\t        int 21h\n\t        mov ah,4ch\n\t        int 21h        \n\t code  ends\n\t        end start   \n\n- 这是一个用汇编写的HelloWorld程序。程序中有**数据段**(datasegment)和**代码段**(code segment),关于段页式管理的部分后面再说。这里每行代码的的偏移地址我们记做它为**虚拟地址**，因为这个地址只是在程序中是从0开始增加,运行时会被映射而产生变化的地址,所以它并不是真实的物理地址而是属于逻辑上划分的。(多亏有虚拟空间这个东西,要不我们以后写代码还得考虑每条的地理位置简直心累！)\n\n- 例如第一个mov指令(mov ax,data)，我们可以看作在代码段内的偏移地址为0，而第二条指令(mov ds,ax)的偏移地址则应该为:**上一条的虚拟地址+上一条指令的长度**。\n\n#### **2.虚拟内存**\n\n- 在最早的计算机中是没有存储器这个抽象的概念，这就意味这每个程序猿在写程序的时候直接用的是**物理地址**！在这种简单粗暴的寻址方式下出现的就是无数令人抓狂的问题。程序中的每条指令需要在内存中有固定的位置，如果位置上有别人正在运行,那么就是一切崩溃的开始(╯‵□′)╯︵┻━┻。甚至用户程序可能一个不小心就会毁掉操作系统！\n\n- 所以为了**宇宙和平**！操作系统为每个进程提供相互独立的内存地址空间就变的刻不容缓。于是乎出现了一种**存储器抽象:地址空间**。它可以令操作系统在程序运行时完成对进程的**保护**和**重定位**,使得进程之间的运行相互不干扰，我们在程序之中只需要像上面的汇编一样代码从地址0开始一行一行的编写代码，等需要运行的时候再由操作系统将准备运行的程序进行重定位到内存上一个空闲的地方。这是不是很棒！\n\n- 尽管地址空间解决了很大一部分问题,但是为了满足日益膨胀的软件规模,现有的内存已经或多或少不够用了,聪明的计算机大神们为了解决这些问题又用了一种新的技术:**虚拟内存**。虚拟内存的出现使得我们可以运行比内存容量大的多的程序。虚拟内存让每个程序有了自己的地址空间(上面提到的那个玩意儿)，这个空间被分成了多个块，每一块称作“**页面**“，可以理解所谓分页就是将我们的程序中的代码在逻辑上分成一块一块的，每一块的划分单位就是页面。运行程序时页面经由硬件执行必要的映射，使得我们程序中的虚拟地址成为我们计算机内存中真正的物理地址,完成了将程序的一部分真正的映射到了内存中\n>这就是这篇文章要介绍的分页管理!看到这里脑中对虚拟内存和页面还没有概念？别着急，接着往下看就慢慢清楚了！)\n\n\n----------\n\n\n# **让程序跑起来!**\n![这里写图片描述](http://img.blog.csdn.net/20151113110518869)\n\n- 图中左边是我们是**页表**(可以理解为一张记录页面与页框映射关系的一样表)。如果我们以4K为页面的大小单元的话(不是必须,但为普遍),我们的程序就需要:64/4=16个页面(就这样被切成了16块(｀･д･´))。但是，糟糕的问题是,真实的计算机中只有右边那可怜的32K内存,所以实际上它只能在真实的内存中保存8个**页框**(通常页面和页框的大小是相等的，因为他们需要进行后面提到的映射)。\n\n- 假设程序刚开始运行时可能会用到程序中0页,1页，2页，3页，4页，5页，9页，11页中的代码。那么当程序运行的时候在真实内存中就需要更新页表(就是将我们需要用到的页面和叶框建立映射关系),并将我们需要用到的页加载到实际内存中,这样就建立好了映射关系(图中的箭头)。图中左边为已经建立好映射关系的页表。\n\n#### **这里是第一种情况—命中**\n\n- **注意!程序开始运行了!**当我们的程序运行到0~4K行代码的时候,程序中使用到的一条 虚拟地址 会被送到一个叫**内存管理单元(MMU)**的地方,MMU发现这条虚拟地址位于页表的第0页，于是它查询页表(页面就是页表中的索引，页表的索引从0开始,例如页面2就是页表中的第三项)发现第0页中存在内容(不存在内容的地方都打上的x),然后读取内容(页框编号)，接着这条虚拟地址中页面编号的部分就被替换为取出的页框编号部分,形成了真实的物理地址!\n\n#### **下面是另一种情况—缺页**\n\n- 那么当我们的程序运行到24k~28k（页面7）的时候,传送的虚拟地址经MMU查询页表后发现页表中没有这个内容（标志为x）,也就是说真实内存中没有对应的页框！这时候MMU发出一个**缺页中断**,使得CPU陷入到操作系统。操作系统会在页表中通过页表置换算法找到一个可以移除的表项，然后将导致陷入中断的的那部分程序加载入内存,更新页表,使得页面7有了对应的页框，然后重新启动引起陷阱的指令，这样就完成了页表的更新。当然被如果程序运行到了被移除的那个表项对应的页面上就会又掉进陷阱(陷入操作系统)，继续更新页表。。。\n\n>(这就是分页的基本过程，看完如果没有深入骨髓的理解就请点击右上角。。。好吧，我就随便说说哈。。。这里只需要有个大致的理解页面管理系统是如何运作的就好~(～o￣▽￣)～o)。\n\n### 接下来就是细腻的重点——**页表**\n话不多说直接上图:\n![这里写图片描述](http://img.blog.csdn.net/20151113121634038)\n注:在我们刚刚的程序中主机有16位地址线。\n\n- 在虚拟地址中,16位的虚拟地址前4位(足够能表示我们分出来的16个页面)作为页面的编号,后12位(表示内存大小为4096个字节)则为**偏移地址**。\n#### **地址映射的步骤**\n- 那让我们看看如果在程序中有个语句要访问地址:8196(二进制为:0010 00000000000100,注意中间那个忧伤的空格)这个地址时事实又是怎么样的呢？\n\n 1.MMU发现8196这个地址存在于第3页(8k~12k),查询得到内容为110(也就是6)\n\n 2.检查页表第3表项中的状态标志(测试状态标志再后面，别着急后面会说明页表项)发现标志为'1'(即该页面对应的页框存在于内存中),一切测试通过!\n\n 3.最重要的最后一步:将得到的3位**页框编号**加上虚拟地址中的12位**偏移地址**，这样就形成了**15位的物理地址**，虚拟地址就这样完成了从8196映射到了内存中24580(位于页7 24k~28k)这个**物理地址**了!\n\n 以上就是分页管理映射的大概流程。\n\n### 接下来需要知道的是—**页表项**\n\n在上一个图中我们当我们取得一个页框的时候并不能仅仅只是进行数位的替换,还需要测试页表项的许多位，\n继续放图:\n![这里写图片描述](http://img.blog.csdn.net/20151113105401242)\n\n- **高速缓存位**:可以禁止页面被缓存,CPU希望IO等设备从接口直接取得数据,而不是从内存中一个缓存的副本中。\n\n- **访问位**:当前页被访问时会被设置，此位可以帮助操作系统的页面置换算法。\n\n- **修改位**:当前页内容被修改后该位会被设置,当页面置换算法决定需要从表项中移除此页面时如果发现被修改了则需要将修改后的数据重新写入硬盘中。如果没被修改则可以直接丢弃。\n\n- **保护位**:说明了当前页面允许执行的操作（读/写/执行 等，这个位在平常的系统权限管理中相当重要!）。\n\n- **是否存在位**:表明了当前页框是否存在于内存当中,此位可以用来判断是否缺页。\n\n\n以上的这些位都是在查询页表的过程中被测试的。比如代码段的页面会被设置为只读，如果一不小心程序企图写入这个页面，那么操作系统就会发出一个信号给进程并停止进程，告诉它”你摊上大事了!”Σ( ° △ °|||)︴\n\n\n## 更快!更快!更快!——**快表**\n- 在使用分页管理后使得内存的管理更加方便了，但是有一个问题一直在头上萦绕不去\"如果我们每次关于内存的操作都要完整的查询一次整个页表的话那无疑是非常没有效率并且非常笨的\"。机智的计算机大神们在这个问题出现后'噔'的一下计算机大神们就想出了可以利用**检测缓冲区(TLB也就是\"快表\")**这个设备解决这个问题。\n\n- 快表就是将**少量且常用**的**页面**放在一个区域(硬件或内存,取决于具体实现)中,每次的查询操作会先在快表中寻找,如果命中且符合测试条件(即测试各种标志位),则直接在快表中取出页框号,然后执行地址映射的流程。如果在快表内未命中则会进行正常的页表查询(在内存中),并在快表中淘汰一个页表项给这个新的页面替换。\n- TLB可以使用硬件也可以使用软件实现。\n\n 1.当在软件TLB中未差找到页表项但是内存中有时，就会发生一个\"**软中断**\",接着就会更新一下TLB(从内存中将页表项读入TLB)。\n\n 2.如果在 TLB和 内存中都未找到页表项时就会发生一个\"**硬中断**\",此时则会从硬盘中读取页面并更新TLB。所以我们页可以想象到硬中断相比软中断来说要耗费巨大的时间。\n\n\n----------\n\n\n# **拥抱更大的内存!**\n### **32位计算机的到来**\n时代在进步，很快计算机发展到了32位，这也使得有了更大虚拟地址空间和物理内存。再像之前那样将所有表项都放在一个页表中显然会带来效率等各种问题(比如32位机支持最大4GB内存,那么我们需要的页表项的数目为:(4*1024*1024)/4=1048576项,足足有一百多万项!)。于是又一个解决办法出现了。。。\n#### **—多级页表**\n嘿!上图:\n![这里写图片描述](http://img.blog.csdn.net/20151113105455525)\n多级页表就如名字一样有很多层的划分，这里以2级页表举例(再多也一样，只是更加复杂)\n\n- 想一下当我们还在16位CPU的时代，通过将**后12位作为偏移地址，前4为作为页面编号**解决了分页问题，成功的跑起了那个小程序。与时俱进的我们怎么能够满足于现状!为了拥抱更大的内存。\n\n- 我们需要将当前的32位地址进行**重新的划分:前10位为目录，中间10位为页面，后12位为偏移地址**。(想象一下顶级页表可以有2^10=1024个项，而每个二级页表可以表4k*1024=4MB的空间，也就是说一个顶级页表可以表4MB×1024=4GB的空间，这刚好是32位计算机能支持的最大内存)。\n\n- 当我们查找一条虚拟地址时，通过:\n **1.前10位索引查找到顶级页表中的二级页表地址**\n **2.通过虚拟地址的中间10位索引到二级页表中的页表项**\n **3.接下来就使用查找到的页表项中的页框号加上虚拟地址最后的12位偏移地址**组成了真实的物理地址!\n\n- 在一个进程执行的时候它实际上也许只需要几个页表。当程序一不小心访问到其他页面的时候无法通过标志位测试而回给操作系统发出”缺页中断“,操作系统检测到了这个进程又企图访问我们不想让它看到的地方，于是又发给它个信号说”你又摊上大事了!”Σ( ° △ °|||)︴，然后无情关闭了它。\n\n\n----------\n### **64位需要更机智的页表方法**\n\n>虽然多级页表在32位机上有一个很好的表现，但是时代又进步了!64位计算机开始普遍。\n>地址空间增长到了2^64,如果页面大小依旧为4kb，那么需要有一个2^52个表项的页表。再如果每个表项8个字节，那么需要多么大的容量你们可以自己算一算(美到不敢想象～)。\n那么问题就又来了。。。\n不过既然我们有2^64这么大的虚拟地址空间，而仅仅只有几个G可怜的小内存那么咱们之前用过的分页肯定就是不能继续再使用了。如果我们。。。换一下?**是的!**\n——我们可以改变由虚拟地址映射物理地址的做法而直接由物理地址映射到虚拟地址!这么一变我们的页表就变小的可以接受了。。。这就是\n#### **—倒排列表**\n- 先抛出**缺点**:倒排列表虽然会缩小页表的规模，但是它会使得从虚拟地址到物理地址的转化过程变得相当困难(反向查找，想想就难受)。\n\n- 当然有缺点我们就要克服缺点!这次又该轮到TLB出场了,由TLB缓存住经常使用的页面可以大大加快效率。但是如果发生缺页时我们应该怎么办？一条条翻完整个倒排页表来找嘛？—**怎么会!**那可不得累死了。。。∑(っ°Д°;)っ。\n\n- 所以机智的计算机大神们又带来的新的解决方案—**散列**!通过将虚拟页面进行散列,如果将散列的虚拟页面与物理页面一样多，那么冲突链都会是可以接受的范围。所以通过**散列+TLB**的方法成功的将我们从超过3000万GB的页表中释放出来!\no(*￣▽￣*)ブ这可得好好庆祝下。。。\n\n\n----------\n\n\n# **关于各种页面置换算法**\n#### **（额。那又是一个大坑。。 ╮(╯_╰)╭）**\n\n所以这里就贴部分算法的百度连接大家有兴趣的可以看看～\n\n\n1.[最佳页面置换算法](http://baike.baidu.com/link?url=8kFsLNxCkL6ZRQ1qInfj40MCrscXKdFaDMlQnDsT-TuUEXDPj_kU80MQbrFTXZa7XpWEHYi_g5d5Krd0y22ob_)  \n2.最近未使用页面置换算法(么有链接额。。)\n3.[先进先出页面置换算法](http://baike.baidu.com/view/9932283.htm)\n4.[第二次机会页面置换算法](http://baike.baidu.com/view/5015063.htm)\n5.[时钟页面置换算法](http://baike.baidu.com/link?url=kbCAbFPDXXwEF4IWsBIcFFygCDjIeJ_6ib80LRRrzgM_CFpS2Ks3G8mXqF1s0iSVpX-f_Jf8zx2asSpi-C943_)\n6.[最近最少使用页面算法](http://wenku.baidu.com/link?url=I66I9aDoWU0PVNEMHpYln4P0G4ej0oY-5rqeoaPzGNHrfAdxpvgX0p_hq8CtL8Vksyoc3KNwbuGuZRKknzvTWi4_eGBIlqmA0G3BYczLnzO)\n7.[工作集页面置换算法](DWg4lIV3Jg27fRuB2H1wInOvqEhEcEzJaQMXCHzVvgHEnu94tHsZOM283eytRUuDD6Vmk72I8Wgqe7J9lnJHDDwoRNLtnxlIPlXAcbd1o1e)\n8.工作集时钟页面置换算法(么有链接额。。)\n\n\n----------\n\n\n# **段页式管理**\n分段的实现我们都不会陌生，程序就是由许许多多的段构成并且在内存中运行的。\n段的大小可以是不固定的，相反页的大小是固定的。但是如果在操作系统中只有段的存在必然会与分区管理一样容易产生内存碎片(好慌~)。如果我门将段的管理与页的管理相结合。。。\n那么就是又一个新的管理方式!!!(好累...(┙>∧<)┙へ┻┻)\n\n段页式管理其实就是在段的偏移地址里面容纳了页面号组成了**段+页面+偏移地址**的虚拟地址格式，所以理解了分页管理这里也很容易 o(*≧▽≦)ツ┏━┓。\n\n在操作系统中则为进程维护了一张类似这样的几张表:\n![这里写图片描述](http://img.blog.csdn.net/20151113105527579)\n\n- 没错，了解了前面的分页管理方式后我们应该可以很明白的看懂这个的地址转换方式。现在让我们回顾下开头的汇编程序，找到那个**code segment**,这就是**段**!当我们程序发现要执行code段的时候将段描述符所指向页表的**地址**加载入**寄存器**(方便接下来指令的快速查找)。然后就是通过虚拟地址的中间的页面号在页表中查找对应的页表项。再然后的然后就你就会噢的一下都懂了～\n>一切似乎又有了熟悉的味道。。。(￣▽￣\") 。。。\n\n\n 最后附上参考资料:《现代操作系统》-Andrew S.Tanenbaum\n\n如有错误希望能得到指点,不胜感激 :D\n","slug":"初窥OS段页式管理概貌","published":1,"updated":"2022-02-27T14:13:00.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl05d6hi400085emt6elnhtr4","content":"<blockquote>\n<p>“那是在一个还只有汇编语言的时代，一只满怀梦想的新手程序猿刚刚完成了一个小程序。“保存，运行，完美！”。可是好奇心强的他发现一些很有意思的事情:</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>为何一个64kb的程序能够在一个只有32kb内存的电脑里运行?</li>\n<li>为什么运行中的程序能够互不干扰,结束后又能继续运行新的程序?”</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>于是新奇的翻开书,发现了操作系统背着程序员偷偷做的一系列幕后工作。。。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h1 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a><strong>地址空间</strong></h1><p>这一切让我先从我们平常最熟悉的程序开始说起,以便先了解两个基本的概念：</p>\n<h4 id=\"1-虚拟地址\"><a href=\"#1-虚拟地址\" class=\"headerlink\" title=\"1.虚拟地址\"></a><strong>1.虚拟地址</strong></h4><pre><code>data segment\ntab db &#39;hello world$&#39;  ;\ndata ends\ncode segment\nassume cs:code, ds:data  ;\nstart:\n        mov ax,data\n        mov ds,ax        \n        lea dx,tab\n        mov ah,9h\n        int 21h\n        mov ah,4ch\n        int 21h        \n code  ends\n        end start   \n</code></pre>\n<ul>\n<li><p>这是一个用汇编写的HelloWorld程序。程序中有<strong>数据段</strong>(datasegment)和<strong>代码段</strong>(code segment),关于段页式管理的部分后面再说。这里每行代码的的偏移地址我们记做它为<strong>虚拟地址</strong>，因为这个地址只是在程序中是从0开始增加,运行时会被映射而产生变化的地址,所以它并不是真实的物理地址而是属于逻辑上划分的。(多亏有虚拟空间这个东西,要不我们以后写代码还得考虑每条的地理位置简直心累！)</p>\n</li>\n<li><p>例如第一个mov指令(mov ax,data)，我们可以看作在代码段内的偏移地址为0，而第二条指令(mov ds,ax)的偏移地址则应该为:<strong>上一条的虚拟地址+上一条指令的长度</strong>。</p>\n</li>\n</ul>\n<h4 id=\"2-虚拟内存\"><a href=\"#2-虚拟内存\" class=\"headerlink\" title=\"2.虚拟内存\"></a><strong>2.虚拟内存</strong></h4><ul>\n<li><p>在最早的计算机中是没有存储器这个抽象的概念，这就意味这每个程序猿在写程序的时候直接用的是<strong>物理地址</strong>！在这种简单粗暴的寻址方式下出现的就是无数令人抓狂的问题。程序中的每条指令需要在内存中有固定的位置，如果位置上有别人正在运行,那么就是一切崩溃的开始(╯‵□′)╯︵┻━┻。甚至用户程序可能一个不小心就会毁掉操作系统！</p>\n</li>\n<li><p>所以为了<strong>宇宙和平</strong>！操作系统为每个进程提供相互独立的内存地址空间就变的刻不容缓。于是乎出现了一种<strong>存储器抽象:地址空间</strong>。它可以令操作系统在程序运行时完成对进程的<strong>保护</strong>和<strong>重定位</strong>,使得进程之间的运行相互不干扰，我们在程序之中只需要像上面的汇编一样代码从地址0开始一行一行的编写代码，等需要运行的时候再由操作系统将准备运行的程序进行重定位到内存上一个空闲的地方。这是不是很棒！</p>\n</li>\n<li><p>尽管地址空间解决了很大一部分问题,但是为了满足日益膨胀的软件规模,现有的内存已经或多或少不够用了,聪明的计算机大神们为了解决这些问题又用了一种新的技术:<strong>虚拟内存</strong>。虚拟内存的出现使得我们可以运行比内存容量大的多的程序。虚拟内存让每个程序有了自己的地址空间(上面提到的那个玩意儿)，这个空间被分成了多个块，每一块称作“<strong>页面</strong>“，可以理解所谓分页就是将我们的程序中的代码在逻辑上分成一块一块的，每一块的划分单位就是页面。运行程序时页面经由硬件执行必要的映射，使得我们程序中的虚拟地址成为我们计算机内存中真正的物理地址,完成了将程序的一部分真正的映射到了内存中</p>\n<blockquote>\n<p>这就是这篇文章要介绍的分页管理!看到这里脑中对虚拟内存和页面还没有概念？别着急，接着往下看就慢慢清楚了！)</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"让程序跑起来\"><a href=\"#让程序跑起来\" class=\"headerlink\" title=\"让程序跑起来!\"></a><strong>让程序跑起来!</strong></h1><p><img src=\"http://img.blog.csdn.net/20151113110518869\" alt=\"这里写图片描述\"></p>\n<ul>\n<li><p>图中左边是我们是<strong>页表</strong>(可以理解为一张记录页面与页框映射关系的一样表)。如果我们以4K为页面的大小单元的话(不是必须,但为普遍),我们的程序就需要:64&#x2F;4&#x3D;16个页面(就这样被切成了16块(｀･д･´))。但是，糟糕的问题是,真实的计算机中只有右边那可怜的32K内存,所以实际上它只能在真实的内存中保存8个<strong>页框</strong>(通常页面和页框的大小是相等的，因为他们需要进行后面提到的映射)。</p>\n</li>\n<li><p>假设程序刚开始运行时可能会用到程序中0页,1页，2页，3页，4页，5页，9页，11页中的代码。那么当程序运行的时候在真实内存中就需要更新页表(就是将我们需要用到的页面和叶框建立映射关系),并将我们需要用到的页加载到实际内存中,这样就建立好了映射关系(图中的箭头)。图中左边为已经建立好映射关系的页表。</p>\n</li>\n</ul>\n<h4 id=\"这里是第一种情况—命中\"><a href=\"#这里是第一种情况—命中\" class=\"headerlink\" title=\"这里是第一种情况—命中\"></a><strong>这里是第一种情况—命中</strong></h4><ul>\n<li>**注意!程序开始运行了!<strong>当我们的程序运行到0~4K行代码的时候,程序中使用到的一条 虚拟地址 会被送到一个叫</strong>内存管理单元(MMU)**的地方,MMU发现这条虚拟地址位于页表的第0页，于是它查询页表(页面就是页表中的索引，页表的索引从0开始,例如页面2就是页表中的第三项)发现第0页中存在内容(不存在内容的地方都打上的x),然后读取内容(页框编号)，接着这条虚拟地址中页面编号的部分就被替换为取出的页框编号部分,形成了真实的物理地址!</li>\n</ul>\n<h4 id=\"下面是另一种情况—缺页\"><a href=\"#下面是另一种情况—缺页\" class=\"headerlink\" title=\"下面是另一种情况—缺页\"></a><strong>下面是另一种情况—缺页</strong></h4><ul>\n<li>那么当我们的程序运行到24k~28k（页面7）的时候,传送的虚拟地址经MMU查询页表后发现页表中没有这个内容（标志为x）,也就是说真实内存中没有对应的页框！这时候MMU发出一个<strong>缺页中断</strong>,使得CPU陷入到操作系统。操作系统会在页表中通过页表置换算法找到一个可以移除的表项，然后将导致陷入中断的的那部分程序加载入内存,更新页表,使得页面7有了对应的页框，然后重新启动引起陷阱的指令，这样就完成了页表的更新。当然被如果程序运行到了被移除的那个表项对应的页面上就会又掉进陷阱(陷入操作系统)，继续更新页表。。。</li>\n</ul>\n<blockquote>\n<p>(这就是分页的基本过程，看完如果没有深入骨髓的理解就请点击右上角。。。好吧，我就随便说说哈。。。这里只需要有个大致的理解页面管理系统是如何运作的就好~(～o￣▽￣)～o)。</p>\n</blockquote>\n<h3 id=\"接下来就是细腻的重点——页表\"><a href=\"#接下来就是细腻的重点——页表\" class=\"headerlink\" title=\"接下来就是细腻的重点——页表\"></a>接下来就是细腻的重点——<strong>页表</strong></h3><p>话不多说直接上图:<br><img src=\"http://img.blog.csdn.net/20151113121634038\" alt=\"这里写图片描述\"><br>注:在我们刚刚的程序中主机有16位地址线。</p>\n<ul>\n<li>在虚拟地址中,16位的虚拟地址前4位(足够能表示我们分出来的16个页面)作为页面的编号,后12位(表示内存大小为4096个字节)则为<strong>偏移地址</strong>。<h4 id=\"地址映射的步骤\"><a href=\"#地址映射的步骤\" class=\"headerlink\" title=\"地址映射的步骤\"></a><strong>地址映射的步骤</strong></h4></li>\n<li>那让我们看看如果在程序中有个语句要访问地址:8196(二进制为:0010 00000000000100,注意中间那个忧伤的空格)这个地址时事实又是怎么样的呢？</li>\n</ul>\n<p> 1.MMU发现8196这个地址存在于第3页(8k~12k),查询得到内容为110(也就是6)</p>\n<p> 2.检查页表第3表项中的状态标志(测试状态标志再后面，别着急后面会说明页表项)发现标志为’1’(即该页面对应的页框存在于内存中),一切测试通过!</p>\n<p> 3.最重要的最后一步:将得到的3位<strong>页框编号</strong>加上虚拟地址中的12位<strong>偏移地址</strong>，这样就形成了<strong>15位的物理地址</strong>，虚拟地址就这样完成了从8196映射到了内存中24580(位于页7 24k~28k)这个<strong>物理地址</strong>了!</p>\n<p> 以上就是分页管理映射的大概流程。</p>\n<h3 id=\"接下来需要知道的是—页表项\"><a href=\"#接下来需要知道的是—页表项\" class=\"headerlink\" title=\"接下来需要知道的是—页表项\"></a>接下来需要知道的是—<strong>页表项</strong></h3><p>在上一个图中我们当我们取得一个页框的时候并不能仅仅只是进行数位的替换,还需要测试页表项的许多位，<br>继续放图:<br><img src=\"http://img.blog.csdn.net/20151113105401242\" alt=\"这里写图片描述\"></p>\n<ul>\n<li><p><strong>高速缓存位</strong>:可以禁止页面被缓存,CPU希望IO等设备从接口直接取得数据,而不是从内存中一个缓存的副本中。</p>\n</li>\n<li><p><strong>访问位</strong>:当前页被访问时会被设置，此位可以帮助操作系统的页面置换算法。</p>\n</li>\n<li><p><strong>修改位</strong>:当前页内容被修改后该位会被设置,当页面置换算法决定需要从表项中移除此页面时如果发现被修改了则需要将修改后的数据重新写入硬盘中。如果没被修改则可以直接丢弃。</p>\n</li>\n<li><p><strong>保护位</strong>:说明了当前页面允许执行的操作（读&#x2F;写&#x2F;执行 等，这个位在平常的系统权限管理中相当重要!）。</p>\n</li>\n<li><p><strong>是否存在位</strong>:表明了当前页框是否存在于内存当中,此位可以用来判断是否缺页。</p>\n</li>\n</ul>\n<p>以上的这些位都是在查询页表的过程中被测试的。比如代码段的页面会被设置为只读，如果一不小心程序企图写入这个页面，那么操作系统就会发出一个信号给进程并停止进程，告诉它”你摊上大事了!”Σ( ° △ °|||)︴</p>\n<h2 id=\"更快-更快-更快-——快表\"><a href=\"#更快-更快-更快-——快表\" class=\"headerlink\" title=\"更快!更快!更快!——快表\"></a>更快!更快!更快!——<strong>快表</strong></h2><ul>\n<li><p>在使用分页管理后使得内存的管理更加方便了，但是有一个问题一直在头上萦绕不去”如果我们每次关于内存的操作都要完整的查询一次整个页表的话那无疑是非常没有效率并且非常笨的”。机智的计算机大神们在这个问题出现后’噔’的一下计算机大神们就想出了可以利用**检测缓冲区(TLB也就是”快表”)**这个设备解决这个问题。</p>\n</li>\n<li><p>快表就是将<strong>少量且常用</strong>的<strong>页面</strong>放在一个区域(硬件或内存,取决于具体实现)中,每次的查询操作会先在快表中寻找,如果命中且符合测试条件(即测试各种标志位),则直接在快表中取出页框号,然后执行地址映射的流程。如果在快表内未命中则会进行正常的页表查询(在内存中),并在快表中淘汰一个页表项给这个新的页面替换。</p>\n</li>\n<li><p>TLB可以使用硬件也可以使用软件实现。</p>\n</li>\n</ul>\n<p> 1.当在软件TLB中未差找到页表项但是内存中有时，就会发生一个”<strong>软中断</strong>“,接着就会更新一下TLB(从内存中将页表项读入TLB)。</p>\n<p> 2.如果在 TLB和 内存中都未找到页表项时就会发生一个”<strong>硬中断</strong>“,此时则会从硬盘中读取页面并更新TLB。所以我们页可以想象到硬中断相比软中断来说要耗费巨大的时间。</p>\n<hr>\n<h1 id=\"拥抱更大的内存\"><a href=\"#拥抱更大的内存\" class=\"headerlink\" title=\"拥抱更大的内存!\"></a><strong>拥抱更大的内存!</strong></h1><h3 id=\"32位计算机的到来\"><a href=\"#32位计算机的到来\" class=\"headerlink\" title=\"32位计算机的到来\"></a><strong>32位计算机的到来</strong></h3><p>时代在进步，很快计算机发展到了32位，这也使得有了更大虚拟地址空间和物理内存。再像之前那样将所有表项都放在一个页表中显然会带来效率等各种问题(比如32位机支持最大4GB内存,那么我们需要的页表项的数目为:(4<em>1024</em>1024)&#x2F;4&#x3D;1048576项,足足有一百多万项!)。于是又一个解决办法出现了。。。</p>\n<h4 id=\"—多级页表\"><a href=\"#—多级页表\" class=\"headerlink\" title=\"—多级页表\"></a><strong>—多级页表</strong></h4><p>嘿!上图:<br><img src=\"http://img.blog.csdn.net/20151113105455525\" alt=\"这里写图片描述\"><br>多级页表就如名字一样有很多层的划分，这里以2级页表举例(再多也一样，只是更加复杂)</p>\n<ul>\n<li><p>想一下当我们还在16位CPU的时代，通过将<strong>后12位作为偏移地址，前4为作为页面编号</strong>解决了分页问题，成功的跑起了那个小程序。与时俱进的我们怎么能够满足于现状!为了拥抱更大的内存。</p>\n</li>\n<li><p>我们需要将当前的32位地址进行<strong>重新的划分:前10位为目录，中间10位为页面，后12位为偏移地址</strong>。(想象一下顶级页表可以有2^10&#x3D;1024个项，而每个二级页表可以表4k*1024&#x3D;4MB的空间，也就是说一个顶级页表可以表4MB×1024&#x3D;4GB的空间，这刚好是32位计算机能支持的最大内存)。</p>\n</li>\n<li><p>当我们查找一条虚拟地址时，通过:</p>\n</li>\n</ul>\n<p> <strong>1.前10位索引查找到顶级页表中的二级页表地址</strong><br> <strong>2.通过虚拟地址的中间10位索引到二级页表中的页表项</strong><br> <strong>3.接下来就使用查找到的页表项中的页框号加上虚拟地址最后的12位偏移地址</strong>组成了真实的物理地址!</p>\n<ul>\n<li>在一个进程执行的时候它实际上也许只需要几个页表。当程序一不小心访问到其他页面的时候无法通过标志位测试而回给操作系统发出”缺页中断“,操作系统检测到了这个进程又企图访问我们不想让它看到的地方，于是又发给它个信号说”你又摊上大事了!”Σ( ° △ °|||)︴，然后无情关闭了它。</li>\n</ul>\n<hr>\n<h3 id=\"64位需要更机智的页表方法\"><a href=\"#64位需要更机智的页表方法\" class=\"headerlink\" title=\"64位需要更机智的页表方法\"></a><strong>64位需要更机智的页表方法</strong></h3><blockquote>\n<p>虽然多级页表在32位机上有一个很好的表现，但是时代又进步了!64位计算机开始普遍。<br>地址空间增长到了2^64,如果页面大小依旧为4kb，那么需要有一个2^52个表项的页表。再如果每个表项8个字节，那么需要多么大的容量你们可以自己算一算(美到不敢想象～)。<br>那么问题就又来了。。。<br>不过既然我们有2^64这么大的虚拟地址空间，而仅仅只有几个G可怜的小内存那么咱们之前用过的分页肯定就是不能继续再使用了。如果我们。。。换一下?<strong>是的!</strong><br>——我们可以改变由虚拟地址映射物理地址的做法而直接由物理地址映射到虚拟地址!这么一变我们的页表就变小的可以接受了。。。这就是</p>\n</blockquote>\n<h4 id=\"—倒排列表\"><a href=\"#—倒排列表\" class=\"headerlink\" title=\"—倒排列表\"></a><strong>—倒排列表</strong></h4><ul>\n<li><p>先抛出<strong>缺点</strong>:倒排列表虽然会缩小页表的规模，但是它会使得从虚拟地址到物理地址的转化过程变得相当困难(反向查找，想想就难受)。</p>\n</li>\n<li><p>当然有缺点我们就要克服缺点!这次又该轮到TLB出场了,由TLB缓存住经常使用的页面可以大大加快效率。但是如果发生缺页时我们应该怎么办？一条条翻完整个倒排页表来找嘛？—**怎么会!**那可不得累死了。。。∑(っ°Д°;)っ。</p>\n</li>\n<li><p>所以机智的计算机大神们又带来的新的解决方案—<strong>散列</strong>!通过将虚拟页面进行散列,如果将散列的虚拟页面与物理页面一样多，那么冲突链都会是可以接受的范围。所以通过<strong>散列+TLB</strong>的方法成功的将我们从超过3000万GB的页表中释放出来!<br>o(<em>￣▽￣</em>)ブ这可得好好庆祝下。。。</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"关于各种页面置换算法\"><a href=\"#关于各种页面置换算法\" class=\"headerlink\" title=\"关于各种页面置换算法\"></a><strong>关于各种页面置换算法</strong></h1><h4 id=\"（额。那又是一个大坑。。-╮-╯-╰-╭）\"><a href=\"#（额。那又是一个大坑。。-╮-╯-╰-╭）\" class=\"headerlink\" title=\"（额。那又是一个大坑。。 ╮(╯_╰)╭）\"></a><strong>（额。那又是一个大坑。。 ╮(╯_╰)╭）</strong></h4><p>所以这里就贴部分算法的百度连接大家有兴趣的可以看看～</p>\n<p>1.<a href=\"http://baike.baidu.com/link?url=8kFsLNxCkL6ZRQ1qInfj40MCrscXKdFaDMlQnDsT-TuUEXDPj_kU80MQbrFTXZa7XpWEHYi_g5d5Krd0y22ob_\">最佳页面置换算法</a><br>2.最近未使用页面置换算法(么有链接额。。)<br>3.<a href=\"http://baike.baidu.com/view/9932283.htm\">先进先出页面置换算法</a><br>4.<a href=\"http://baike.baidu.com/view/5015063.htm\">第二次机会页面置换算法</a><br>5.<a href=\"http://baike.baidu.com/link?url=kbCAbFPDXXwEF4IWsBIcFFygCDjIeJ_6ib80LRRrzgM_CFpS2Ks3G8mXqF1s0iSVpX-f_Jf8zx2asSpi-C943_\">时钟页面置换算法</a><br>6.<a href=\"http://wenku.baidu.com/link?url=I66I9aDoWU0PVNEMHpYln4P0G4ej0oY-5rqeoaPzGNHrfAdxpvgX0p_hq8CtL8Vksyoc3KNwbuGuZRKknzvTWi4_eGBIlqmA0G3BYczLnzO\">最近最少使用页面算法</a><br>7.<a href=\"DWg4lIV3Jg27fRuB2H1wInOvqEhEcEzJaQMXCHzVvgHEnu94tHsZOM283eytRUuDD6Vmk72I8Wgqe7J9lnJHDDwoRNLtnxlIPlXAcbd1o1e\">工作集页面置换算法</a><br>8.工作集时钟页面置换算法(么有链接额。。)</p>\n<hr>\n<h1 id=\"段页式管理\"><a href=\"#段页式管理\" class=\"headerlink\" title=\"段页式管理\"></a><strong>段页式管理</strong></h1><p>分段的实现我们都不会陌生，程序就是由许许多多的段构成并且在内存中运行的。<br>段的大小可以是不固定的，相反页的大小是固定的。但是如果在操作系统中只有段的存在必然会与分区管理一样容易产生内存碎片(好慌~)。如果我门将段的管理与页的管理相结合。。。<br>那么就是又一个新的管理方式!!!(好累…(┙&gt;∧&lt;)┙へ┻┻)</p>\n<p>段页式管理其实就是在段的偏移地址里面容纳了页面号组成了<strong>段+页面+偏移地址</strong>的虚拟地址格式，所以理解了分页管理这里也很容易 o(*≧▽≦)ツ┏━┓。</p>\n<p>在操作系统中则为进程维护了一张类似这样的几张表:<br><img src=\"http://img.blog.csdn.net/20151113105527579\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>没错，了解了前面的分页管理方式后我们应该可以很明白的看懂这个的地址转换方式。现在让我们回顾下开头的汇编程序，找到那个<strong>code segment</strong>,这就是<strong>段</strong>!当我们程序发现要执行code段的时候将段描述符所指向页表的<strong>地址</strong>加载入<strong>寄存器</strong>(方便接下来指令的快速查找)。然后就是通过虚拟地址的中间的页面号在页表中查找对应的页表项。再然后的然后就你就会噢的一下都懂了～<blockquote>\n<p>一切似乎又有了熟悉的味道。。。(￣▽￣”) 。。。</p>\n</blockquote>\n</li>\n</ul>\n<p> 最后附上参考资料:《现代操作系统》-Andrew S.Tanenbaum</p>\n<p>如有错误希望能得到指点,不胜感激 :D</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>“那是在一个还只有汇编语言的时代，一只满怀梦想的新手程序猿刚刚完成了一个小程序。“保存，运行，完美！”。可是好奇心强的他发现一些很有意思的事情:</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>为何一个64kb的程序能够在一个只有32kb内存的电脑里运行?</li>\n<li>为什么运行中的程序能够互不干扰,结束后又能继续运行新的程序?”</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>于是新奇的翻开书,发现了操作系统背着程序员偷偷做的一系列幕后工作。。。</p>\n</blockquote>","more":"<h1 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a><strong>地址空间</strong></h1><p>这一切让我先从我们平常最熟悉的程序开始说起,以便先了解两个基本的概念：</p>\n<h4 id=\"1-虚拟地址\"><a href=\"#1-虚拟地址\" class=\"headerlink\" title=\"1.虚拟地址\"></a><strong>1.虚拟地址</strong></h4><pre><code>data segment\ntab db &#39;hello world$&#39;  ;\ndata ends\ncode segment\nassume cs:code, ds:data  ;\nstart:\n        mov ax,data\n        mov ds,ax        \n        lea dx,tab\n        mov ah,9h\n        int 21h\n        mov ah,4ch\n        int 21h        \n code  ends\n        end start   \n</code></pre>\n<ul>\n<li><p>这是一个用汇编写的HelloWorld程序。程序中有<strong>数据段</strong>(datasegment)和<strong>代码段</strong>(code segment),关于段页式管理的部分后面再说。这里每行代码的的偏移地址我们记做它为<strong>虚拟地址</strong>，因为这个地址只是在程序中是从0开始增加,运行时会被映射而产生变化的地址,所以它并不是真实的物理地址而是属于逻辑上划分的。(多亏有虚拟空间这个东西,要不我们以后写代码还得考虑每条的地理位置简直心累！)</p>\n</li>\n<li><p>例如第一个mov指令(mov ax,data)，我们可以看作在代码段内的偏移地址为0，而第二条指令(mov ds,ax)的偏移地址则应该为:<strong>上一条的虚拟地址+上一条指令的长度</strong>。</p>\n</li>\n</ul>\n<h4 id=\"2-虚拟内存\"><a href=\"#2-虚拟内存\" class=\"headerlink\" title=\"2.虚拟内存\"></a><strong>2.虚拟内存</strong></h4><ul>\n<li><p>在最早的计算机中是没有存储器这个抽象的概念，这就意味这每个程序猿在写程序的时候直接用的是<strong>物理地址</strong>！在这种简单粗暴的寻址方式下出现的就是无数令人抓狂的问题。程序中的每条指令需要在内存中有固定的位置，如果位置上有别人正在运行,那么就是一切崩溃的开始(╯‵□′)╯︵┻━┻。甚至用户程序可能一个不小心就会毁掉操作系统！</p>\n</li>\n<li><p>所以为了<strong>宇宙和平</strong>！操作系统为每个进程提供相互独立的内存地址空间就变的刻不容缓。于是乎出现了一种<strong>存储器抽象:地址空间</strong>。它可以令操作系统在程序运行时完成对进程的<strong>保护</strong>和<strong>重定位</strong>,使得进程之间的运行相互不干扰，我们在程序之中只需要像上面的汇编一样代码从地址0开始一行一行的编写代码，等需要运行的时候再由操作系统将准备运行的程序进行重定位到内存上一个空闲的地方。这是不是很棒！</p>\n</li>\n<li><p>尽管地址空间解决了很大一部分问题,但是为了满足日益膨胀的软件规模,现有的内存已经或多或少不够用了,聪明的计算机大神们为了解决这些问题又用了一种新的技术:<strong>虚拟内存</strong>。虚拟内存的出现使得我们可以运行比内存容量大的多的程序。虚拟内存让每个程序有了自己的地址空间(上面提到的那个玩意儿)，这个空间被分成了多个块，每一块称作“<strong>页面</strong>“，可以理解所谓分页就是将我们的程序中的代码在逻辑上分成一块一块的，每一块的划分单位就是页面。运行程序时页面经由硬件执行必要的映射，使得我们程序中的虚拟地址成为我们计算机内存中真正的物理地址,完成了将程序的一部分真正的映射到了内存中</p>\n<blockquote>\n<p>这就是这篇文章要介绍的分页管理!看到这里脑中对虚拟内存和页面还没有概念？别着急，接着往下看就慢慢清楚了！)</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h1 id=\"让程序跑起来\"><a href=\"#让程序跑起来\" class=\"headerlink\" title=\"让程序跑起来!\"></a><strong>让程序跑起来!</strong></h1><p><img src=\"http://img.blog.csdn.net/20151113110518869\" alt=\"这里写图片描述\"></p>\n<ul>\n<li><p>图中左边是我们是<strong>页表</strong>(可以理解为一张记录页面与页框映射关系的一样表)。如果我们以4K为页面的大小单元的话(不是必须,但为普遍),我们的程序就需要:64&#x2F;4&#x3D;16个页面(就这样被切成了16块(｀･д･´))。但是，糟糕的问题是,真实的计算机中只有右边那可怜的32K内存,所以实际上它只能在真实的内存中保存8个<strong>页框</strong>(通常页面和页框的大小是相等的，因为他们需要进行后面提到的映射)。</p>\n</li>\n<li><p>假设程序刚开始运行时可能会用到程序中0页,1页，2页，3页，4页，5页，9页，11页中的代码。那么当程序运行的时候在真实内存中就需要更新页表(就是将我们需要用到的页面和叶框建立映射关系),并将我们需要用到的页加载到实际内存中,这样就建立好了映射关系(图中的箭头)。图中左边为已经建立好映射关系的页表。</p>\n</li>\n</ul>\n<h4 id=\"这里是第一种情况—命中\"><a href=\"#这里是第一种情况—命中\" class=\"headerlink\" title=\"这里是第一种情况—命中\"></a><strong>这里是第一种情况—命中</strong></h4><ul>\n<li>**注意!程序开始运行了!<strong>当我们的程序运行到0~4K行代码的时候,程序中使用到的一条 虚拟地址 会被送到一个叫</strong>内存管理单元(MMU)**的地方,MMU发现这条虚拟地址位于页表的第0页，于是它查询页表(页面就是页表中的索引，页表的索引从0开始,例如页面2就是页表中的第三项)发现第0页中存在内容(不存在内容的地方都打上的x),然后读取内容(页框编号)，接着这条虚拟地址中页面编号的部分就被替换为取出的页框编号部分,形成了真实的物理地址!</li>\n</ul>\n<h4 id=\"下面是另一种情况—缺页\"><a href=\"#下面是另一种情况—缺页\" class=\"headerlink\" title=\"下面是另一种情况—缺页\"></a><strong>下面是另一种情况—缺页</strong></h4><ul>\n<li>那么当我们的程序运行到24k~28k（页面7）的时候,传送的虚拟地址经MMU查询页表后发现页表中没有这个内容（标志为x）,也就是说真实内存中没有对应的页框！这时候MMU发出一个<strong>缺页中断</strong>,使得CPU陷入到操作系统。操作系统会在页表中通过页表置换算法找到一个可以移除的表项，然后将导致陷入中断的的那部分程序加载入内存,更新页表,使得页面7有了对应的页框，然后重新启动引起陷阱的指令，这样就完成了页表的更新。当然被如果程序运行到了被移除的那个表项对应的页面上就会又掉进陷阱(陷入操作系统)，继续更新页表。。。</li>\n</ul>\n<blockquote>\n<p>(这就是分页的基本过程，看完如果没有深入骨髓的理解就请点击右上角。。。好吧，我就随便说说哈。。。这里只需要有个大致的理解页面管理系统是如何运作的就好~(～o￣▽￣)～o)。</p>\n</blockquote>\n<h3 id=\"接下来就是细腻的重点——页表\"><a href=\"#接下来就是细腻的重点——页表\" class=\"headerlink\" title=\"接下来就是细腻的重点——页表\"></a>接下来就是细腻的重点——<strong>页表</strong></h3><p>话不多说直接上图:<br><img src=\"http://img.blog.csdn.net/20151113121634038\" alt=\"这里写图片描述\"><br>注:在我们刚刚的程序中主机有16位地址线。</p>\n<ul>\n<li>在虚拟地址中,16位的虚拟地址前4位(足够能表示我们分出来的16个页面)作为页面的编号,后12位(表示内存大小为4096个字节)则为<strong>偏移地址</strong>。<h4 id=\"地址映射的步骤\"><a href=\"#地址映射的步骤\" class=\"headerlink\" title=\"地址映射的步骤\"></a><strong>地址映射的步骤</strong></h4></li>\n<li>那让我们看看如果在程序中有个语句要访问地址:8196(二进制为:0010 00000000000100,注意中间那个忧伤的空格)这个地址时事实又是怎么样的呢？</li>\n</ul>\n<p> 1.MMU发现8196这个地址存在于第3页(8k~12k),查询得到内容为110(也就是6)</p>\n<p> 2.检查页表第3表项中的状态标志(测试状态标志再后面，别着急后面会说明页表项)发现标志为’1’(即该页面对应的页框存在于内存中),一切测试通过!</p>\n<p> 3.最重要的最后一步:将得到的3位<strong>页框编号</strong>加上虚拟地址中的12位<strong>偏移地址</strong>，这样就形成了<strong>15位的物理地址</strong>，虚拟地址就这样完成了从8196映射到了内存中24580(位于页7 24k~28k)这个<strong>物理地址</strong>了!</p>\n<p> 以上就是分页管理映射的大概流程。</p>\n<h3 id=\"接下来需要知道的是—页表项\"><a href=\"#接下来需要知道的是—页表项\" class=\"headerlink\" title=\"接下来需要知道的是—页表项\"></a>接下来需要知道的是—<strong>页表项</strong></h3><p>在上一个图中我们当我们取得一个页框的时候并不能仅仅只是进行数位的替换,还需要测试页表项的许多位，<br>继续放图:<br><img src=\"http://img.blog.csdn.net/20151113105401242\" alt=\"这里写图片描述\"></p>\n<ul>\n<li><p><strong>高速缓存位</strong>:可以禁止页面被缓存,CPU希望IO等设备从接口直接取得数据,而不是从内存中一个缓存的副本中。</p>\n</li>\n<li><p><strong>访问位</strong>:当前页被访问时会被设置，此位可以帮助操作系统的页面置换算法。</p>\n</li>\n<li><p><strong>修改位</strong>:当前页内容被修改后该位会被设置,当页面置换算法决定需要从表项中移除此页面时如果发现被修改了则需要将修改后的数据重新写入硬盘中。如果没被修改则可以直接丢弃。</p>\n</li>\n<li><p><strong>保护位</strong>:说明了当前页面允许执行的操作（读&#x2F;写&#x2F;执行 等，这个位在平常的系统权限管理中相当重要!）。</p>\n</li>\n<li><p><strong>是否存在位</strong>:表明了当前页框是否存在于内存当中,此位可以用来判断是否缺页。</p>\n</li>\n</ul>\n<p>以上的这些位都是在查询页表的过程中被测试的。比如代码段的页面会被设置为只读，如果一不小心程序企图写入这个页面，那么操作系统就会发出一个信号给进程并停止进程，告诉它”你摊上大事了!”Σ( ° △ °|||)︴</p>\n<h2 id=\"更快-更快-更快-——快表\"><a href=\"#更快-更快-更快-——快表\" class=\"headerlink\" title=\"更快!更快!更快!——快表\"></a>更快!更快!更快!——<strong>快表</strong></h2><ul>\n<li><p>在使用分页管理后使得内存的管理更加方便了，但是有一个问题一直在头上萦绕不去”如果我们每次关于内存的操作都要完整的查询一次整个页表的话那无疑是非常没有效率并且非常笨的”。机智的计算机大神们在这个问题出现后’噔’的一下计算机大神们就想出了可以利用**检测缓冲区(TLB也就是”快表”)**这个设备解决这个问题。</p>\n</li>\n<li><p>快表就是将<strong>少量且常用</strong>的<strong>页面</strong>放在一个区域(硬件或内存,取决于具体实现)中,每次的查询操作会先在快表中寻找,如果命中且符合测试条件(即测试各种标志位),则直接在快表中取出页框号,然后执行地址映射的流程。如果在快表内未命中则会进行正常的页表查询(在内存中),并在快表中淘汰一个页表项给这个新的页面替换。</p>\n</li>\n<li><p>TLB可以使用硬件也可以使用软件实现。</p>\n</li>\n</ul>\n<p> 1.当在软件TLB中未差找到页表项但是内存中有时，就会发生一个”<strong>软中断</strong>“,接着就会更新一下TLB(从内存中将页表项读入TLB)。</p>\n<p> 2.如果在 TLB和 内存中都未找到页表项时就会发生一个”<strong>硬中断</strong>“,此时则会从硬盘中读取页面并更新TLB。所以我们页可以想象到硬中断相比软中断来说要耗费巨大的时间。</p>\n<hr>\n<h1 id=\"拥抱更大的内存\"><a href=\"#拥抱更大的内存\" class=\"headerlink\" title=\"拥抱更大的内存!\"></a><strong>拥抱更大的内存!</strong></h1><h3 id=\"32位计算机的到来\"><a href=\"#32位计算机的到来\" class=\"headerlink\" title=\"32位计算机的到来\"></a><strong>32位计算机的到来</strong></h3><p>时代在进步，很快计算机发展到了32位，这也使得有了更大虚拟地址空间和物理内存。再像之前那样将所有表项都放在一个页表中显然会带来效率等各种问题(比如32位机支持最大4GB内存,那么我们需要的页表项的数目为:(4<em>1024</em>1024)&#x2F;4&#x3D;1048576项,足足有一百多万项!)。于是又一个解决办法出现了。。。</p>\n<h4 id=\"—多级页表\"><a href=\"#—多级页表\" class=\"headerlink\" title=\"—多级页表\"></a><strong>—多级页表</strong></h4><p>嘿!上图:<br><img src=\"http://img.blog.csdn.net/20151113105455525\" alt=\"这里写图片描述\"><br>多级页表就如名字一样有很多层的划分，这里以2级页表举例(再多也一样，只是更加复杂)</p>\n<ul>\n<li><p>想一下当我们还在16位CPU的时代，通过将<strong>后12位作为偏移地址，前4为作为页面编号</strong>解决了分页问题，成功的跑起了那个小程序。与时俱进的我们怎么能够满足于现状!为了拥抱更大的内存。</p>\n</li>\n<li><p>我们需要将当前的32位地址进行<strong>重新的划分:前10位为目录，中间10位为页面，后12位为偏移地址</strong>。(想象一下顶级页表可以有2^10&#x3D;1024个项，而每个二级页表可以表4k*1024&#x3D;4MB的空间，也就是说一个顶级页表可以表4MB×1024&#x3D;4GB的空间，这刚好是32位计算机能支持的最大内存)。</p>\n</li>\n<li><p>当我们查找一条虚拟地址时，通过:</p>\n</li>\n</ul>\n<p> <strong>1.前10位索引查找到顶级页表中的二级页表地址</strong><br> <strong>2.通过虚拟地址的中间10位索引到二级页表中的页表项</strong><br> <strong>3.接下来就使用查找到的页表项中的页框号加上虚拟地址最后的12位偏移地址</strong>组成了真实的物理地址!</p>\n<ul>\n<li>在一个进程执行的时候它实际上也许只需要几个页表。当程序一不小心访问到其他页面的时候无法通过标志位测试而回给操作系统发出”缺页中断“,操作系统检测到了这个进程又企图访问我们不想让它看到的地方，于是又发给它个信号说”你又摊上大事了!”Σ( ° △ °|||)︴，然后无情关闭了它。</li>\n</ul>\n<hr>\n<h3 id=\"64位需要更机智的页表方法\"><a href=\"#64位需要更机智的页表方法\" class=\"headerlink\" title=\"64位需要更机智的页表方法\"></a><strong>64位需要更机智的页表方法</strong></h3><blockquote>\n<p>虽然多级页表在32位机上有一个很好的表现，但是时代又进步了!64位计算机开始普遍。<br>地址空间增长到了2^64,如果页面大小依旧为4kb，那么需要有一个2^52个表项的页表。再如果每个表项8个字节，那么需要多么大的容量你们可以自己算一算(美到不敢想象～)。<br>那么问题就又来了。。。<br>不过既然我们有2^64这么大的虚拟地址空间，而仅仅只有几个G可怜的小内存那么咱们之前用过的分页肯定就是不能继续再使用了。如果我们。。。换一下?<strong>是的!</strong><br>——我们可以改变由虚拟地址映射物理地址的做法而直接由物理地址映射到虚拟地址!这么一变我们的页表就变小的可以接受了。。。这就是</p>\n</blockquote>\n<h4 id=\"—倒排列表\"><a href=\"#—倒排列表\" class=\"headerlink\" title=\"—倒排列表\"></a><strong>—倒排列表</strong></h4><ul>\n<li><p>先抛出<strong>缺点</strong>:倒排列表虽然会缩小页表的规模，但是它会使得从虚拟地址到物理地址的转化过程变得相当困难(反向查找，想想就难受)。</p>\n</li>\n<li><p>当然有缺点我们就要克服缺点!这次又该轮到TLB出场了,由TLB缓存住经常使用的页面可以大大加快效率。但是如果发生缺页时我们应该怎么办？一条条翻完整个倒排页表来找嘛？—**怎么会!**那可不得累死了。。。∑(っ°Д°;)っ。</p>\n</li>\n<li><p>所以机智的计算机大神们又带来的新的解决方案—<strong>散列</strong>!通过将虚拟页面进行散列,如果将散列的虚拟页面与物理页面一样多，那么冲突链都会是可以接受的范围。所以通过<strong>散列+TLB</strong>的方法成功的将我们从超过3000万GB的页表中释放出来!<br>o(<em>￣▽￣</em>)ブ这可得好好庆祝下。。。</p>\n</li>\n</ul>\n<hr>\n<h1 id=\"关于各种页面置换算法\"><a href=\"#关于各种页面置换算法\" class=\"headerlink\" title=\"关于各种页面置换算法\"></a><strong>关于各种页面置换算法</strong></h1><h4 id=\"（额。那又是一个大坑。。-╮-╯-╰-╭）\"><a href=\"#（额。那又是一个大坑。。-╮-╯-╰-╭）\" class=\"headerlink\" title=\"（额。那又是一个大坑。。 ╮(╯_╰)╭）\"></a><strong>（额。那又是一个大坑。。 ╮(╯_╰)╭）</strong></h4><p>所以这里就贴部分算法的百度连接大家有兴趣的可以看看～</p>\n<p>1.<a href=\"http://baike.baidu.com/link?url=8kFsLNxCkL6ZRQ1qInfj40MCrscXKdFaDMlQnDsT-TuUEXDPj_kU80MQbrFTXZa7XpWEHYi_g5d5Krd0y22ob_\">最佳页面置换算法</a><br>2.最近未使用页面置换算法(么有链接额。。)<br>3.<a href=\"http://baike.baidu.com/view/9932283.htm\">先进先出页面置换算法</a><br>4.<a href=\"http://baike.baidu.com/view/5015063.htm\">第二次机会页面置换算法</a><br>5.<a href=\"http://baike.baidu.com/link?url=kbCAbFPDXXwEF4IWsBIcFFygCDjIeJ_6ib80LRRrzgM_CFpS2Ks3G8mXqF1s0iSVpX-f_Jf8zx2asSpi-C943_\">时钟页面置换算法</a><br>6.<a href=\"http://wenku.baidu.com/link?url=I66I9aDoWU0PVNEMHpYln4P0G4ej0oY-5rqeoaPzGNHrfAdxpvgX0p_hq8CtL8Vksyoc3KNwbuGuZRKknzvTWi4_eGBIlqmA0G3BYczLnzO\">最近最少使用页面算法</a><br>7.<a href=\"DWg4lIV3Jg27fRuB2H1wInOvqEhEcEzJaQMXCHzVvgHEnu94tHsZOM283eytRUuDD6Vmk72I8Wgqe7J9lnJHDDwoRNLtnxlIPlXAcbd1o1e\">工作集页面置换算法</a><br>8.工作集时钟页面置换算法(么有链接额。。)</p>\n<hr>\n<h1 id=\"段页式管理\"><a href=\"#段页式管理\" class=\"headerlink\" title=\"段页式管理\"></a><strong>段页式管理</strong></h1><p>分段的实现我们都不会陌生，程序就是由许许多多的段构成并且在内存中运行的。<br>段的大小可以是不固定的，相反页的大小是固定的。但是如果在操作系统中只有段的存在必然会与分区管理一样容易产生内存碎片(好慌~)。如果我门将段的管理与页的管理相结合。。。<br>那么就是又一个新的管理方式!!!(好累…(┙&gt;∧&lt;)┙へ┻┻)</p>\n<p>段页式管理其实就是在段的偏移地址里面容纳了页面号组成了<strong>段+页面+偏移地址</strong>的虚拟地址格式，所以理解了分页管理这里也很容易 o(*≧▽≦)ツ┏━┓。</p>\n<p>在操作系统中则为进程维护了一张类似这样的几张表:<br><img src=\"http://img.blog.csdn.net/20151113105527579\" alt=\"这里写图片描述\"></p>\n<ul>\n<li>没错，了解了前面的分页管理方式后我们应该可以很明白的看懂这个的地址转换方式。现在让我们回顾下开头的汇编程序，找到那个<strong>code segment</strong>,这就是<strong>段</strong>!当我们程序发现要执行code段的时候将段描述符所指向页表的<strong>地址</strong>加载入<strong>寄存器</strong>(方便接下来指令的快速查找)。然后就是通过虚拟地址的中间的页面号在页表中查找对应的页表项。再然后的然后就你就会噢的一下都懂了～<blockquote>\n<p>一切似乎又有了熟悉的味道。。。(￣▽￣”) 。。。</p>\n</blockquote>\n</li>\n</ul>\n<p> 最后附上参考资料:《现代操作系统》-Andrew S.Tanenbaum</p>\n<p>如有错误希望能得到指点,不胜感激 :D</p>"},{"title":"我的第一个VLog","date":"2018-12-03T02:13:00.000Z","_content":"\n>\"There is only one kind of heroism, that is to see the true face of life and also to love it.”\n世界上只有一种英雄主义，那就是看清生活的真面目并且还能够热爱它。\n\n这是第二次去日本，同时也是第二次出国😅。上一次是5月中旬公司的团建。大概那次的所见让我对日本有了很好的印象，所以这次国庆的长假我选择了上次就想去的东京，感受下超级大都市的感觉。\n\n👉👉👉[**戳我看VLog**](https://www.bilibili.com/video/av37267520/)👈👈👈\n<!--more-->\n\n![东京全景](https://al6apa.dm.files.1drv.com/y4mE2COO5RTQSrwAIG1DhqDrJU8RsBTjiwOSfKh4NJRDnEZQadnbbz1jRQ_mKWxqNkWuzy2Q6MDooUzR7Q7dIHRp-uNtGxdAu3h7n7rGuVk8Wm7KeAriQrYrjS5H9t-mQOEIMMgP4Gvk4NqDggIL08GPyBySOmvbWOidwvnbe01o2aOCLYD259kZQbuvhfRzuQslDekt-MnekGcAAiWeVteaQ?width=1920&height=1080&cropmode=none)\n\n因为一直对于视频制作这方面也比较感兴趣，在出行前几星期突然想到可以拍一个VLog。于是立马下单买了个单反稳定器并且临时抱佛脚的看了点拍视频的小技巧。带上了我的a7m2就出发了（可惜a7m3才支持4k录制，这也是个小遗憾。。。）\n\n1号-10号总共在日本待了10天，在繁忙的工作间隙能这么长时间在一个陌生的国家游玩的真是一件非常幸福的事情。像我这种比较佛系的旅游，没有固定的地点，就是喜欢无方向的走在大街小巷。因为对我来说旅游不是打卡一个又一个的景点，而是享受那摆脱常规生活方式的束缚，在陌生的环境中感受世界的方式。\n\n虽然当时去的时候刚好遇到两个大台风，多半的天气都是阴沉沉的。但当有☀️的时候天真的超级漂亮！\n\n>富士山下河口湖\n\n![富士山下](https://bf7xba.dm.files.1drv.com/y4m2sC9qKiZA67ax6PLWsdqc2wJmtVa0ScDRAG8EZHKSNEYJpUZyH-yeShVX364uHR3qGIJIHfgjx0o2KVm3Kq1KI22rV-y-KTE0BGdU23hL2pngxC5bktwAp0yRHDdtpvHvJd-wZMXydx7d9DQIRey59YBuy_w5Z43e3rGgGoKXkGpvju6t2qMZqeoPADoE6g7Z7zTqoZuaeSIoWwmBIJeLA?width=1921&height=1080&cropmode=none)\n\n假期期间走的是 东京-箱根-富士山 这条线。由于不是跟团行，旅行的路线和目的都有了极大的自由度（基本都是早上醒来计划下一天的行程然后再订一下晚上住的地方，路上线路全靠谷歌 😎😎😎）\n不过因为没有提前做规划导致踩了很多坑。所以还是建议以后不要这样干=。=\n\n在东京吃了非常多次的寿司（不得不说我对🍣是真爱！）\n在箱根汤本泡热到窒息温泉\n在箱根町港坐帅气的海贼船\n在富士山下感受着山边美景\n在镰仓看到了动画中的电车\n\n>镰仓 江之岛站\n\n![江之电车](https://a17xba.dm.files.1drv.com/y4msj2p4Gydx0ZUHBCgPxO1Qu6l98jjONH4f4SUhqIgBVmPsSM9XJs9xnv7W-tJrL0oMIuXKxG86F_YdJKm10P8GNPlx-PTCiQEL9TmmB5YmSfM3S4juvApkox5TJGBEgi-pOzmpDLzGhI7V3egpbMQX2joPylCQzTyDRYyXEBmdn6sTUhLbFtUkGGerpFgPa_42Jmc0vo3FYsopupPMxa-dA?width=1920&height=1440&cropmode=none)\n\n从日本回来后开始看了很多视频制作相关的教学～看完很多 premiere，然后发现我笔记本带不起来。。。囧  \n\n发现我相机录制选错了格式，格式录成了25i、很多镜头都很晃、手机比例导致不得不放大图像等等。。。（此处哼略1万个坑😭😭😭）  \n\n不过好歹还是能勉强跟着音乐的节奏剪一下，这也是我在做视频方面迈出了的第一步，希望以后做视频的水平能够越来越高，学习更多技巧。同时也希望以后有机会去寻找更多的远方～\n\n> 镰仓 镰仓高校前站\n\n![镰仓高校前](https://pl3xba.dm.files.1drv.com/y4mRgxPglbXXj31zb4fbLdqSYG44EI6zVaCZIz-83yoHksc-a4kj5vYCICqpbVXwi4fZz4NGVrlZ12zHN3ECKbmq_Ah-ICLDwcrURC9paU0RkOGW3oPmyI_f6KbhkDmhimlZyM1LDEFJezTEM_jLLTv1Mq4RiwRt4jeYQkvmH5Ur6bwAP04oC3gmev3RsK5uWDbdDUTZireZaFi1nhY9u4gxw?width=1919&height=1282&cropmode=none)\n","source":"_posts/我的第一个VLog.md","raw":"---\ntitle: 我的第一个VLog\ndate: 2018-12-03 10:13:00\ntags:\n  - 日本\n  - 旅行\n  - VLog\n---\n\n>\"There is only one kind of heroism, that is to see the true face of life and also to love it.”\n世界上只有一种英雄主义，那就是看清生活的真面目并且还能够热爱它。\n\n这是第二次去日本，同时也是第二次出国😅。上一次是5月中旬公司的团建。大概那次的所见让我对日本有了很好的印象，所以这次国庆的长假我选择了上次就想去的东京，感受下超级大都市的感觉。\n\n👉👉👉[**戳我看VLog**](https://www.bilibili.com/video/av37267520/)👈👈👈\n<!--more-->\n\n![东京全景](https://al6apa.dm.files.1drv.com/y4mE2COO5RTQSrwAIG1DhqDrJU8RsBTjiwOSfKh4NJRDnEZQadnbbz1jRQ_mKWxqNkWuzy2Q6MDooUzR7Q7dIHRp-uNtGxdAu3h7n7rGuVk8Wm7KeAriQrYrjS5H9t-mQOEIMMgP4Gvk4NqDggIL08GPyBySOmvbWOidwvnbe01o2aOCLYD259kZQbuvhfRzuQslDekt-MnekGcAAiWeVteaQ?width=1920&height=1080&cropmode=none)\n\n因为一直对于视频制作这方面也比较感兴趣，在出行前几星期突然想到可以拍一个VLog。于是立马下单买了个单反稳定器并且临时抱佛脚的看了点拍视频的小技巧。带上了我的a7m2就出发了（可惜a7m3才支持4k录制，这也是个小遗憾。。。）\n\n1号-10号总共在日本待了10天，在繁忙的工作间隙能这么长时间在一个陌生的国家游玩的真是一件非常幸福的事情。像我这种比较佛系的旅游，没有固定的地点，就是喜欢无方向的走在大街小巷。因为对我来说旅游不是打卡一个又一个的景点，而是享受那摆脱常规生活方式的束缚，在陌生的环境中感受世界的方式。\n\n虽然当时去的时候刚好遇到两个大台风，多半的天气都是阴沉沉的。但当有☀️的时候天真的超级漂亮！\n\n>富士山下河口湖\n\n![富士山下](https://bf7xba.dm.files.1drv.com/y4m2sC9qKiZA67ax6PLWsdqc2wJmtVa0ScDRAG8EZHKSNEYJpUZyH-yeShVX364uHR3qGIJIHfgjx0o2KVm3Kq1KI22rV-y-KTE0BGdU23hL2pngxC5bktwAp0yRHDdtpvHvJd-wZMXydx7d9DQIRey59YBuy_w5Z43e3rGgGoKXkGpvju6t2qMZqeoPADoE6g7Z7zTqoZuaeSIoWwmBIJeLA?width=1921&height=1080&cropmode=none)\n\n假期期间走的是 东京-箱根-富士山 这条线。由于不是跟团行，旅行的路线和目的都有了极大的自由度（基本都是早上醒来计划下一天的行程然后再订一下晚上住的地方，路上线路全靠谷歌 😎😎😎）\n不过因为没有提前做规划导致踩了很多坑。所以还是建议以后不要这样干=。=\n\n在东京吃了非常多次的寿司（不得不说我对🍣是真爱！）\n在箱根汤本泡热到窒息温泉\n在箱根町港坐帅气的海贼船\n在富士山下感受着山边美景\n在镰仓看到了动画中的电车\n\n>镰仓 江之岛站\n\n![江之电车](https://a17xba.dm.files.1drv.com/y4msj2p4Gydx0ZUHBCgPxO1Qu6l98jjONH4f4SUhqIgBVmPsSM9XJs9xnv7W-tJrL0oMIuXKxG86F_YdJKm10P8GNPlx-PTCiQEL9TmmB5YmSfM3S4juvApkox5TJGBEgi-pOzmpDLzGhI7V3egpbMQX2joPylCQzTyDRYyXEBmdn6sTUhLbFtUkGGerpFgPa_42Jmc0vo3FYsopupPMxa-dA?width=1920&height=1440&cropmode=none)\n\n从日本回来后开始看了很多视频制作相关的教学～看完很多 premiere，然后发现我笔记本带不起来。。。囧  \n\n发现我相机录制选错了格式，格式录成了25i、很多镜头都很晃、手机比例导致不得不放大图像等等。。。（此处哼略1万个坑😭😭😭）  \n\n不过好歹还是能勉强跟着音乐的节奏剪一下，这也是我在做视频方面迈出了的第一步，希望以后做视频的水平能够越来越高，学习更多技巧。同时也希望以后有机会去寻找更多的远方～\n\n> 镰仓 镰仓高校前站\n\n![镰仓高校前](https://pl3xba.dm.files.1drv.com/y4mRgxPglbXXj31zb4fbLdqSYG44EI6zVaCZIz-83yoHksc-a4kj5vYCICqpbVXwi4fZz4NGVrlZ12zHN3ECKbmq_Ah-ICLDwcrURC9paU0RkOGW3oPmyI_f6KbhkDmhimlZyM1LDEFJezTEM_jLLTv1Mq4RiwRt4jeYQkvmH5Ur6bwAP04oC3gmev3RsK5uWDbdDUTZireZaFi1nhY9u4gxw?width=1919&height=1282&cropmode=none)\n","slug":"我的第一个VLog","published":1,"updated":"2022-02-27T13:20:40.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl05d6hi8000m5emtcfl9erce","content":"<blockquote>\n<p>“There is only one kind of heroism, that is to see the true face of life and also to love it.”<br>世界上只有一种英雄主义，那就是看清生活的真面目并且还能够热爱它。</p>\n</blockquote>\n<p>这是第二次去日本，同时也是第二次出国😅。上一次是5月中旬公司的团建。大概那次的所见让我对日本有了很好的印象，所以这次国庆的长假我选择了上次就想去的东京，感受下超级大都市的感觉。</p>\n<p>👉👉👉<a href=\"https://www.bilibili.com/video/av37267520/\"><strong>戳我看VLog</strong></a>👈👈👈</p>\n<span id=\"more\"></span>\n\n<p><img src=\"https://al6apa.dm.files.1drv.com/y4mE2COO5RTQSrwAIG1DhqDrJU8RsBTjiwOSfKh4NJRDnEZQadnbbz1jRQ_mKWxqNkWuzy2Q6MDooUzR7Q7dIHRp-uNtGxdAu3h7n7rGuVk8Wm7KeAriQrYrjS5H9t-mQOEIMMgP4Gvk4NqDggIL08GPyBySOmvbWOidwvnbe01o2aOCLYD259kZQbuvhfRzuQslDekt-MnekGcAAiWeVteaQ?width=1920&height=1080&cropmode=none\" alt=\"东京全景\"></p>\n<p>因为一直对于视频制作这方面也比较感兴趣，在出行前几星期突然想到可以拍一个VLog。于是立马下单买了个单反稳定器并且临时抱佛脚的看了点拍视频的小技巧。带上了我的a7m2就出发了（可惜a7m3才支持4k录制，这也是个小遗憾。。。）</p>\n<p>1号-10号总共在日本待了10天，在繁忙的工作间隙能这么长时间在一个陌生的国家游玩的真是一件非常幸福的事情。像我这种比较佛系的旅游，没有固定的地点，就是喜欢无方向的走在大街小巷。因为对我来说旅游不是打卡一个又一个的景点，而是享受那摆脱常规生活方式的束缚，在陌生的环境中感受世界的方式。</p>\n<p>虽然当时去的时候刚好遇到两个大台风，多半的天气都是阴沉沉的。但当有☀️的时候天真的超级漂亮！</p>\n<blockquote>\n<p>富士山下河口湖</p>\n</blockquote>\n<p><img src=\"https://bf7xba.dm.files.1drv.com/y4m2sC9qKiZA67ax6PLWsdqc2wJmtVa0ScDRAG8EZHKSNEYJpUZyH-yeShVX364uHR3qGIJIHfgjx0o2KVm3Kq1KI22rV-y-KTE0BGdU23hL2pngxC5bktwAp0yRHDdtpvHvJd-wZMXydx7d9DQIRey59YBuy_w5Z43e3rGgGoKXkGpvju6t2qMZqeoPADoE6g7Z7zTqoZuaeSIoWwmBIJeLA?width=1921&height=1080&cropmode=none\" alt=\"富士山下\"></p>\n<p>假期期间走的是 东京-箱根-富士山 这条线。由于不是跟团行，旅行的路线和目的都有了极大的自由度（基本都是早上醒来计划下一天的行程然后再订一下晚上住的地方，路上线路全靠谷歌 😎😎😎）<br>不过因为没有提前做规划导致踩了很多坑。所以还是建议以后不要这样干&#x3D;。&#x3D;</p>\n<p>在东京吃了非常多次的寿司（不得不说我对🍣是真爱！）<br>在箱根汤本泡热到窒息温泉<br>在箱根町港坐帅气的海贼船<br>在富士山下感受着山边美景<br>在镰仓看到了动画中的电车</p>\n<blockquote>\n<p>镰仓 江之岛站</p>\n</blockquote>\n<p><img src=\"https://a17xba.dm.files.1drv.com/y4msj2p4Gydx0ZUHBCgPxO1Qu6l98jjONH4f4SUhqIgBVmPsSM9XJs9xnv7W-tJrL0oMIuXKxG86F_YdJKm10P8GNPlx-PTCiQEL9TmmB5YmSfM3S4juvApkox5TJGBEgi-pOzmpDLzGhI7V3egpbMQX2joPylCQzTyDRYyXEBmdn6sTUhLbFtUkGGerpFgPa_42Jmc0vo3FYsopupPMxa-dA?width=1920&height=1440&cropmode=none\" alt=\"江之电车\"></p>\n<p>从日本回来后开始看了很多视频制作相关的教学～看完很多 premiere，然后发现我笔记本带不起来。。。囧  </p>\n<p>发现我相机录制选错了格式，格式录成了25i、很多镜头都很晃、手机比例导致不得不放大图像等等。。。（此处哼略1万个坑😭😭😭）  </p>\n<p>不过好歹还是能勉强跟着音乐的节奏剪一下，这也是我在做视频方面迈出了的第一步，希望以后做视频的水平能够越来越高，学习更多技巧。同时也希望以后有机会去寻找更多的远方～</p>\n<blockquote>\n<p>镰仓 镰仓高校前站</p>\n</blockquote>\n<p><img src=\"https://pl3xba.dm.files.1drv.com/y4mRgxPglbXXj31zb4fbLdqSYG44EI6zVaCZIz-83yoHksc-a4kj5vYCICqpbVXwi4fZz4NGVrlZ12zHN3ECKbmq_Ah-ICLDwcrURC9paU0RkOGW3oPmyI_f6KbhkDmhimlZyM1LDEFJezTEM_jLLTv1Mq4RiwRt4jeYQkvmH5Ur6bwAP04oC3gmev3RsK5uWDbdDUTZireZaFi1nhY9u4gxw?width=1919&height=1282&cropmode=none\" alt=\"镰仓高校前\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>“There is only one kind of heroism, that is to see the true face of life and also to love it.”<br>世界上只有一种英雄主义，那就是看清生活的真面目并且还能够热爱它。</p>\n</blockquote>\n<p>这是第二次去日本，同时也是第二次出国😅。上一次是5月中旬公司的团建。大概那次的所见让我对日本有了很好的印象，所以这次国庆的长假我选择了上次就想去的东京，感受下超级大都市的感觉。</p>\n<p>👉👉👉<a href=\"https://www.bilibili.com/video/av37267520/\"><strong>戳我看VLog</strong></a>👈👈👈</p>","more":"<p><img src=\"https://al6apa.dm.files.1drv.com/y4mE2COO5RTQSrwAIG1DhqDrJU8RsBTjiwOSfKh4NJRDnEZQadnbbz1jRQ_mKWxqNkWuzy2Q6MDooUzR7Q7dIHRp-uNtGxdAu3h7n7rGuVk8Wm7KeAriQrYrjS5H9t-mQOEIMMgP4Gvk4NqDggIL08GPyBySOmvbWOidwvnbe01o2aOCLYD259kZQbuvhfRzuQslDekt-MnekGcAAiWeVteaQ?width=1920&height=1080&cropmode=none\" alt=\"东京全景\"></p>\n<p>因为一直对于视频制作这方面也比较感兴趣，在出行前几星期突然想到可以拍一个VLog。于是立马下单买了个单反稳定器并且临时抱佛脚的看了点拍视频的小技巧。带上了我的a7m2就出发了（可惜a7m3才支持4k录制，这也是个小遗憾。。。）</p>\n<p>1号-10号总共在日本待了10天，在繁忙的工作间隙能这么长时间在一个陌生的国家游玩的真是一件非常幸福的事情。像我这种比较佛系的旅游，没有固定的地点，就是喜欢无方向的走在大街小巷。因为对我来说旅游不是打卡一个又一个的景点，而是享受那摆脱常规生活方式的束缚，在陌生的环境中感受世界的方式。</p>\n<p>虽然当时去的时候刚好遇到两个大台风，多半的天气都是阴沉沉的。但当有☀️的时候天真的超级漂亮！</p>\n<blockquote>\n<p>富士山下河口湖</p>\n</blockquote>\n<p><img src=\"https://bf7xba.dm.files.1drv.com/y4m2sC9qKiZA67ax6PLWsdqc2wJmtVa0ScDRAG8EZHKSNEYJpUZyH-yeShVX364uHR3qGIJIHfgjx0o2KVm3Kq1KI22rV-y-KTE0BGdU23hL2pngxC5bktwAp0yRHDdtpvHvJd-wZMXydx7d9DQIRey59YBuy_w5Z43e3rGgGoKXkGpvju6t2qMZqeoPADoE6g7Z7zTqoZuaeSIoWwmBIJeLA?width=1921&height=1080&cropmode=none\" alt=\"富士山下\"></p>\n<p>假期期间走的是 东京-箱根-富士山 这条线。由于不是跟团行，旅行的路线和目的都有了极大的自由度（基本都是早上醒来计划下一天的行程然后再订一下晚上住的地方，路上线路全靠谷歌 😎😎😎）<br>不过因为没有提前做规划导致踩了很多坑。所以还是建议以后不要这样干&#x3D;。&#x3D;</p>\n<p>在东京吃了非常多次的寿司（不得不说我对🍣是真爱！）<br>在箱根汤本泡热到窒息温泉<br>在箱根町港坐帅气的海贼船<br>在富士山下感受着山边美景<br>在镰仓看到了动画中的电车</p>\n<blockquote>\n<p>镰仓 江之岛站</p>\n</blockquote>\n<p><img src=\"https://a17xba.dm.files.1drv.com/y4msj2p4Gydx0ZUHBCgPxO1Qu6l98jjONH4f4SUhqIgBVmPsSM9XJs9xnv7W-tJrL0oMIuXKxG86F_YdJKm10P8GNPlx-PTCiQEL9TmmB5YmSfM3S4juvApkox5TJGBEgi-pOzmpDLzGhI7V3egpbMQX2joPylCQzTyDRYyXEBmdn6sTUhLbFtUkGGerpFgPa_42Jmc0vo3FYsopupPMxa-dA?width=1920&height=1440&cropmode=none\" alt=\"江之电车\"></p>\n<p>从日本回来后开始看了很多视频制作相关的教学～看完很多 premiere，然后发现我笔记本带不起来。。。囧  </p>\n<p>发现我相机录制选错了格式，格式录成了25i、很多镜头都很晃、手机比例导致不得不放大图像等等。。。（此处哼略1万个坑😭😭😭）  </p>\n<p>不过好歹还是能勉强跟着音乐的节奏剪一下，这也是我在做视频方面迈出了的第一步，希望以后做视频的水平能够越来越高，学习更多技巧。同时也希望以后有机会去寻找更多的远方～</p>\n<blockquote>\n<p>镰仓 镰仓高校前站</p>\n</blockquote>\n<p><img src=\"https://pl3xba.dm.files.1drv.com/y4mRgxPglbXXj31zb4fbLdqSYG44EI6zVaCZIz-83yoHksc-a4kj5vYCICqpbVXwi4fZz4NGVrlZ12zHN3ECKbmq_Ah-ICLDwcrURC9paU0RkOGW3oPmyI_f6KbhkDmhimlZyM1LDEFJezTEM_jLLTv1Mq4RiwRt4jeYQkvmH5Ur6bwAP04oC3gmev3RsK5uWDbdDUTZireZaFi1nhY9u4gxw?width=1919&height=1282&cropmode=none\" alt=\"镰仓高校前\"></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl05d6hhs00005emt1n3bfg3i","tag_id":"cl05d6hi000025emtffw0eb5n","_id":"cl05d6hi400075emt105w0e3d"},{"post_id":"cl05d6hhy00015emt2d33eaj6","tag_id":"cl05d6hi000025emtffw0eb5n","_id":"cl05d6hi6000a5emt8ui0bvco"},{"post_id":"cl05d6hi100035emta1hy27as","tag_id":"cl05d6hi000025emtffw0eb5n","_id":"cl05d6hi6000c5emtb37ahw05"},{"post_id":"cl05d6hi200045emt5x673j1z","tag_id":"cl05d6hi6000b5emt3hpjetgu","_id":"cl05d6hi7000e5emtf0ha4mdm"},{"post_id":"cl05d6hi300055emtf7fe4kpf","tag_id":"cl05d6hi6000d5emthchw97hs","_id":"cl05d6hi7000g5emteilqbrls"},{"post_id":"cl05d6hi400085emt6elnhtr4","tag_id":"cl05d6hi6000d5emthchw97hs","_id":"cl05d6hi8000j5emt26jz63zi"},{"post_id":"cl05d6hi400085emt6elnhtr4","tag_id":"cl05d6hi7000h5emtcuc261ww","_id":"cl05d6hi8000k5emt9diadrm4"},{"post_id":"cl05d6hi400085emt6elnhtr4","tag_id":"cl05d6hi7000i5emtbuqg58f5","_id":"cl05d6hi8000l5emtco3j2pex"},{"post_id":"cl05d6hi8000m5emtcfl9erce","tag_id":"cl05d6hi9000n5emt91as49pm","_id":"cl05d6hia000q5emtab6f8k0z"},{"post_id":"cl05d6hi8000m5emtcfl9erce","tag_id":"cl05d6hi9000o5emtdu5vdeiv","_id":"cl05d6hia000r5emtgvxs8rfg"},{"post_id":"cl05d6hi8000m5emtcfl9erce","tag_id":"cl05d6hi9000p5emt23pia48w","_id":"cl05d6hia000s5emt2s5sh2jk"}],"Tag":[{"name":"Beego Framework","_id":"cl05d6hi000025emtffw0eb5n"},{"name":"C++","_id":"cl05d6hi6000b5emt3hpjetgu"},{"name":"Linux","_id":"cl05d6hi6000d5emthchw97hs"},{"name":"Operating System","_id":"cl05d6hi7000h5emtcuc261ww"},{"name":"内存管理","_id":"cl05d6hi7000i5emtbuqg58f5"},{"name":"日本","_id":"cl05d6hi9000n5emt91as49pm"},{"name":"旅行","_id":"cl05d6hi9000o5emtdu5vdeiv"},{"name":"VLog","_id":"cl05d6hi9000p5emt23pia48w"}]}}